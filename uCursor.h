//---------------------------------------------------------------------------

#ifndef uCursorH
#define uCursorH
//---------------------------------------------------------------------------
#include "uIter.h"
//---------------------------------------------------------------------------
namespace SHEdit
{
  class TSHEdit;
    class Iter;
    
    /*! CIter/Cursor Iterator
     * =====================
     * Cursor Iterator is (mostly) automatically generated wrapper of the Iter class. The only purpose of this class is to provide an abstract layer that lets user (or rather developer using this component from outside) to perform iterator-oriented edits on buffer while taking care of redrawing the component appropriately. It also server as a front-end for cursors. 
     *
     * Some definitions in this file (and in cpp) are generated by a perl script. In order to update these run ./perl uCursor.h uCursor.cpp from a shell (or use perl directly, providing the file names as separate arguments).
     * */

    #define CITER_BEGIN 1
    #define CITER_END 2
    #define CITER_BOTH 3
    
    class CIter
    {
      private:
             CIter(TSHEdit * component, const Iter& itr, short type, bool myown); //to be called only by the component
              TSHEdit * component;
              friend class TSHEdit;
                Iter itr;
                short type;
                bool myown;
                
                void Init();
                void Update();
      public:
               CIter(const CIter& c);
               ~CIter();

               Iter * GetIter();
             void Insert(String xText);
             void DeleteTo(CIter& itr);
             
               /*AUTOINCLUDE_HEAD_CIter_uIter.h*/
      /*AUTOGENERATED*/ bool  CIter::Valid ()   ; 
      /*AUTOGENERATED*/ bool  CIter::GoLine (bool allowEnd = false)  ;                               /*!< Goes to the pos 0 of next line. That is the offset 0 of first Span after nextline NSpan */
      /*AUTOGENERATED*/ bool  CIter::GoLineEnd ()  ; 
      /*AUTOGENERATED*/ bool  CIter::GoLineStart ()  ; 
      /*AUTOGENERATED*/ bool  CIter::RevLine ()  ; 
      /*AUTOGENERATED*/ bool  CIter::RevLineBegin ()  ; 
      /*AUTOGENERATED*/ bool  CIter::GoChar ()  ;                                                    /*!< Increments iterator by 1 */
      /*AUTOGENERATED*/ bool  CIter::RevChar ()  ; 
      /*AUTOGENERATED*/ wchar_t  CIter::GetNextChar ()  ; 
      /*AUTOGENERATED*/ wchar_t  CIter::GetChar ()  ; 
      /*AUTOGENERATED*/ int  CIter::GetLineNum ()  ; 
      /*AUTOGENERATED*/ void  CIter::GoWordLiteral ()  ;                                             /*!< goes to next start of a word (alnum + underscore) */
      /*AUTOGENERATED*/ void  CIter::RevWordLiteral ()  ;                                            /*!< goes to previous start of a word (alnum + underscore) */
      /*AUTOGENERATED*/ int  CIter::GetLeftOffset ()  ;                                              /*!< Returns left offset counting tabs as multiple characters according to the tabstop */
      /*AUTOGENERATED*/ void  CIter::GoByOffset (int chars)  ;                                       /*!< Goes forward countint tabs as multiple characters according to the tabstop. Always stays on the same line. */
      /*AUTOGENERATED*/ void  CIter::GoBy (int chars, bool multiline = false)  ;                     /*!< Goes forward counting tabs as single character. Always stays on the same line. */
      /*AUTOGENERATED*/ void  CIter::GoLeft (int chars, bool multiline = false)  ;                   /*!< Goes forward counting tabs as single character. always stays on the same line */
      /*AUTOGENERATED*/ int  CIter::GetDistance (Iter* itr)  ; 
      /*AUTOGENERATED*/ void  CIter::MarkupBegin (SHEdit::Format * format)  ;                        /*!< Adds positionless markup. For formatting overview see \ref index */
      /*AUTOGENERATED*/ void  CIter::MarkupEnd (SHEdit::Format * format)  ;                          /*!< Adds positionless markup. For formatting overview see \ref index */
      /*AUTOGENERATED*/ void  CIter::MarkupRem (SHEdit::Format * format)  ;                          /*!< Removes all positionless markup from current position. For formatting overview see \ref index */
      /*AUTOGENERATED*/ bool  CIter::FindNext (wchar_t * string, bool skip = true, bool caseSensitive = true, bool wholeword = false)  ; /*!< skip defines whether to match word directly at cursor or not */
      /*AUTOGENERATED*/ bool  CIter::FindPrev (wchar_t * string, bool skip = true, bool caseSensitive = true, bool wholeword= false)  ; /*!< same as findnext */
      /*AUTOGENERATED*/ bool  CIter::IsUnderCursor (const wchar_t *& string, bool caseSensitive, bool wholeword)  ; /*!< Tests if the string is at the position of cursor. Serves for FindNext/FindNext. */
      /*AUTOGENERATED*/ bool  CIter::LineIsEmpty ( bool allowWhite = false)  ; 
      /*AUTOGENERATED*/ void  CIter::GoToLine (int line)  ; 
      /*AUTOGENERATED*/ String  CIter::GetLine ()  ; 
    };
}
//---------------------------------------------------------------------------
#endif
