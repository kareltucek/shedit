//---------------------------------------------------------------------------

#ifndef uCursorH
#define uCursorH
//---------------------------------------------------------------------------
#include "uIter.h"
//---------------------------------------------------------------------------
namespace SHEdit
{
  class TSHEdit;
  class Iter;

  /*! CIter/Cursor Iterator
   * =====================
   * Cursor Iterator is (mostly) automatically generated wrapper of the Iter class. The only purpose of this class is to provide an abstract layer that lets user (or rather developer using this component from outside) to perform iterator-oriented edits on buffer while taking care of redrawing the component appropriately. It also server as a front-end for cursors. 
   * */

  class CIter
  {
    private:
      TSHEdit * component;
      Iter itr;
      bool second;
      bool myown;

      void Init();
      void Update();
    public:
      CIter(TSHEdit * component, const Iter& itr, bool second, bool myown);
      CIter(const CIter& c);
      ~CIter();

      Iter * GetIter();
      void Insert(String xText);
      void DeleteTo(CIter& itr);

      /*AUTOINCLUDE_HEAD_CIter_uIter.h*/
      /*AUTOGENERATED*/ bool  Valid ()   ; 
      /*AUTOGENERATED*/ bool  GoLine (bool allowEnd = false)  ;                                      /*!< Goes to the pos 0 of next line. That is the offset 0 of first Span after nextline NSpan */
      /*AUTOGENERATED*/ bool  GoLineEnd ()  ; 
      /*AUTOGENERATED*/ bool  GoLineStart ()  ; 
      /*AUTOGENERATED*/ bool  RevLine ()  ; 
      /*AUTOGENERATED*/ bool  RevLineBegin ()  ; 
      /*AUTOGENERATED*/ bool  GoChar ()  ;                                                           /*!< Increments iterator by 1 */
      /*AUTOGENERATED*/ bool  RevChar ()  ; 
      /*AUTOGENERATED*/ wchar_t  GetNextChar ()  ; 
      /*AUTOGENERATED*/ wchar_t  GetChar ()  ; 
      /*AUTOGENERATED*/ int  GetLineNum ()  ; 
      /*AUTOGENERATED*/ int  GetLeftOffset ()  ;                                                     /*!< Returns left offset counting tabs as multiple characters according to the tabstop */
      /*AUTOGENERATED*/ void  GoByOffset (int chars)  ;                                              /*!< Goes forward countint tabs as multiple characters according to the tabstop. Always stays on the same line. */
      /*AUTOGENERATED*/ void  GoBy (int chars, bool multiline = false)  ;                            /*!< Goes forward counting tabs as single character. Always stays on the same line. */
      /*AUTOGENERATED*/ void  GoLeft (int chars, bool multiline = false)  ;                          /*!< Goes forward counting tabs as single character. always stays on the same line */
      /*AUTOGENERATED*/ int  GetDistance (Iter* itr)  ; 
      /*AUTOGENERATED*/ void  MarkupBegin (SHEdit::Format * format)  ;                               /*!< Adds positionless markup. For formatting overview see \ref index */
      /*AUTOGENERATED*/ void  MarkupEnd (SHEdit::Format * format)  ;                                 /*!< Adds positionless markup. For formatting overview see \ref index */
      /*AUTOGENERATED*/ void  MarkupRem (SHEdit::Format * format)  ;                                 /*!< Removes all positionless markup from current position. For formatting overview see \ref index */
      /*AUTOGENERATED*/ bool  FindNext (wchar_t * string, bool skip = true, bool caseSensitive = true, bool wholeword = false)  ; /*!< skip defines whether to match word directly at cursor or not */
      /*AUTOGENERATED*/ bool  FindPrev (wchar_t * string, bool skip = true, bool caseSensitive = true, bool wholeword= false)  ; /*!< same as findnext */
      /*AUTOGENERATED*/ bool  IsUnderCursor (const wchar_t *& string, bool caseSensitive, bool wholeword)  ;   //used as test for search;
      /*AUTOGENERATED*/ bool  LineIsEmpty ()  ; 
      /*AUTOGENERATED*/ void  GoToLine (int line)  ; 
      /*AUTOGENERATED*/ String  GetLine ()  ; 
  };
}
//---------------------------------------------------------------------------
#endif
