//---------------------------------------------------------------------------


#pragma hdrstop

#include "uCursor.h"
#include "uIter.h"
#include "cSHEdit.h"

using namespace SHEdit;
//---------------------------------------------------------------------------
CIter::CIter(TSHEdit * component, const Iter& itr, bool second, bool myown)
: itr(itr), component(component), second(second), myown(myown)
{
}
//---------------------------------------------------------------------------
CIter::CIter(const CIter& c)
: itr(c.itr), component(c.component), second(c.second), myown(myown)
{
}
//---------------------------------------------------------------------------
void CIter::Init()
{
  if(!myown)
  {
    if(second)
    {
      itr = *component->GetCursorIterEnd();
        if(!itr.Valid())
          itr = *component->GetCursorIter();
    }
    else
    {
      itr = *component->GetCursorIter();
        if(!itr.Valid())
          itr = *component->GetCursorIterEnd();
    }
  }
}
//---------------------------------------------------------------------------
void CIter::Update()
{
  if(!myown)
  {
    if(second)
      component->SetSelection(component->GetCursorIter(),&itr);
    else
      component->SetSelection(&itr, component->GetCursorIterEnd());
  }
}
//---------------------------------------------------------------------------
CIter::~CIter()
{
}
//---------------------------------------------------------------------------
Iter* CIter::GetIter()
{
  return &itr;
}
//---------------------------------------------------------------------------
void CIter::Insert(String text)
{
  if(myown)
    component->Insert(text.c_str(), &itr);
  else
    component->Insert(text.c_str());
}
//---------------------------------------------------------------------------
void CIter::DeleteTo(CIter& itr)
{
  if(this->itr < itr.itr)
    component->DeleteSel(true, GetIter(), itr.GetIter());
  else
    component->DeleteSel(true, itr.GetIter(), GetIter());
}
//---------------------------------------------------------------------------
//auto generation has to be executed manually by "./autogen uCursor.cpp uCursor.h" (or preferably "./autogen *c *h") in an environment with working perl every time a maintainer wants the autogenerated interface to be up-to-date
/*AUTOINCLUDE_BODY_CIter_uIter.h*/
/*AUTOGENERATED*/ bool  CIter::Valid ()   { Init();  return  this->itr.Valid ();} 
/*AUTOGENERATED*/ bool  CIter::GoLine (bool allowEnd )  { Init(); bool  tmp =  this->itr.GoLine (allowEnd); Update();  return  tmp;} /*!< Goes to the pos 0 of next line. That is the offset 0 of first Span after nextline NSpan */
/*AUTOGENERATED*/ bool  CIter::GoLineEnd ()  { Init(); bool  tmp =  this->itr.GoLineEnd (); Update();  return  tmp;}  
/*AUTOGENERATED*/ bool  CIter::GoLineStart ()  { Init(); bool  tmp =  this->itr.GoLineStart (); Update();  return  tmp;}  
/*AUTOGENERATED*/ bool  CIter::RevLine ()  { Init(); bool  tmp =  this->itr.RevLine (); Update();  return  tmp;}  
/*AUTOGENERATED*/ bool  CIter::RevLineBegin ()  { Init(); bool  tmp =  this->itr.RevLineBegin (); Update();  return  tmp;}  
/*AUTOGENERATED*/ bool  CIter::GoChar ()  { Init(); bool  tmp =  this->itr.GoChar (); Update();  return  tmp;} /*!< Increments iterator by 1 */
/*AUTOGENERATED*/ bool  CIter::RevChar ()  { Init(); bool  tmp =  this->itr.RevChar (); Update();  return  tmp;}  
/*AUTOGENERATED*/ wchar_t  CIter::GetNextChar ()  { Init();  return  this->itr.GetNextChar ();} 
/*AUTOGENERATED*/ wchar_t  CIter::GetChar ()  { Init();  return  this->itr.GetChar ();} 
/*AUTOGENERATED*/ int  CIter::GetLineNum ()  { Init();  return  this->itr.GetLineNum ();} 
/*AUTOGENERATED*/ void  CIter::GoWordLiteral ()  { Init();  this->itr.GoWordLiteral (); Update();  } /*!< goes to next start of a word (alnum + underscore) */
/*AUTOGENERATED*/ void  CIter::RevWordLiteral ()  { Init();  this->itr.RevWordLiteral (); Update();  } /*!< goes to previous start of a word (alnum + underscore) */
/*AUTOGENERATED*/ int  CIter::GetLeftOffset ()  { Init();  return  this->itr.GetLeftOffset ();} /*!< Returns left offset counting tabs as multiple characters according to the tabstop */
/*AUTOGENERATED*/ void  CIter::GoByOffset (int chars)  { Init();  this->itr.GoByOffset (chars); Update();  } /*!< Goes forward countint tabs as multiple characters according to the tabstop. Always stays on the same line. */
/*AUTOGENERATED*/ void  CIter::GoBy (int chars, bool multiline )  { Init();  this->itr.GoBy (chars,multiline); Update();  } /*!< Goes forward counting tabs as single character. Always stays on the same line. */
/*AUTOGENERATED*/ void  CIter::GoLeft (int chars, bool multiline )  { Init();  this->itr.GoLeft (chars,multiline); Update();  } /*!< Goes forward counting tabs as single character. always stays on the same line */
/*AUTOGENERATED*/ int  CIter::GetDistance (Iter* itr)  { Init();  return  this->itr.GetDistance (itr);} 
/*AUTOGENERATED*/ void  CIter::MarkupBegin (SHEdit::Format * format)  { Init();  this->itr.MarkupBegin (format);} /*!< Adds positionless markup. For formatting overview see \ref index */
/*AUTOGENERATED*/ void  CIter::MarkupEnd (SHEdit::Format * format)  { Init();  this->itr.MarkupEnd (format);} /*!< Adds positionless markup. For formatting overview see \ref index */
/*AUTOGENERATED*/ void  CIter::MarkupRem (SHEdit::Format * format)  { Init();  this->itr.MarkupRem (format);} /*!< Removes all positionless markup from current position. For formatting overview see \ref index */
/*AUTOGENERATED*/ bool  CIter::FindNext (wchar_t * string, bool skip , bool caseSensitive , bool wholeword )  { Init(); bool  tmp =  this->itr.FindNext (string,skip,caseSensitive,wholeword); Update();  return  tmp;} /*!< skip defines whether to match word directly at cursor or not */
/*AUTOGENERATED*/ bool  CIter::FindPrev (wchar_t * string, bool skip , bool caseSensitive , bool wholeword)  { Init(); bool  tmp =  this->itr.FindPrev (string,skip,caseSensitive,wholeword); Update();  return  tmp;} /*!< same as findnext */
/*AUTOGENERATED*/ bool  CIter::IsUnderCursor (const wchar_t *& string, bool caseSensitive, bool wholeword)  { Init();  return  this->itr.IsUnderCursor (string,caseSensitive,wholeword);} /*!< Tests if the string is at the position of cursor. Serves for FindNext/FindNext. */
/*AUTOGENERATED*/ bool  CIter::LineIsEmpty ()  { Init();  return  this->itr.LineIsEmpty ();} 
/*AUTOGENERATED*/ void  CIter::GoToLine (int line)  { Init();  this->itr.GoToLine (line); Update();  }  
/*AUTOGENERATED*/ String  CIter::GetLine ()  { Init();  return  this->itr.GetLine ();} 
#pragma package(smart_init)
