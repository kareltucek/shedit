!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ALLOW_TABS	config.h	21;"	d
Action	cSHEdit.cpp	/^void TSHEdit::Action(String msg, bool end)$/;"	f	class:TSHEdit	signature:(String msg, bool end)
Action	cSHEdit.h	/^      void Action(String name, bool end = true);$/;"	p	class:SHEdit::TSHEdit	access:private	signature:(String name, bool end = true)
Action	uSpan.cpp	/^Action::Action(int fromlinenum, int tolinenum, int frompos, int topos, ActionType type)$/;"	f	class:Action	signature:(int fromlinenum, int tolinenum, int frompos, int topos, ActionType type)
Action	uSpan.h	/^    Action(int fromlinenum, int tolinenum, int frompos, int topos, ActionType type);$/;"	p	struct:SHEdit::Action	access:public	signature:(int fromlinenum, int tolinenum, int frompos, int topos, ActionType type)
Action	uSpan.h	/^  struct Action$/;"	s	namespace:SHEdit
Action::Action	uSpan.cpp	/^Action::Action(int fromlinenum, int tolinenum, int frompos, int topos, ActionType type)$/;"	f	class:Action	signature:(int fromlinenum, int tolinenum, int frompos, int topos, ActionType type)
Action::~Action	uSpan.cpp	/^Action::~Action()$/;"	f	class:Action	signature:()
ActionType	uSpan.h	/^    enum ActionType{deletion, insertion};$/;"	g	struct:SHEdit::Action	access:public
Add	uFormat.cpp	/^void Format::Add(Stack<SHEdit::Mark>::Node* mark)$/;"	f	class:Format	signature:(Stack<SHEdit::Mark>::Node* mark)
Add	uFormat.h	/^      void Add(Stack<Mark>::Node * mark);$/;"	p	class:SHEdit::Format	access:public	signature:(Stack<Mark>::Node * mark)
Add	uLanguageDefinition2.cpp	/^LanguageDefinition::Node* LanguageDefinition::Node::Add(const Node& n)$/;"	f	class:LanguageDefinition::Node	signature:(const Node& n)
Add	uLanguageDefinition2.h	/^        Node* Add(const Node& n); \/\/returns a pointer to a used node (either a new node, or an already existing done)$/;"	p	struct:SHEdit::LanguageDefinition::Node	access:public	signature:(const Node& n)
AddChar	uParser.cpp	/^void Parser::AddChar(Iter * itr, int & pos)$/;"	f	class:Parser	signature:(Iter * itr, int & pos)
AddChar	uParser.h	/^      void AddChar(Iter * itr, int & pos);$/;"	p	class:SHEdit::Parser	access:private	signature:(Iter * itr, int & pos)
AddDupTree	DOCUMENTATION	/^      TreeNode * AddDupTree(TreeNode * tree, FontStyle * format); $/;"	p	file:	signature:(TreeNode * tree, FontStyle * format)
AddDupTree	uLanguageDefinition.cpp	/^LanguageDefinition::TreeNode * LanguageDefinition::AddDupTree(LanguageDefinition::TreeNode * tree, FontStyle * format)$/;"	f	class:LanguageDefinition	signature:(LanguageDefinition::TreeNode * tree, FontStyle * format)
AddDupTree	uLanguageDefinition.h	/^      TreeNode * AddDupTree(TreeNode * tree, FontStyle * format);                                    \/*!< Duplicates the base of tree provided with the format provided. All pointers remain intact - one tree may have more than one bases. By making changes that are deeper than the duplicated TreeNode's member pointers, then you are making changes to both trees. *\/$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(TreeNode * tree, FontStyle * format)
AddIM	uFormat.cpp	/^void Format::AddIM(IMark * mark)$/;"	f	class:Format	signature:(IMark * mark)
AddIM	uFormat.h	/^      void AddIM(IMark * mark);$/;"	p	class:SHEdit::Format	access:public	signature:(IMark * mark)
AddJump	DOCUMENTATION	/^      void AddJump(wchar_t * string, FontStyle * format, LangDefJumpType type, TreeNode * at, TreeNode * to, short jumpmask = 0, short newmask = 0, short gmask= 0); $/;"	p	file:	signature:(wchar_t * string, FontStyle * format, LangDefJumpType type, TreeNode * at, TreeNode * to, short jumpmask = 0, short newmask = 0, short gmask= 0)
AddJump	uLanguageDefinition.cpp	/^void LanguageDefinition::AddJump(wchar_t * string, FontStyle * format, LangDefJumpType type, TreeNode * at, TreeNode * to, short jumpmask, short newmask, short gmask)$/;"	f	class:LanguageDefinition	signature:(wchar_t * string, FontStyle * format, LangDefJumpType type, TreeNode * at, TreeNode * to, short jumpmask, short newmask, short gmask)
AddJump	uLanguageDefinition.cpp	/^void LanguageDefinition::TreeNode::AddJump(short pushmask, short newmask, short gmask, LangDefJumpType _type, TreeNode * to, bool begin, FontStyle * format)$/;"	f	class:LanguageDefinition::TreeNode	signature:(short pushmask, short newmask, short gmask, LangDefJumpType _type, TreeNode * to, bool begin, FontStyle * format)
AddJump	uLanguageDefinition.h	/^        void AddJump(short pushmask, short newmask, short newgmask, LangDefJumpType type, TreeNode * to, bool begin, FontStyle *format);$/;"	p	struct:SHEdit::LanguageDefinition::TreeNode	access:public	signature:(short pushmask, short newmask, short newgmask, LangDefJumpType type, TreeNode * to, bool begin, FontStyle *format)
AddJump	uLanguageDefinition.h	/^      void AddJump(wchar_t * string, FontStyle * format, LangDefJumpType type, TreeNode * at, TreeNode * to, short jumpmask = 0, short newmask = 0, short gmask= 0); \/*!< Adds a custom jump from "at" tree to "to" tree. String is a space separated list.*\/$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(wchar_t * string, FontStyle * format, LangDefJumpType type, TreeNode * at, TreeNode * to, short jumpmask = 0, short newmask = 0, short gmask= 0)
AddJumpFront	uLanguageDefinition.cpp	/^void LanguageDefinition::AddJumpFront(wchar_t * string, FontStyle * format, LangDefJumpType type, TreeNode * at, TreeNode * to, short jumpmask, short newmask, short gmask)$/;"	f	class:LanguageDefinition	signature:(wchar_t * string, FontStyle * format, LangDefJumpType type, TreeNode * at, TreeNode * to, short jumpmask, short newmask, short gmask)
AddJumpFront	uLanguageDefinition.h	/^      void AddJumpFront(wchar_t * string, FontStyle * format, LangDefJumpType type, TreeNode * at, TreeNode * to, short jumpmask = 0, short newmask = 0, short gmask= 0); \/*!< Like AddJump but adds new jumps to the beginning of jump list.*\/$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(wchar_t * string, FontStyle * format, LangDefJumpType type, TreeNode * at, TreeNode * to, short jumpmask = 0, short newmask = 0, short gmask= 0)
AddJumps	uLanguageDefinition.cpp	/^void LanguageDefinition::AddJumps(wchar_t * string, FontStyle * format, LangDefJumpType type, TreeNode * at, TreeNode * to, short jumpmask, short newmask, short gmask)$/;"	f	class:LanguageDefinition	signature:(wchar_t * string, FontStyle * format, LangDefJumpType type, TreeNode * at, TreeNode * to, short jumpmask, short newmask, short gmask)
AddJumps	uLanguageDefinition.h	/^      void AddJumps(wchar_t * string, FontStyle * format, LangDefJumpType type, TreeNode * at, TreeNode * to, short jumpmask = 0, short newmask = 0, short newgmask= 0); \/*!< Just an abreviation. *\/$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(wchar_t * string, FontStyle * format, LangDefJumpType type, TreeNode * at, TreeNode * to, short jumpmask = 0, short newmask = 0, short newgmask= 0)
AddJumpsFront	uLanguageDefinition.cpp	/^void LanguageDefinition::AddJumpsFront(wchar_t * string, FontStyle * format, LangDefJumpType type, TreeNode * at, TreeNode * to, short jumpmask, short newmask, short gmask)$/;"	f	class:LanguageDefinition	signature:(wchar_t * string, FontStyle * format, LangDefJumpType type, TreeNode * at, TreeNode * to, short jumpmask, short newmask, short gmask)
AddJumpsFront	uLanguageDefinition.h	/^      void AddJumpsFront(wchar_t * string, FontStyle * format, LangDefJumpType type, TreeNode * at, TreeNode * to, short jumpmask = 0, short newmask = 0, short newgmask= 0); \/*!< Just an abreviation. *\/$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(wchar_t * string, FontStyle * format, LangDefJumpType type, TreeNode * at, TreeNode * to, short jumpmask = 0, short newmask = 0, short newgmask= 0)
AddKeywords	uLanguageDefinition.cpp	/^void LanguageDefinition::AddKeywords(wchar_t * string, FontStyle * format, TreeNode * at)$/;"	f	class:LanguageDefinition	signature:(wchar_t * string, FontStyle * format, TreeNode * at)
AddKeywords	uLanguageDefinition.h	/^      void AddKeywords(wchar_t * string, FontStyle * format, TreeNode * at = NULL);                  \/*!< Adds all words that are contained in string (as space-separated list) to the tree given as "at". If tree is not given, then the main root is used *\/$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(wchar_t * string, FontStyle * format, TreeNode * at = NULL)
AddLine	DOCUMENTATION	/^      TreeNode * AddLine(wchar_t * string, FontStyle * format, TreeNode * at = NULL, TreeNode * to = NULL); $/;"	p	file:	signature:(wchar_t * string, FontStyle * format, TreeNode * at = NULL, TreeNode * to = NULL)
AddLine	cSHEdit.cpp	/^void TSHEdit::AddLine(const String& string, SHEdit::Format * format)$/;"	f	class:TSHEdit	signature:(const String& string, SHEdit::Format * format)
AddLine	cSHEdit.h	/^      void AddLine(const String& string, Format * format = NULL);$/;"	p	class:SHEdit::TSHEdit	access:public	signature:(const String& string, Format * format = NULL)
AddLine	uLanguageDefinition.cpp	/^LanguageDefinition::TreeNode* LanguageDefinition::AddLine(wchar_t * string, FontStyle * format, TreeNode * at, TreeNode * to)$/;"	f	class:LanguageDefinition	signature:(wchar_t * string, FontStyle * format, TreeNode * at, TreeNode * to)
AddLine	uLanguageDefinition.h	/^      TreeNode * AddLine(wchar_t * string, FontStyle * format, TreeNode * at = NULL, TreeNode * to = NULL); \/*!< Adds a linetag item - as c commenting \/\/. Returns new tree that was created for the line's formatting. Is an abbreviation for double jump. *\/$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(wchar_t * string, FontStyle * format, TreeNode * at = NULL, TreeNode * to = NULL)
AddLineStrong	DOCUMENTATION	/^      TreeNode * AddLineStrong(wchar_t * string, FontStyle * format, TreeNode * at = NULL, TreeNode * to = NULL); $/;"	p	file:	signature:(wchar_t * string, FontStyle * format, TreeNode * at = NULL, TreeNode * to = NULL)
AddLineStrong	uLanguageDefinition.cpp	/^LanguageDefinition::TreeNode* LanguageDefinition::AddLineStrong(wchar_t * string, FontStyle * format, TreeNode * at, TreeNode * to)$/;"	f	class:LanguageDefinition	signature:(wchar_t * string, FontStyle * format, TreeNode * at, TreeNode * to)
AddLineStrong	uLanguageDefinition.h	/^      TreeNode * AddLineStrong(wchar_t * string, FontStyle * format, TreeNode * at = NULL, TreeNode * to = NULL); \/*!< as AddLine, but stores entire state of parser and at the end of line it restores it back. *\/$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(wchar_t * string, FontStyle * format, TreeNode * at = NULL, TreeNode * to = NULL)
AddLines	cSHEdit.cpp	/^void TSHEdit::AddLines(const String& string, SHEdit::Format * format)$/;"	f	class:TSHEdit	signature:(const String& string, SHEdit::Format * format)
AddLines	cSHEdit.h	/^      void AddLines(const String& string, Format * format = NULL);$/;"	p	class:SHEdit::TSHEdit	access:public	signature:(const String& string, Format * format = NULL)
AddNewTree	DOCUMENTATION	/^      TreeNode * AddNewTree(FontStyle * format); $/;"	p	file:	signature:(FontStyle * format)
AddNewTree	uLanguageDefinition.cpp	/^LanguageDefinition::TreeNode * LanguageDefinition::AddNewTree(FontStyle * format)$/;"	f	class:LanguageDefinition	signature:(FontStyle * format)
AddNewTree	uLanguageDefinition.cpp	/^LanguageDefinition::TreeNode * LanguageDefinition::AddNewTree(FontStyle * format, bool caseSensit)$/;"	f	class:LanguageDefinition	signature:(FontStyle * format, bool caseSensit)
AddNewTree	uLanguageDefinition.h	/^      TreeNode * AddNewTree(FontStyle * format);                                                     \/*!< Just creates and returns an empty new tree with format as the default format *\/$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(FontStyle * format)
AddNewTree	uLanguageDefinition.h	/^      TreeNode * AddNewTree(FontStyle * format, bool caseSensitive);                                 \/*!< Just creates and returns an empty new tree with format as the default format *\/$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(FontStyle * format, bool caseSensitive)
AddNonTerm	uLanguageDefinition2.cpp	/^void LanguageDefinition::AddNonTerm(const std::wstring& name, FontStyle* fs, int id, int flags)$/;"	f	class:LanguageDefinition	signature:(const std::wstring& name, FontStyle* fs, int id, int flags)
AddNonTerm	uLanguageDefinition2.h	/^      void AddNonTerm(const std::wstring& name, FontStyle* fs, int id, int flags);$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(const std::wstring& name, FontStyle* fs, int id, int flags)
AddPair	DOCUMENTATION	/^      TreeNode * AddPair(wchar_t * opening, wchar_t * closing, FontStyle * format, TreeNode * at = NULL, TreeNode * to = NULL); $/;"	p	file:	signature:(wchar_t * opening, wchar_t * closing, FontStyle * format, TreeNode * at = NULL, TreeNode * to = NULL)
AddPair	uLanguageDefinition.cpp	/^LanguageDefinition::TreeNode* LanguageDefinition::AddPair(wchar_t * opening, wchar_t * closing, FontStyle * format, TreeNode * at, TreeNode * to)$/;"	f	class:LanguageDefinition	signature:(wchar_t * opening, wchar_t * closing, FontStyle * format, TreeNode * at, TreeNode * to)
AddPair	uLanguageDefinition.h	/^      TreeNode * AddPair(wchar_t * opening, wchar_t * closing, FontStyle * format, TreeNode * at = NULL, TreeNode * to = NULL); \/*!< Is just an abreviation for two jumps. Adds jump from "opening" tag at "at" tree to newly created tree and then corresponding jump back *\/$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(wchar_t * opening, wchar_t * closing, FontStyle * format, TreeNode * at = NULL, TreeNode * to = NULL)
AddPop	DOCUMENTATION	/^      void AddPop(wchar_t * string, FontStyle * format, TreeNode * at, short popmask, short popcount = -2, short newgmask = 0);$/;"	p	file:	signature:(wchar_t * string, FontStyle * format, TreeNode * at, short popmask, short popcount = -2, short newgmask = 0)
AddPop	uLanguageDefinition.cpp	/^void LanguageDefinition::AddPop(wchar_t * string, FontStyle * format, TreeNode * at, short popmask, short popcount, short newgmask)$/;"	f	class:LanguageDefinition	signature:(wchar_t * string, FontStyle * format, TreeNode * at, short popmask, short popcount, short newgmask)
AddPop	uLanguageDefinition.cpp	/^void LanguageDefinition::TreeNode::AddPop(short popmask, short newgmask, short popcount, bool begin, FontStyle * format)$/;"	f	class:LanguageDefinition::TreeNode	signature:(short popmask, short newgmask, short popcount, bool begin, FontStyle * format)
AddPop	uLanguageDefinition.h	/^        void AddPop(short popmask, short newmask, short popcount, bool begin, FontStyle *format);$/;"	p	struct:SHEdit::LanguageDefinition::TreeNode	access:public	signature:(short popmask, short newmask, short popcount, bool begin, FontStyle *format)
AddPop	uLanguageDefinition.h	/^      void AddPop(wchar_t * string, FontStyle * format, TreeNode * at, short popmask, short popcount = -2, short newgmask = 0);$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(wchar_t * string, FontStyle * format, TreeNode * at, short popmask, short popcount = -2, short newgmask = 0)
AddPops	uLanguageDefinition.cpp	/^void LanguageDefinition::AddPops(wchar_t * string, FontStyle * format, TreeNode * at, short popmask, short popcount, short gmask)$/;"	f	class:LanguageDefinition	signature:(wchar_t * string, FontStyle * format, TreeNode * at, short popmask, short popcount, short gmask)
AddPops	uLanguageDefinition.h	/^      void AddPops(wchar_t * string, FontStyle * format, TreeNode * at, short popmask, short popcount = -2, short newgmask = 0); \/*!< Just an abreviation. *\/$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(wchar_t * string, FontStyle * format, TreeNode * at, short popmask, short popcount = -2, short newgmask = 0)
AddPops	uLanguageDefinitionWebLangs.cpp	/^void LanguageDefinitionWebLangs::AddPops(LanguageDefinition::TreeNode * at)$/;"	f	class:LanguageDefinitionWebLangs	signature:(LanguageDefinition::TreeNode * at)
AddPops	uLanguageDefinitionWebLangs.h	/^      void AddPops(TreeNode * at);$/;"	p	class:SHEdit::LanguageDefinitionWebLangs	access:private	signature:(TreeNode * at)
AddPush	DOCUMENTATION	/^      void AddPush(wchar_t * string, FontStyle * format, TreeNode * at, TreeNode * to, short pushmask, short newmask = 0, short newgmask = 0); $/;"	p	file:	signature:(wchar_t * string, FontStyle * format, TreeNode * at, TreeNode * to, short pushmask, short newmask = 0, short newgmask = 0)
AddPush	uLanguageDefinition.cpp	/^void LanguageDefinition::AddPush(wchar_t * string, FontStyle * format, TreeNode * at, TreeNode * to, short pushmask, short newmask, short gmask)$/;"	f	class:LanguageDefinition	signature:(wchar_t * string, FontStyle * format, TreeNode * at, TreeNode * to, short pushmask, short newmask, short gmask)
AddPush	uLanguageDefinition.h	/^      void AddPush(wchar_t * string, FontStyle * format, TreeNode * at, TreeNode * to, short pushmask, short newmask = 0, short newgmask = 0); \/*!< Adds pushes specified by string (as space separated list. *\/$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(wchar_t * string, FontStyle * format, TreeNode * at, TreeNode * to, short pushmask, short newmask = 0, short newgmask = 0)
AddPushFront	uLanguageDefinition.cpp	/^void LanguageDefinition::AddPushFront(wchar_t * string, FontStyle * format, TreeNode * at, TreeNode * to, short pushmask, short newmask, short gmask)$/;"	f	class:LanguageDefinition	signature:(wchar_t * string, FontStyle * format, TreeNode * at, TreeNode * to, short pushmask, short newmask, short gmask)
AddPushFront	uLanguageDefinition.h	/^      void AddPushFront(wchar_t * string, FontStyle * format, TreeNode * at, TreeNode * to, short pushmask, short newmask = 0, short newgmask = 0);$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(wchar_t * string, FontStyle * format, TreeNode * at, TreeNode * to, short pushmask, short newmask = 0, short newgmask = 0)
AddPushPopPair	DOCUMENTATION	/^      TreeNode * AddPushPopPair(wchar_t * opening, wchar_t * closing, FontStyle * format, TreeNode * at, TreeNode * to, short mask); $/;"	p	file:	signature:(wchar_t * opening, wchar_t * closing, FontStyle * format, TreeNode * at, TreeNode * to, short mask)
AddPushPopPair	uLanguageDefinition.cpp	/^LanguageDefinition::TreeNode* LanguageDefinition::AddPushPopPair(wchar_t * opening, wchar_t * closing, FontStyle * format, TreeNode * at, TreeNode * to, short mask)$/;"	f	class:LanguageDefinition	signature:(wchar_t * opening, wchar_t * closing, FontStyle * format, TreeNode * at, TreeNode * to, short mask)
AddPushPopPair	uLanguageDefinition.h	/^      TreeNode * AddPushPopPair(wchar_t * opening, wchar_t * closing, FontStyle * format, TreeNode * at, TreeNode * to, short mask); \/*!< Is just an abreviation for push that adds the mask and pop that is conditioned by the same mask.*\/$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(wchar_t * opening, wchar_t * closing, FontStyle * format, TreeNode * at, TreeNode * to, short mask)
AddPushes	uLanguageDefinition.cpp	/^void LanguageDefinition::AddPushes(wchar_t * string, FontStyle * format, TreeNode * at, TreeNode * to, short pushmask, short newmask, short gmask)$/;"	f	class:LanguageDefinition	signature:(wchar_t * string, FontStyle * format, TreeNode * at, TreeNode * to, short pushmask, short newmask, short gmask)
AddPushes	uLanguageDefinition.h	/^      void AddPushes(wchar_t * string, FontStyle * format, TreeNode * at, TreeNode * to, short pushmask, short newmask = 0, short newgmask = 0); \/*!< Just an abreviation. *\/$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(wchar_t * string, FontStyle * format, TreeNode * at, TreeNode * to, short pushmask, short newmask = 0, short newgmask = 0)
AddPushesFront	uLanguageDefinition.cpp	/^void LanguageDefinition::AddPushesFront(wchar_t * string, FontStyle * format, TreeNode * at, TreeNode * to, short pushmask, short newmask, short gmask)$/;"	f	class:LanguageDefinition	signature:(wchar_t * string, FontStyle * format, TreeNode * at, TreeNode * to, short pushmask, short newmask, short gmask)
AddPushesFront	uLanguageDefinition.h	/^      void AddPushesFront(wchar_t * string, FontStyle * format, TreeNode * at, TreeNode * to, short pushmask, short newmask = 0, short newgmask = 0); \/*!< Just an abreviation. *\/$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(wchar_t * string, FontStyle * format, TreeNode * at, TreeNode * to, short pushmask, short newmask = 0, short newgmask = 0)
AddRule	uLanguageDefinition2.cpp	/^void LanguageDefinition::AddRule(const std::wstring& name, std::wstring rule)$/;"	f	class:LanguageDefinition	signature:(const std::wstring& name, std::wstring rule)
AddRule	uLanguageDefinition2.h	/^      void AddRule(const std::wstring& name, std::wstring rule);$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(const std::wstring& name, std::wstring rule)
AddSafetyJumps	uLanguageDefinitionWebLangs.cpp	/^void LanguageDefinitionWebLangs::AddSafetyJumps()$/;"	f	class:LanguageDefinitionWebLangs	signature:()
AddSafetyJumps	uLanguageDefinitionWebLangs.h	/^      void AddSafetyJumps();$/;"	p	class:SHEdit::LanguageDefinitionWebLangs	access:private	signature:()
AddTerm	uLanguageDefinition2.cpp	/^void LanguageDefinition::AddTerm(const std::wstring& name,FontStyle* fs,const std::wstring& rgx, int id, int flags)$/;"	f	class:LanguageDefinition	signature:(const std::wstring& name,FontStyle* fs,const std::wstring& rgx, int id, int flags)
AddTerm	uLanguageDefinition2.h	/^      void AddTerm(const std::wstring& name,FontStyle*,const std::wstring& rgx, int id, int flags);$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(const std::wstring& name,FontStyle*,const std::wstring& rgx, int id, int flags)
AddWord	DOCUMENTATION	/^      void AddWord(wchar_t * string, FontStyle * format, TreeNode * at = NULL); $/;"	p	file:	signature:(wchar_t * string, FontStyle * format, TreeNode * at = NULL)
AddWord	uLanguageDefinition.cpp	/^void LanguageDefinition::AddWord(wchar_t * string, FontStyle * format, TreeNode * at)$/;"	f	class:LanguageDefinition	signature:(wchar_t * string, FontStyle * format, TreeNode * at)
AddWord	uLanguageDefinition.h	/^      void AddWord(wchar_t * string, FontStyle * format, TreeNode * at = NULL);                      \/*!< Adds a wordtag item (i.e. for highlighting php variables as $test just by $) *\/$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(wchar_t * string, FontStyle * format, TreeNode * at = NULL)
AdjustLine	cSHEdit.cpp	/^void TSHEdit::AdjustLine(bool paint, bool fromtop)$/;"	f	class:TSHEdit	signature:(bool paint, bool fromtop)
AdjustLine	cSHEdit.h	/^      void AdjustLine(bool paint, bool fromtop = true);$/;"	p	class:SHEdit::TSHEdit	access:public	signature:(bool paint, bool fromtop = true)
Align	cSHEdit.h	/^      __property TAlign Align = {read=FAlign, write=SetAlign, default=0};$/;"	m	class:SHEdit::TSHEdit	access:public
Auto	uLanguageDefinition2.h	/^      const static int Auto = -1;$/;"	m	class:SHEdit::LanguageDefinition	access:public
BY	uDrawer.cpp	130;"	d	file:
Begin	uBuffer.cpp	/^Iter * Buffer::Begin()$/;"	f	class:Buffer	signature:()
Begin	uBuffer.h	/^      Iter * Begin();$/;"	p	class:SHEdit::Buffer	access:public	signature:()
BottomBorder	uDrawer.cpp	/^int Drawer::BottomBorder()$/;"	f	class:Drawer	signature:()
BottomBorder	uDrawer.h	/^      inline int BottomBorder();$/;"	p	class:SHEdit::Drawer	access:private	signature:()
Buffer	DOCUMENTATION	/^The TSHEdit consists of 4 main parts. The component class TSHEdit, the Buffer, the Parser and the Drawer. Originally the parser and the drawer were designed to work in their own threads, but as it turned out, it was not possible since the vcl is not thread safe (and it actually causes problems even when everything is synced properly from the side of the project).$/;"	v	typeref:class:the
Buffer	uBuffer.cpp	/^Buffer::Buffer()$/;"	f	class:Buffer	signature:()
Buffer	uBuffer.h	/^      Buffer();$/;"	p	class:SHEdit::Buffer	access:public	signature:()
Buffer	uBuffer.h	/^  class Buffer$/;"	c	namespace:SHEdit
Buffer::Begin	uBuffer.cpp	/^Iter * Buffer::Begin()$/;"	f	class:Buffer	signature:()
Buffer::Buffer	uBuffer.cpp	/^Buffer::Buffer()$/;"	f	class:Buffer	signature:()
Buffer::CheckIntegrity	uBuffer.cpp	/^int Buffer::CheckIntegrity(int& emptyCount)$/;"	f	class:Buffer	signature:(int& emptyCount)
Buffer::Delete	uBuffer.cpp	/^int Buffer::Delete(Iter * From, Iter * To)$/;"	f	class:Buffer	signature:(Iter * From, Iter * To)
Buffer::End	uBuffer.cpp	/^Iter * Buffer::End()$/;"	f	class:Buffer	signature:()
Buffer::First	uBuffer.cpp	/^Iter * Buffer::First()   \/\/technically shows wrong location - just if we NEED to maintain a link to fist link no matter what gets inserted$/;"	f	class:Buffer	signature:()
Buffer::FirstLine	uBuffer.cpp	/^NSpan * Buffer::FirstLine()$/;"	f	class:Buffer	signature:()
Buffer::GetItrCount	uBuffer.cpp	/^int Buffer::GetItrCount()$/;"	f	class:Buffer	signature:()
Buffer::GetLine	uBuffer.cpp	/^String Buffer::GetLine(Iter * line, bool replaceTabs)$/;"	f	class:Buffer	signature:(Iter * line, bool replaceTabs)
Buffer::GetLineCount	uBuffer.cpp	/^int Buffer::GetLineCount()$/;"	f	class:Buffer	signature:()
Buffer::GetLineTo	uBuffer.cpp	/^String Buffer::GetLineTo(Iter* To, bool replaceTabs)$/;"	f	class:Buffer	signature:(Iter* To, bool replaceTabs)
Buffer::GetText	uBuffer.cpp	/^wchar_t * Buffer::GetText(Iter * From, Iter* To, bool addCR)$/;"	f	class:Buffer	signature:(Iter * From, Iter* To, bool addCR)
Buffer::HistoryOnOff	uBuffer.cpp	/^void Buffer::HistoryOnOff()$/;"	f	class:Buffer	signature:()
Buffer::Insert	uBuffer.cpp	/^int Buffer::Insert(Iter * At, const wchar_t * string)$/;"	f	class:Buffer	signature:(Iter * At, const wchar_t * string)
Buffer::IsPlainWord	uBuffer.cpp	/^bool Buffer::IsPlainWord(const wchar_t * string)                \/\/OK$/;"	f	class:Buffer	signature:(const wchar_t * string)
Buffer::ItersTranslateDelete	uBuffer.cpp	/^void Buffer::ItersTranslateDelete(int fromlinenum, int frompos, int tolinenum, int topos, NSpan * toline)$/;"	f	class:Buffer	signature:(int fromlinenum, int frompos, int tolinenum, int topos, NSpan * toline)
Buffer::ItersTranslateInsert	uBuffer.cpp	/^void Buffer::ItersTranslateInsert(int linenum, int pos, int bylines, int topos, NSpan * toline)$/;"	f	class:Buffer	signature:(int linenum, int pos, int bylines, int topos, NSpan * toline)
Buffer::PurgeStack	uBuffer.cpp	/^void Buffer::PurgeStack(std::stack<UndoTask*>& stack)$/;"	f	class:Buffer	signature:(std::stack<UndoTask*>& stack)
Buffer::Redo	uBuffer.cpp	/^Iter * Buffer::Redo(Iter *& begin)$/;"	f	class:Buffer	signature:(Iter *& begin)
Buffer::RegisterF	uBuffer.cpp	/^void Buffer::RegisterF(SHEdit::Format * f)$/;"	f	class:Buffer	signature:(SHEdit::Format * f)
Buffer::RegisterIM	uBuffer.cpp	/^void Buffer::RegisterIM(IMark * itr)$/;"	f	class:Buffer	signature:(IMark * itr)
Buffer::RegisterIP	uBuffer.cpp	/^void Buffer::RegisterIP(IPos * itr)$/;"	f	class:Buffer	signature:(IPos * itr)
Buffer::SimpleLoadFile	uBuffer.cpp	/^void Buffer::SimpleLoadFile(const wchar_t * filename)$/;"	f	class:Buffer	signature:(const wchar_t * filename)
Buffer::SimpleSaveFile	uBuffer.cpp	/^void Buffer::SimpleSaveFile(const wchar_t * filename)$/;"	f	class:Buffer	signature:(const wchar_t * filename)
Buffer::Undo	uBuffer.cpp	/^Iter * Buffer::Undo(Iter *& begin)$/;"	f	class:Buffer	signature:(Iter *& begin)
Buffer::UndoPush	uBuffer.cpp	/^void Buffer::UndoPush(UndoTask * event)$/;"	f	class:Buffer	signature:(UndoTask * event)
Buffer::UndoRedo	uBuffer.cpp	/^Iter * Buffer::UndoRedo(std::stack<UndoTask*> * stackUndo, std::stack<UndoTask*> * stackRedo, Iter *& begin)$/;"	f	class:Buffer	signature:(std::stack<UndoTask*> * stackUndo, std::stack<UndoTask*> * stackRedo, Iter *& begin)
Buffer::UnregisterF	uBuffer.cpp	/^void Buffer::UnregisterF(SHEdit::Format * f)$/;"	f	class:Buffer	signature:(SHEdit::Format * f)
Buffer::UnregisterIM	uBuffer.cpp	/^void Buffer::UnregisterIM(IMark * itr)$/;"	f	class:Buffer	signature:(IMark * itr)
Buffer::UnregisterIP	uBuffer.cpp	/^void Buffer::UnregisterIP(IPos * itr)$/;"	f	class:Buffer	signature:(IPos * itr)
Buffer::Write	uBuffer.cpp	/^void Buffer::Write(AnsiString message)$/;"	f	class:Buffer	signature:(AnsiString message)
Buffer::_Delete	uBuffer.cpp	/^void Buffer::_Delete(NSpan * word)$/;"	f	class:Buffer	signature:(NSpan * word)
Buffer::_Delete	uBuffer.cpp	/^void Buffer::_Delete(Span * word)$/;"	f	class:Buffer	signature:(Span * word)
Buffer::_DeleteAt	uBuffer.cpp	/^Range * Buffer::_DeleteAt(Iter * From, Iter * To, bool writeundo, bool forcenew)$/;"	f	class:Buffer	signature:(Iter * From, Iter * To, bool writeundo, bool forcenew)
Buffer::_Insert	uBuffer.cpp	/^void Buffer::_Insert(NSpan * word)$/;"	f	class:Buffer	signature:(NSpan * word)
Buffer::_Insert	uBuffer.cpp	/^void Buffer::_Insert(Span * word)$/;"	f	class:Buffer	signature:(Span * word)
Buffer::_InsertAt	uBuffer.cpp	/^Range * Buffer::_InsertAt(NSpan * line, Span * word, int pos, const wchar_t * string, bool writeundo, bool forcenew)   \/\/OK$/;"	f	class:Buffer	signature:(NSpan * line, Span * word, int pos, const wchar_t * string, bool writeundo, bool forcenew)
Buffer::_ParseWord	uBuffer.cpp	/^wchar_t* Buffer::_ParseWord(const wchar_t *& ptr, const wchar_t * ptrend)             \/\/OK$/;"	f	class:Buffer	signature:(const wchar_t *& ptr, const wchar_t * ptrend)
Buffer::_SplitAt	uBuffer.cpp	/^Span* Buffer::_SplitAt(Iter * At)$/;"	f	class:Buffer	signature:(Iter * At)
Buffer::_SplitBegin	uBuffer.cpp	/^Span* Buffer::_SplitBegin(Iter * At)$/;"	f	class:Buffer	signature:(Iter * At)
Buffer::_SplitEnd	uBuffer.cpp	/^Span* Buffer::_SplitEnd(Iter * At)$/;"	f	class:Buffer	signature:(Iter * At)
Buffer::begin	uBuffer.cpp	/^Iter Buffer::begin()$/;"	f	class:Buffer	signature:()
Buffer::end	uBuffer.cpp	/^Iter Buffer::end()$/;"	f	class:Buffer	signature:()
Buffer::first	uBuffer.cpp	/^Iter Buffer::first()   \/\/technically shows wrong location - just if we NEED to maintain a link to fist link no matter what gets inserted$/;"	f	class:Buffer	signature:()
Buffer::~Buffer	uBuffer.cpp	/^Buffer::~Buffer()$/;"	f	class:Buffer	signature:()
Button1	fSearchBar.h	/^  TButton *Button1;$/;"	m	class:TSearchBar	access:private
Button1Click	fSearchBar.cpp	/^void __fastcall TSearchBar::Button1Click(TObject *Sender)$/;"	f	class:TSearchBar	signature:(TObject *Sender)
Button1Click	fSearchBar.h	/^  void __fastcall Button1Click(TObject *Sender);$/;"	p	class:TSearchBar	access:private	signature:(TObject *Sender)
Button2	fSearchBar.h	/^  TButton *Button2;$/;"	m	class:TSearchBar	access:private
Button2Click	fSearchBar.cpp	/^void __fastcall TSearchBar::Button2Click(TObject *Sender)$/;"	f	class:TSearchBar	signature:(TObject *Sender)
Button2Click	fSearchBar.h	/^  void __fastcall Button2Click(TObject *Sender);$/;"	p	class:TSearchBar	access:private	signature:(TObject *Sender)
CITER_BEGIN	uCursor.h	20;"	d
CITER_BOTH	uCursor.h	22;"	d
CITER_END	uCursor.h	21;"	d
CIter	uCursor.cpp	/^CIter::CIter(TSHEdit * component, const Iter& itr, short type, bool myown)$/;"	f	class:CIter	signature:(TSHEdit * component, const Iter& itr, short type, bool myown)
CIter	uCursor.cpp	/^CIter::CIter(const CIter& c)$/;"	f	class:CIter	signature:(const CIter& c)
CIter	uCursor.h	/^               CIter(const CIter& c);$/;"	p	class:SHEdit::CIter	access:public	signature:(const CIter& c)
CIter	uCursor.h	/^             CIter(TSHEdit * component, const Iter& itr, short type, bool myown); \/\/to be called only by the component$/;"	p	class:SHEdit::CIter	access:private	signature:(TSHEdit * component, const Iter& itr, short type, bool myown)
CIter	uCursor.h	/^    class CIter$/;"	c	namespace:SHEdit
CIter::CIter	uCursor.cpp	/^CIter::CIter(TSHEdit * component, const Iter& itr, short type, bool myown)$/;"	f	class:CIter	signature:(TSHEdit * component, const Iter& itr, short type, bool myown)
CIter::CIter	uCursor.cpp	/^CIter::CIter(const CIter& c)$/;"	f	class:CIter	signature:(const CIter& c)
CIter::DeleteTo	uCursor.cpp	/^void CIter::DeleteTo(CIter& itr)$/;"	f	class:CIter	signature:(CIter& itr)
CIter::FindNext	uCursor.cpp	/^      \/*AUTOGENERATED*\/ bool  CIter::FindNext (wchar_t * string, bool skip , bool caseSensitive , bool wholeword )  { Init(); bool  tmp =  this->itr.FindNext (string,skip,caseSensitive,wholeword); Update();  return  tmp;} \/*!< skip defines whether to match word directly at cursor or not *\/$/;"	f	class:CIter	signature:(wchar_t * string, bool skip , bool caseSensitive , bool wholeword )
CIter::FindPrev	uCursor.cpp	/^      \/*AUTOGENERATED*\/ bool  CIter::FindPrev (wchar_t * string, bool skip , bool caseSensitive , bool wholeword)  { Init(); bool  tmp =  this->itr.FindPrev (string,skip,caseSensitive,wholeword); Update();  return  tmp;} \/*!< same as findnext *\/$/;"	f	class:CIter	signature:(wchar_t * string, bool skip , bool caseSensitive , bool wholeword)
CIter::GetChar	uCursor.cpp	/^      \/*AUTOGENERATED*\/ wchar_t  CIter::GetChar ()  { Init();  return  this->itr.GetChar ();} $/;"	f	class:CIter	signature:()
CIter::GetDistance	uCursor.cpp	/^      \/*AUTOGENERATED*\/ int  CIter::GetDistance (Iter* itr)  { Init();  return  this->itr.GetDistance (itr);} $/;"	f	class:CIter	signature:(Iter* itr)
CIter::GetIter	uCursor.cpp	/^Iter* CIter::GetIter()$/;"	f	class:CIter	signature:()
CIter::GetLeftOffset	uCursor.cpp	/^      \/*AUTOGENERATED*\/ int  CIter::GetLeftOffset ()  { Init();  return  this->itr.GetLeftOffset ();} \/*!< Returns left offset counting tabs as multiple characters according to the tabstop *\/$/;"	f	class:CIter	signature:()
CIter::GetLine	uCursor.cpp	/^      \/*AUTOGENERATED*\/ String  CIter::GetLine ()  { Init();  return  this->itr.GetLine ();} $/;"	f	class:CIter	signature:()
CIter::GetLineNum	uCursor.cpp	/^      \/*AUTOGENERATED*\/ int  CIter::GetLineNum ()  { Init();  return  this->itr.GetLineNum ();} $/;"	f	class:CIter	signature:()
CIter::GetNextChar	uCursor.cpp	/^      \/*AUTOGENERATED*\/ wchar_t  CIter::GetNextChar ()  { Init();  return  this->itr.GetNextChar ();} $/;"	f	class:CIter	signature:()
CIter::GoBy	uCursor.cpp	/^      \/*AUTOGENERATED*\/ void  CIter::GoBy (int chars, bool multiline )  { Init();  this->itr.GoBy (chars,multiline); Update();  } \/*!< Goes forward counting tabs as single character. Always stays on the same line. *\/$/;"	f	class:CIter	signature:(int chars, bool multiline )
CIter::GoByOffset	uCursor.cpp	/^      \/*AUTOGENERATED*\/ void  CIter::GoByOffset (int chars)  { Init();  this->itr.GoByOffset (chars); Update();  } \/*!< Goes forward countint tabs as multiple characters according to the tabstop. Always stays on the same line. *\/$/;"	f	class:CIter	signature:(int chars)
CIter::GoChar	uCursor.cpp	/^      \/*AUTOGENERATED*\/ bool  CIter::GoChar ()  { Init(); bool  tmp =  this->itr.GoChar (); Update();  return  tmp;} \/*!< Increments iterator by 1 *\/$/;"	f	class:CIter	signature:()
CIter::GoLeft	uCursor.cpp	/^      \/*AUTOGENERATED*\/ void  CIter::GoLeft (int chars, bool multiline )  { Init();  this->itr.GoLeft (chars,multiline); Update();  } \/*!< Goes forward counting tabs as single character. always stays on the same line *\/$/;"	f	class:CIter	signature:(int chars, bool multiline )
CIter::GoLine	uCursor.cpp	/^      \/*AUTOGENERATED*\/ bool  CIter::GoLine (bool allowEnd )  { Init(); bool  tmp =  this->itr.GoLine (allowEnd); Update();  return  tmp;} \/*!< Goes to the pos 0 of next line. That is the offset 0 of first Span after nextline NSpan *\/$/;"	f	class:CIter	signature:(bool allowEnd )
CIter::GoLineEnd	uCursor.cpp	/^      \/*AUTOGENERATED*\/ bool  CIter::GoLineEnd ()  { Init(); bool  tmp =  this->itr.GoLineEnd (); Update();  return  tmp;}  $/;"	f	class:CIter	signature:()
CIter::GoLineStart	uCursor.cpp	/^      \/*AUTOGENERATED*\/ bool  CIter::GoLineStart ()  { Init(); bool  tmp =  this->itr.GoLineStart (); Update();  return  tmp;}  $/;"	f	class:CIter	signature:()
CIter::GoToLine	uCursor.cpp	/^      \/*AUTOGENERATED*\/ void  CIter::GoToLine (int line)  { Init();  this->itr.GoToLine (line); Update();  }  $/;"	f	class:CIter	signature:(int line)
CIter::GoWordLiteral	uCursor.cpp	/^      \/*AUTOGENERATED*\/ void  CIter::GoWordLiteral ()  { Init();  this->itr.GoWordLiteral (); Update();  } \/*!< goes to next start of a word (alnum + underscore) *\/$/;"	f	class:CIter	signature:()
CIter::Init	uCursor.cpp	/^void CIter::Init()$/;"	f	class:CIter	signature:()
CIter::Insert	uCursor.cpp	/^void CIter::Insert(String text)$/;"	f	class:CIter	signature:(String text)
CIter::IsUnderCursor	uCursor.cpp	/^      \/*AUTOGENERATED*\/ bool  CIter::IsUnderCursor (const wchar_t *& string, bool caseSensitive, bool wholeword)  { Init();  return  this->itr.IsUnderCursor (string,caseSensitive,wholeword);} \/*!< Tests if the string is at the position of cursor. Serves for FindNext\/FindNext. *\/$/;"	f	class:CIter	signature:(const wchar_t *& string, bool caseSensitive, bool wholeword)
CIter::LineIsEmpty	uCursor.cpp	/^      \/*AUTOGENERATED*\/ bool  CIter::LineIsEmpty ( bool allowWhite )  { Init();  return  this->itr.LineIsEmpty (allowWhite);} $/;"	f	class:CIter	signature:( bool allowWhite )
CIter::MarkupBegin	uCursor.cpp	/^      \/*AUTOGENERATED*\/ void  CIter::MarkupBegin (SHEdit::Format * format)  { Init();  this->itr.MarkupBegin (format);} \/*!< Adds positionless markup. For formatting overview see \\ref index *\/$/;"	f	class:CIter	signature:(SHEdit::Format * format)
CIter::MarkupEnd	uCursor.cpp	/^      \/*AUTOGENERATED*\/ void  CIter::MarkupEnd (SHEdit::Format * format)  { Init();  this->itr.MarkupEnd (format);} \/*!< Adds positionless markup. For formatting overview see \\ref index *\/$/;"	f	class:CIter	signature:(SHEdit::Format * format)
CIter::MarkupRem	uCursor.cpp	/^      \/*AUTOGENERATED*\/ void  CIter::MarkupRem (SHEdit::Format * format)  { Init();  this->itr.MarkupRem (format);} \/*!< Removes all positionless markup from current position. For formatting overview see \\ref index *\/$/;"	f	class:CIter	signature:(SHEdit::Format * format)
CIter::RevChar	uCursor.cpp	/^      \/*AUTOGENERATED*\/ bool  CIter::RevChar ()  { Init(); bool  tmp =  this->itr.RevChar (); Update();  return  tmp;}  $/;"	f	class:CIter	signature:()
CIter::RevLine	uCursor.cpp	/^      \/*AUTOGENERATED*\/ bool  CIter::RevLine ()  { Init(); bool  tmp =  this->itr.RevLine (); Update();  return  tmp;}  $/;"	f	class:CIter	signature:()
CIter::RevLineBegin	uCursor.cpp	/^      \/*AUTOGENERATED*\/ bool  CIter::RevLineBegin ()  { Init(); bool  tmp =  this->itr.RevLineBegin (); Update();  return  tmp;}  $/;"	f	class:CIter	signature:()
CIter::RevWordLiteral	uCursor.cpp	/^      \/*AUTOGENERATED*\/ void  CIter::RevWordLiteral ()  { Init();  this->itr.RevWordLiteral (); Update();  } \/*!< goes to previous start of a word (alnum + underscore) *\/$/;"	f	class:CIter	signature:()
CIter::Update	uCursor.cpp	/^void CIter::Update()$/;"	f	class:CIter	signature:()
CIter::Valid	uCursor.cpp	/^      \/*AUTOGENERATED*\/ bool  CIter::Valid ()   { Init();  return  this->itr.Valid ();} $/;"	f	class:CIter	signature:()
CIter::~CIter	uCursor.cpp	/^CIter::~CIter()$/;"	f	class:CIter	signature:()
CONTRACT	LICENSE	/^LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING$/;"	v
CanGoFurther	uParser.cpp	/^bool Parser::CanGoFurther(LanguageDefinition::SearchIter sit, Iter * itr, bool inword, bool checkbefore, bool recursive)$/;"	f	class:Parser	signature:(LanguageDefinition::SearchIter sit, Iter * itr, bool inword, bool checkbefore, bool recursive)
CanGoFurther	uParser.h	/^      bool CanGoFurther(LanguageDefinition::SearchIter sit, Iter * itr, bool inword, bool checkbefore = false, bool recursive = false);$/;"	p	class:SHEdit::Parser	access:private	signature:(LanguageDefinition::SearchIter sit, Iter * itr, bool inword, bool checkbefore = false, bool recursive = false)
CheckBox1	fSearchBar.h	/^  TCheckBox *CheckBox1;$/;"	m	class:TSearchBar	access:private
CheckIntegrity	cSHEdit.cpp	/^void TSHEdit::CheckIntegrity()$/;"	f	class:TSHEdit	signature:()
CheckIntegrity	cSHEdit.h	/^      void CheckIntegrity();$/;"	p	class:SHEdit::TSHEdit	access:public	signature:()
CheckIntegrity	uBuffer.cpp	/^int Buffer::CheckIntegrity(int& emptyCount)$/;"	f	class:Buffer	signature:(int& emptyCount)
CheckIntegrity	uBuffer.h	/^      int CheckIntegrity(int& emptyCount);$/;"	p	class:SHEdit::Buffer	access:public	signature:(int& emptyCount)
CheckIterIntegrity	cSHEdit.cpp	/^void TSHEdit::CheckIterIntegrity(Iter * itr)$/;"	f	class:TSHEdit	signature:(Iter * itr)
CheckIterIntegrity	cSHEdit.h	/^      void CheckIterIntegrity(Iter * itr);$/;"	p	class:SHEdit::TSHEdit	access:public	signature:(Iter * itr)
CheckMarkup	uParser.cpp	/^void Parser::CheckMarkup(Iter * itr, bool paint)$/;"	f	class:Parser	signature:(Iter * itr, bool paint)
CheckMarkup	uParser.h	/^      inline void CheckMarkup(Iter * itr, bool paint);$/;"	p	class:SHEdit::Parser	access:private	signature:(Iter * itr, bool paint)
Clear	cSHEdit.cpp	/^void TSHEdit::Clear()$/;"	f	class:TSHEdit	signature:()
Clear	cSHEdit.h	/^      void Clear();$/;"	p	class:SHEdit::TSHEdit	access:public	signature:()
Compare	uIPos.cpp	/^bool IPos::Compare(const IPos*& a, const IPos*& b)$/;"	f	class:IPos	signature:(const IPos*& a, const IPos*& b)
Compare	uIPos.h	/^      static bool Compare(const IPos*& a, const IPos*& b);                                           \/*!< Returns true if "a" is to be considered to go befor "b" in buffer. For descendants should be also able to take into acount their positioning needs (i.e. when the position itself is the same, but some markup should be processed before other; its implemented this way to work with template asociative containers that do not allow comparing against other then template type) *\/$/;"	p	class:SHEdit::IPos	access:public	signature:(const IPos*& a, const IPos*& b)
Construct	uLanguageDefinition2.cpp	/^void LanguageDefinition::Construct(std::wstring& rule, std::vector<Node*>& endnodes)$/;"	f	class:LanguageDefinition	signature:(std::wstring& rule, std::vector<Node*>& endnodes)
Construct	uLanguageDefinition2.h	/^      void Construct(std::wstring& rule, std::vector<Node*>& endnodes);$/;"	p	class:SHEdit::LanguageDefinition	access:private	signature:(std::wstring& rule, std::vector<Node*>& endnodes)
ConstructCss	uLanguageDefinitionWebLangs.cpp	/^void LanguageDefinitionWebLangs::ConstructCss(LanguageDefinition::TreeNode * at, TColor * bg, TColor * fg)$/;"	f	class:LanguageDefinitionWebLangs	signature:(LanguageDefinition::TreeNode * at, TColor * bg, TColor * fg)
ConstructCss	uLanguageDefinitionWebLangs.h	/^      void ConstructCss(TreeNode * at,  TColor * bg, TColor * fg);$/;"	p	class:SHEdit::LanguageDefinitionWebLangs	access:private	signature:(TreeNode * at, TColor * bg, TColor * fg)
ConstructHtml	uLanguageDefinitionWebLangs.cpp	/^void LanguageDefinitionWebLangs::ConstructHtml(LanguageDefinition::TreeNode * at, TColor * bg, TColor * fg)$/;"	f	class:LanguageDefinitionWebLangs	signature:(LanguageDefinition::TreeNode * at, TColor * bg, TColor * fg)
ConstructHtml	uLanguageDefinitionWebLangs.h	/^      void ConstructHtml(TreeNode * at, TColor * bg, TColor * fg);$/;"	p	class:SHEdit::LanguageDefinitionWebLangs	access:private	signature:(TreeNode * at, TColor * bg, TColor * fg)
ConstructJavascript	uLanguageDefinitionWebLangs.cpp	/^void LanguageDefinitionWebLangs::ConstructJavascript(LanguageDefinition::TreeNode * at, TColor * bg, TColor * fg)$/;"	f	class:LanguageDefinitionWebLangs	signature:(LanguageDefinition::TreeNode * at, TColor * bg, TColor * fg)
ConstructJavascript	uLanguageDefinitionWebLangs.h	/^      void ConstructJavascript(TreeNode * at, TColor * bg, TColor * fg);$/;"	p	class:SHEdit::LanguageDefinitionWebLangs	access:private	signature:(TreeNode * at, TColor * bg, TColor * fg)
ConstructPhp	uLanguageDefinitionWebLangs.cpp	/^void LanguageDefinitionWebLangs::ConstructPhp(LanguageDefinition::TreeNode * at, TColor * bg, TColor * fg)$/;"	f	class:LanguageDefinitionWebLangs	signature:(LanguageDefinition::TreeNode * at, TColor * bg, TColor * fg)
ConstructPhp	uLanguageDefinitionWebLangs.h	/^      void ConstructPhp(TreeNode * at,  TColor * bg, TColor * fg);$/;"	p	class:SHEdit::LanguageDefinitionWebLangs	access:private	signature:(TreeNode * at, TColor * bg, TColor * fg)
Contains	uStack.h	/^    bool Contains(T_data d);$/;"	p	class:Stack	access:public	signature:(T_data d)
Contains	uStack.h	/^bool Stack<T_data>::Contains(T_data d)$/;"	f	class:Stack	signature:(T_data d)
Copy	cSHEdit.cpp	/^void TSHEdit::Copy()$/;"	f	class:TSHEdit	signature:()
Copy	cSHEdit.h	/^      void Copy();$/;"	p	class:SHEdit::TSHEdit	access:public	signature:()
Copy	uIPos.cpp	/^void IPos::Copy(const IPos& ip)$/;"	f	class:IPos	signature:(const IPos& ip)
Copy	uIPos.h	/^      void Copy(const IPos& ip);$/;"	p	class:SHEdit::IPos	access:private	signature:(const IPos& ip)
Cq	uLanguageDefinition2.cpp	/^bool LanguageDefinition::Node::Cq(const Node& n)$/;"	f	class:LanguageDefinition::Node	signature:(const Node& n)
Cq	uLanguageDefinition2.h	/^        bool Cq(const NTerm& n){return ruleid == n.ruleid && gather == n.gather && call == n.call && fs == n.fs;};$/;"	f	struct:SHEdit::LanguageDefinition::NTerm	access:public	signature:(const NTerm& n)
Cq	uLanguageDefinition2.h	/^        bool Cq(const Node& n); \/\/congruent; more power needed here  - we should check the rest of the tree too$/;"	p	struct:SHEdit::LanguageDefinition::Node	access:public	signature:(const Node& n)
Cq	uLanguageDefinition2.h	/^        bool Cq(const Term& n){return tokid == n.tokid && remember == n.remember && getstyle == n.getstyle && call == n.call && fs == n.fs;};$/;"	f	struct:SHEdit::LanguageDefinition::Term	access:public	signature:(const Term& n)
Cshedit	cSHEdit.cpp	/^namespace Cshedit$/;"	n	file:
Cshedit::Register	cSHEdit.cpp	/^  void __fastcall PACKAGE Register()$/;"	f	namespace:Cshedit	signature:()
DEBUG	config.h	2;"	d
DEFONTSIZE	config.h	32;"	d
DOUBLE_BUFFERED	config.h	17;"	d
Delete	uBuffer.cpp	/^int Buffer::Delete(Iter * From, Iter * To)$/;"	f	class:Buffer	signature:(Iter * From, Iter * To)
Delete	uBuffer.h	/^      int Delete(Iter * From, Iter * To);$/;"	p	class:SHEdit::Buffer	access:public	signature:(Iter * From, Iter * To)
DeleteSel	cSHEdit.cpp	/^void TSHEdit::DeleteSel(bool allowsync, Iter * start, Iter * end)$/;"	f	class:TSHEdit	signature:(bool allowsync, Iter * start, Iter * end)
DeleteSel	cSHEdit.h	/^      void DeleteSel(bool allowsync = true, Iter * start = NULL, Iter * end = NULL);                 \/*!< Handles all deletion tasks (except load file). If start or end are NULL, then the deletion is performed on the selection*\/$/;"	p	class:SHEdit::TSHEdit	access:protected	signature:(bool allowsync = true, Iter * start = NULL, Iter * end = NULL)
DeleteTo	uCursor.cpp	/^void CIter::DeleteTo(CIter& itr)$/;"	f	class:CIter	signature:(CIter& itr)
DeleteTo	uCursor.h	/^             void DeleteTo(CIter& itr);$/;"	p	class:SHEdit::CIter	access:public	signature:(CIter& itr)
DllEntryPoint	SHEditPackage.cpp	/^int WINAPI DllEntryPoint(HINSTANCE hinst, unsigned long reason, void*)$/;"	f	signature:(HINSTANCE hinst, unsigned long reason, void*)
Draw	uParser.cpp	/^void __fastcall Parser::Draw()$/;"	f	class:Parser	signature:()
Draw	uParser.h	/^      void __fastcall Draw();$/;"	p	class:SHEdit::Parser	access:private	signature:()
DrawCursor	uDrawer.cpp	/^void Drawer::DrawCursor()$/;"	f	class:Drawer	signature:()
DrawCursor	uDrawer.h	/^      void DrawCursor();$/;"	p	class:SHEdit::Drawer	access:private	signature:()
DrawEndl	uDrawer.cpp	/^void __fastcall Drawer::DrawEndl(short linenum, FontStyle format)$/;"	f	class:Drawer	signature:(short linenum, FontStyle format)
DrawEndl	uDrawer.h	/^      void __fastcall DrawEndl(short linenum, FontStyle format);$/;"	p	class:SHEdit::Drawer	access:private	signature:(short linenum, FontStyle format)
DrawEof	uDrawer.cpp	/^void __fastcall Drawer::DrawEof(short linenum)$/;"	f	class:Drawer	signature:(short linenum)
DrawEof	uDrawer.h	/^      void __fastcall DrawEof(short linenum);$/;"	p	class:SHEdit::Drawer	access:private	signature:(short linenum)
DrawLinenum	uDrawer.cpp	/^void __fastcall Drawer::DrawLinenum(int from)$/;"	f	class:Drawer	signature:(int from)
DrawLinenum	uDrawer.h	/^      void __fastcall DrawLinenum(int from);$/;"	p	class:SHEdit::Drawer	access:private	signature:(int from)
DrawMove	uDrawer.cpp	/^void __fastcall Drawer::DrawMove(int from, int to, int by)$/;"	f	class:Drawer	signature:(int from, int to, int by)
DrawMove	uDrawer.h	/^      void __fastcall DrawMove(int from, int to, int by);$/;"	p	class:SHEdit::Drawer	access:private	signature:(int from, int to, int by)
DrawResize	uDrawer.cpp	/^void __fastcall Drawer::DrawResize(int w, int h)$/;"	f	class:Drawer	signature:(int w, int h)
DrawResize	uDrawer.h	/^      void __fastcall DrawResize(int w, int h);$/;"	p	class:SHEdit::Drawer	access:private	signature:(int w, int h)
DrawText	uDrawer.cpp	/^void __fastcall Drawer::DrawText(String text, bool newline, short linenum, FontStyle format)$/;"	f	class:Drawer	signature:(String text, bool newline, short linenum, FontStyle format)
DrawText	uDrawer.h	/^      void __fastcall DrawText(String text, bool newline, short linenum, FontStyle format);$/;"	p	class:SHEdit::Drawer	access:private	signature:(String text, bool newline, short linenum, FontStyle format)
Drawer	uDrawer.cpp	/^__fastcall Drawer::Drawer(TCanvas * canvas, TSHEdit * parent)$/;"	f	class:Drawer	signature:(TCanvas * canvas, TSHEdit * parent)
Drawer	uDrawer.h	/^      __fastcall Drawer(TCanvas * Canvas, TSHEdit * parent) ;$/;"	p	class:SHEdit::Drawer	access:public	signature:(TCanvas * Canvas, TSHEdit * parent)
Drawer	uDrawer.h	/^  class Drawer$/;"	c	namespace:SHEdit
Drawer::BottomBorder	uDrawer.cpp	/^int Drawer::BottomBorder()$/;"	f	class:Drawer	signature:()
Drawer::DrawCursor	uDrawer.cpp	/^void Drawer::DrawCursor()$/;"	f	class:Drawer	signature:()
Drawer::DrawEndl	uDrawer.cpp	/^void __fastcall Drawer::DrawEndl(short linenum, FontStyle format)$/;"	f	class:Drawer	signature:(short linenum, FontStyle format)
Drawer::DrawEof	uDrawer.cpp	/^void __fastcall Drawer::DrawEof(short linenum)$/;"	f	class:Drawer	signature:(short linenum)
Drawer::DrawLinenum	uDrawer.cpp	/^void __fastcall Drawer::DrawLinenum(int from)$/;"	f	class:Drawer	signature:(int from)
Drawer::DrawMove	uDrawer.cpp	/^void __fastcall Drawer::DrawMove(int from, int to, int by)$/;"	f	class:Drawer	signature:(int from, int to, int by)
Drawer::DrawResize	uDrawer.cpp	/^void __fastcall Drawer::DrawResize(int w, int h)$/;"	f	class:Drawer	signature:(int w, int h)
Drawer::DrawText	uDrawer.cpp	/^void __fastcall Drawer::DrawText(String text, bool newline, short linenum, FontStyle format)$/;"	f	class:Drawer	signature:(String text, bool newline, short linenum, FontStyle format)
Drawer::Drawer	uDrawer.cpp	/^__fastcall Drawer::Drawer(TCanvas * canvas, TSHEdit * parent)$/;"	f	class:Drawer	signature:(TCanvas * canvas, TSHEdit * parent)
Drawer::GetFontsize	uDrawer.cpp	/^int __fastcall Drawer::GetFontsize()$/;"	f	class:Drawer	signature:()
Drawer::GetLinenumWidth	uDrawer.cpp	/^int __fastcall Drawer::GetLinenumWidth()$/;"	f	class:Drawer	signature:()
Drawer::GetLinenumsEnabled	uDrawer.cpp	/^bool __fastcall Drawer::GetLinenumsEnabled()$/;"	f	class:Drawer	signature:()
Drawer::GetLinesize	uDrawer.cpp	/^int __fastcall Drawer::GetLinesize()$/;"	f	class:Drawer	signature:()
Drawer::Paint	uDrawer.cpp	/^void __fastcall Drawer::Paint()$/;"	f	class:Drawer	signature:()
Drawer::RightBorder	uDrawer.cpp	/^int Drawer::RightBorder()$/;"	f	class:Drawer	signature:()
Drawer::SetFontsize	uDrawer.cpp	/^void __fastcall Drawer::SetFontsize(int size)$/;"	f	class:Drawer	signature:(int size)
Drawer::SetLinenumsEnabled	uDrawer.cpp	/^void __fastcall Drawer::SetLinenumsEnabled(bool enable)$/;"	f	class:Drawer	signature:(bool enable)
Drawer::StressTest	uDrawer.cpp	/^void Drawer::StressTest()$/;"	f	class:Drawer	signature:()
Drawer::UpdateCursor	uDrawer.cpp	/^void __fastcall Drawer::UpdateCursor(int x, int y)$/;"	f	class:Drawer	signature:(int x, int y)
Drawer::UpdateHBar	uDrawer.cpp	/^void __fastcall Drawer::UpdateHBar()$/;"	f	class:Drawer	signature:()
Drawer::UpdateLinenumWidth	uDrawer.cpp	/^bool __fastcall Drawer::UpdateLinenumWidth(int count)$/;"	f	class:Drawer	signature:(int count)
Drawer::Write	uDrawer.cpp	/^void Drawer::Write(String message)$/;"	f	class:Drawer	signature:(String message)
Drawer::~Drawer	uDrawer.cpp	/^__fastcall Drawer::~Drawer()$/;"	f	class:Drawer	signature:()
DumpStackState	uParser.cpp	/^void Parser::DumpStackState()$/;"	f	class:Parser	signature:()
DumpStackState	uParser.h	/^      void DumpStackState();$/;"	p	class:SHEdit::Parser	access:private	signature:()
Duplicate	uIter.cpp	/^Iter * Iter::Duplicate()$/;"	f	class:Iter	signature:()
Duplicate	uIter.h	/^      Iter * Duplicate();                                                                            \/*!<  returns pointer to valid duplicate of Iter. *\/$/;"	p	class:SHEdit::Iter	access:public	signature:()
Edit1	fSearchBar.h	/^  TEdit *Edit1;$/;"	m	class:TSearchBar	access:private
Edit1KeyPress	fSearchBar.cpp	/^void __fastcall TSearchBar::Edit1KeyPress(TObject *Sender, wchar_t &Key)$/;"	f	class:TSearchBar	signature:(TObject *Sender, wchar_t &Key)
Edit1KeyPress	fSearchBar.h	/^  void __fastcall Edit1KeyPress(TObject *Sender, wchar_t &Key);$/;"	p	class:TSearchBar	access:private	signature:(TObject *Sender, wchar_t &Key)
Empty	uLanguageDefinition.h	/^  enum LangDefSpecType{Empty = 0x1, Nomatch = 0x2, Normal=0x4, Jump=0x8, WordTag=0x20, LineTag=0x40, Lookahead = 0x80};$/;"	e	enum:SHEdit::LangDefSpecType
End	uBuffer.cpp	/^Iter * Buffer::End()$/;"	f	class:Buffer	signature:()
End	uBuffer.h	/^      Iter * End();$/;"	p	class:SHEdit::Buffer	access:public	signature:()
Eq	uLanguageDefinition2.cpp	/^bool LanguageDefinition::Node::Eq(const Node& n)$/;"	f	class:LanguageDefinition::Node	signature:(const Node& n)
Eq	uLanguageDefinition2.h	/^        bool Eq(const NTerm& n){return ruleid == n.ruleid;};$/;"	f	struct:SHEdit::LanguageDefinition::NTerm	access:public	signature:(const NTerm& n)
Eq	uLanguageDefinition2.h	/^        bool Eq(const Node& n); \/\/equal (indistinguishable by perser)$/;"	p	struct:SHEdit::LanguageDefinition::Node	access:public	signature:(const Node& n)
Eq	uLanguageDefinition2.h	/^        bool Eq(const Term& n){return tokid == n.tokid;};$/;"	f	struct:SHEdit::LanguageDefinition::Term	access:public	signature:(const Term& n)
Erase	uStack.h	/^    void Erase();$/;"	p	class:Stack	access:public	signature:()
Erase	uStack.h	/^    void Erase(iterator itr);$/;"	p	class:Stack	access:public	signature:(iterator itr)
Erase	uStack.h	/^void Stack<T_data>::Erase()$/;"	f	class:Stack	signature:()
Erase	uStack.h	/^void Stack<T_data>::Erase(iterator it)$/;"	f	class:Stack	signature:(iterator it)
Escape	cSHEdit.cpp	/^String TSHEdit::Escape(String str)$/;"	f	class:TSHEdit	signature:(String str)
Escape	cSHEdit.h	/^      String Escape(String str);    \/\/debug as well$/;"	p	class:SHEdit::TSHEdit	access:public	signature:(String str)
Execute	uParser.cpp	/^bool __fastcall Parser::Execute(bool paint)$/;"	f	class:Parser	signature:(bool paint)
Execute	uParser.h	/^      bool __fastcall Execute(bool paint = true);$/;"	p	class:SHEdit::Parser	access:public	signature:(bool paint = true)
ExpandLambda	uLanguageDefinition2.cpp	/^void LanguageDefinition::Node::ExpandLambda(std::map<int, Node*>& index, Node* next)$/;"	f	class:LanguageDefinition::Node	signature:(std::map<int, Node*>& index, Node* next)
ExpandLambda	uLanguageDefinition2.h	/^        void ExpandLambda(std::map<int, Node*>& index, Node* next);$/;"	p	struct:SHEdit::LanguageDefinition::Node	access:public	signature:(std::map<int, Node*>& index, Node* next)
FIXSCREENTOP	config.h	41;"	d
FORCELOOKAHEAD	config.h	35;"	d
FOnChange	cSHEdit.h	/^      TMessage FOnChange;$/;"	m	class:SHEdit::TSHEdit	access:protected
FOnClick	cSHEdit.h	/^      TMessage FOnClick;$/;"	m	class:SHEdit::TSHEdit	access:protected
FOnEnter	cSHEdit.h	/^      TMessage FOnEnter;$/;"	m	class:SHEdit::TSHEdit	access:protected
FOnExit	cSHEdit.h	/^      TMessage FOnExit;$/;"	m	class:SHEdit::TSHEdit	access:protected
FOnKeyDown	cSHEdit.h	/^      TKeyEvent FOnKeyDown;$/;"	m	class:SHEdit::TSHEdit	access:protected
FOnKeyPress	cSHEdit.h	/^      TKeyPressEvent FOnKeyPress;$/;"	m	class:SHEdit::TSHEdit	access:protected
FOnKeyUp	cSHEdit.h	/^      TKeyEvent FOnKeyUp;$/;"	m	class:SHEdit::TSHEdit	access:protected
FOnMouseUp	cSHEdit.h	/^      TMouseEvent FOnMouseUp;$/;"	m	class:SHEdit::TSHEdit	access:protected
FROM	LICENSE	/^FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER$/;"	v
FROM	uDrawer.cpp	128;"	d	file:
FULL_WIDTH_PAINT	config.h	18;"	d
Finalize	uLanguageDefinition2.cpp	/^void LanguageDefinition::Finalize()$/;"	f	class:LanguageDefinition	signature:()
Finalize	uLanguageDefinition2.cpp	/^void LanguageDefinition::Node::Finalize()$/;"	f	class:LanguageDefinition::Node	signature:()
Finalize	uLanguageDefinition2.h	/^        void Finalize(); $/;"	p	struct:SHEdit::LanguageDefinition::Node	access:public	signature:()
Finalize	uLanguageDefinition2.h	/^      void Finalize(); $/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:()
FindNext	uCursor.cpp	/^      \/*AUTOGENERATED*\/ bool  CIter::FindNext (wchar_t * string, bool skip , bool caseSensitive , bool wholeword )  { Init(); bool  tmp =  this->itr.FindNext (string,skip,caseSensitive,wholeword); Update();  return  tmp;} \/*!< skip defines whether to match word directly at cursor or not *\/$/;"	f	class:CIter	signature:(wchar_t * string, bool skip , bool caseSensitive , bool wholeword )
FindNext	uCursor.h	/^      \/*AUTOGENERATED*\/ bool  CIter::FindNext (wchar_t * string, bool skip = true, bool caseSensitive = true, bool wholeword = false)  ; \/*!< skip defines whether to match word directly at cursor or not *\/$/;"	p	class:SHEdit::CIter::CIter	access:public	signature:(wchar_t * string, bool skip = true, bool caseSensitive = true, bool wholeword = false)
FindNext	uIter.cpp	/^bool Iter::FindNext(wchar_t * string, bool skip, bool caseSensitive, bool wholeword)$/;"	f	class:Iter	signature:(wchar_t * string, bool skip, bool caseSensitive, bool wholeword)
FindNext	uIter.h	/^      bool FindNext(wchar_t * string, bool skip = true, bool caseSensitive = true, bool wholeword = false)\/*AUTOGEN_UPDATE*\/; \/*!< skip defines whether to match word directly at cursor or not *\/$/;"	p	class:SHEdit::Iter	access:public	signature:(wchar_t * string, bool skip = true, bool caseSensitive = true, bool wholeword = false)
FindOrCreateItem	uLanguageDefinition.cpp	/^LanguageDefinition::TreeNode* LanguageDefinition::FindOrCreateItem(TreeNode * item, wchar_t comp, TreeNode * at)$/;"	f	class:LanguageDefinition	signature:(TreeNode * item, wchar_t comp, TreeNode * at)
FindOrCreateItem	uLanguageDefinition.h	/^      TreeNode* FindOrCreateItem(TreeNode * item, wchar_t c, TreeNode * at);$/;"	p	class:SHEdit::LanguageDefinition	access:private	signature:(TreeNode * item, wchar_t c, TreeNode * at)
FindPrev	uCursor.cpp	/^      \/*AUTOGENERATED*\/ bool  CIter::FindPrev (wchar_t * string, bool skip , bool caseSensitive , bool wholeword)  { Init(); bool  tmp =  this->itr.FindPrev (string,skip,caseSensitive,wholeword); Update();  return  tmp;} \/*!< same as findnext *\/$/;"	f	class:CIter	signature:(wchar_t * string, bool skip , bool caseSensitive , bool wholeword)
FindPrev	uCursor.h	/^      \/*AUTOGENERATED*\/ bool  CIter::FindPrev (wchar_t * string, bool skip = true, bool caseSensitive = true, bool wholeword= false)  ; \/*!< same as findnext *\/$/;"	p	class:SHEdit::CIter::CIter	access:public	signature:(wchar_t * string, bool skip = true, bool caseSensitive = true, bool wholeword= false)
FindPrev	uIter.cpp	/^bool Iter::FindPrev(wchar_t * string, bool skip, bool caseSensitive, bool wholeword)$/;"	f	class:Iter	signature:(wchar_t * string, bool skip, bool caseSensitive, bool wholeword)
FindPrev	uIter.h	/^      bool FindPrev(wchar_t * string, bool skip = true, bool caseSensitive = true, bool wholeword= false)\/*AUTOGEN_UPDATE*\/; \/*!< same as findnext *\/$/;"	p	class:SHEdit::Iter	access:public	signature:(wchar_t * string, bool skip = true, bool caseSensitive = true, bool wholeword= false)
First	uBuffer.cpp	/^Iter * Buffer::First()   \/\/technically shows wrong location - just if we NEED to maintain a link to fist link no matter what gets inserted$/;"	f	class:Buffer	signature:()
First	uBuffer.h	/^      Iter * First();$/;"	p	class:SHEdit::Buffer	access:public	signature:()
FirstLine	uBuffer.cpp	/^NSpan * Buffer::FirstLine()$/;"	f	class:Buffer	signature:()
FirstLine	uBuffer.h	/^      NSpan * FirstLine();$/;"	p	class:SHEdit::Buffer	access:public	signature:()
Flush	uParser.cpp	/^void Parser::Flush()$/;"	f	class:Parser	signature:()
Flush	uParser.h	/^      void Flush();$/;"	p	class:SHEdit::Parser	access:private	signature:()
FlushAll	uParser.cpp	/^void Parser::FlushAll()$/;"	f	class:Parser	signature:()
FlushAll	uParser.h	/^      void FlushAll();$/;"	p	class:SHEdit::Parser	access:private	signature:()
FontSize	cSHEdit.h	/^      __property int FontSize = {read=GetFontsize, write=SetFontsize, default=DEFONTSIZE};$/;"	m	class:SHEdit::TSHEdit	access:public
FontStyle	uFormat.cpp	/^  FontStyle::FontStyle()$/;"	f	class:FontStyle	signature:()
FontStyle	uFormat.cpp	/^  FontStyle::FontStyle(TColor * foreground)$/;"	f	class:FontStyle	signature:(TColor * foreground)
FontStyle	uFormat.cpp	/^  FontStyle::FontStyle(TColor * foreground, TColor * background)$/;"	f	class:FontStyle	signature:(TColor * foreground, TColor * background)
FontStyle	uFormat.cpp	/^  FontStyle::FontStyle(TColor * foreground, TColor * background, TFontStyles style)$/;"	f	class:FontStyle	signature:(TColor * foreground, TColor * background, TFontStyles style)
FontStyle	uFormat.h	/^      FontStyle();$/;"	p	class:SHEdit::FontStyle	access:public	signature:()
FontStyle	uFormat.h	/^      FontStyle(TColor * foreground);$/;"	p	class:SHEdit::FontStyle	access:public	signature:(TColor * foreground)
FontStyle	uFormat.h	/^      FontStyle(TColor * foreground, TColor * background);$/;"	p	class:SHEdit::FontStyle	access:public	signature:(TColor * foreground, TColor * background)
FontStyle	uFormat.h	/^      FontStyle(TColor * foreground, TColor * background, TFontStyles style);$/;"	p	class:SHEdit::FontStyle	access:public	signature:(TColor * foreground, TColor * background, TFontStyles style)
FontStyle	uFormat.h	/^  class FontStyle$/;"	c	namespace:SHEdit
FontStyle::FontStyle	uFormat.cpp	/^  FontStyle::FontStyle()$/;"	f	class:FontStyle	signature:()
FontStyle::FontStyle	uFormat.cpp	/^  FontStyle::FontStyle(TColor * foreground)$/;"	f	class:FontStyle	signature:(TColor * foreground)
FontStyle::FontStyle	uFormat.cpp	/^  FontStyle::FontStyle(TColor * foreground, TColor * background)$/;"	f	class:FontStyle	signature:(TColor * foreground, TColor * background)
FontStyle::FontStyle	uFormat.cpp	/^  FontStyle::FontStyle(TColor * foreground, TColor * background, TFontStyles style)$/;"	f	class:FontStyle	signature:(TColor * foreground, TColor * background, TFontStyles style)
FontStyle::operator !=	uFormat.cpp	/^bool FontStyle::operator!=(const SHEdit::FontStyle& f)$/;"	f	class:FontStyle	signature:(const SHEdit::FontStyle& f)
FontStyle::operator +=	uFormat.cpp	/^SHEdit::FontStyle& FontStyle::operator+=(const SHEdit::FontStyle& f)$/;"	f	class:FontStyle	signature:(const SHEdit::FontStyle& f)
FontStyle::operator +=	uFormat.cpp	/^SHEdit::FontStyle& FontStyle::operator+=(const SHEdit::Format& f)$/;"	f	class:FontStyle	signature:(const SHEdit::Format& f)
FontStyle::operator =	uFormat.cpp	/^SHEdit::FontStyle& FontStyle::operator=(const SHEdit::FontStyle& f)$/;"	f	class:FontStyle	signature:(const SHEdit::FontStyle& f)
FontStyle::operator =	uFormat.cpp	/^SHEdit::FontStyle& FontStyle::operator=(const SHEdit::Format& f)$/;"	f	class:FontStyle	signature:(const SHEdit::Format& f)
FontStyle::operator ==	uFormat.cpp	/^bool FontStyle::operator==(const SHEdit::FontStyle& f)$/;"	f	class:FontStyle	signature:(const SHEdit::FontStyle& f)
Format	uFormat.cpp	/^  Format::Format(TColor * foreground, TColor * background)$/;"	f	class:Format	signature:(TColor * foreground, TColor * background)
Format	uFormat.cpp	/^  Format::Format(TColor * foreground, TColor * background, TFontStyles style)$/;"	f	class:Format	signature:(TColor * foreground, TColor * background, TFontStyles style)
Format	uFormat.cpp	/^Format::Format()$/;"	f	class:Format	signature:()
Format	uFormat.h	/^      Format();$/;"	p	class:SHEdit::Format	access:public	signature:()
Format	uFormat.h	/^      Format(TColor * foreground, TColor * background);$/;"	p	class:SHEdit::Format	access:public	signature:(TColor * foreground, TColor * background)
Format	uFormat.h	/^      Format(TColor * foreground, TColor * background, TFontStyles style);$/;"	p	class:SHEdit::Format	access:public	signature:(TColor * foreground, TColor * background, TFontStyles style)
Format	uFormat.h	/^  class Format : public FontStyle$/;"	c	namespace:SHEdit	inherits:FontStyle
Format::Add	uFormat.cpp	/^void Format::Add(Stack<SHEdit::Mark>::Node* mark)$/;"	f	class:Format	signature:(Stack<SHEdit::Mark>::Node* mark)
Format::AddIM	uFormat.cpp	/^void Format::AddIM(IMark * mark)$/;"	f	class:Format	signature:(IMark * mark)
Format::Format	uFormat.cpp	/^  Format::Format(TColor * foreground, TColor * background)$/;"	f	class:Format	signature:(TColor * foreground, TColor * background)
Format::Format	uFormat.cpp	/^  Format::Format(TColor * foreground, TColor * background, TFontStyles style)$/;"	f	class:Format	signature:(TColor * foreground, TColor * background, TFontStyles style)
Format::Format	uFormat.cpp	/^Format::Format()$/;"	f	class:Format	signature:()
Format::GetMarkBefore	uFormat.cpp	/^IMark * Format::GetMarkBefore(IPos* ipos)$/;"	f	class:Format	signature:(IPos* ipos)
Format::Remove	uFormat.cpp	/^void Format::Remove( Stack<SHEdit::Mark>::Node* mark)$/;"	f	class:Format	signature:( Stack<SHEdit::Mark>::Node* mark)
Format::RemoveAllMarks	uFormat.cpp	/^void Format::RemoveAllMarks()$/;"	f	class:Format	signature:()
Format::RemoveIM	uFormat.cpp	/^void Format::RemoveIM( IMark * mark)$/;"	f	class:Format	signature:( IMark * mark)
Format::operator !=	uFormat.cpp	/^bool Format::operator!=(const SHEdit::Format& f)$/;"	f	class:Format	signature:(const SHEdit::Format& f)
Format::operator +=	uFormat.cpp	/^SHEdit::Format& Format::operator+=(const SHEdit::Format& f)$/;"	f	class:Format	signature:(const SHEdit::Format& f)
Format::operator =	uFormat.cpp	/^SHEdit::Format& Format::operator=(const SHEdit::Format& f)$/;"	f	class:Format	signature:(const SHEdit::Format& f)
Format::operator ==	uFormat.cpp	/^bool Format::operator==(const SHEdit::Format& f)$/;"	f	class:Format	signature:(const SHEdit::Format& f)
Format::~Format	uFormat.cpp	/^Format::~Format()$/;"	f	class:Format	signature:()
FormatList	uBuffer.h	/^      std::set<Format*> FormatList;$/;"	m	class:SHEdit::Buffer	access:private
Free	uSpan.cpp	/^void Range::Free()$/;"	f	class:Range	signature:()
Free	uSpan.h	/^    void Free(); \/\/destructor shall not destroy data it holds, but free shoul$/;"	p	struct:SHEdit::Range	access:public	signature:()
GetActLine	cSHEdit.cpp	/^int __fastcall TSHEdit::GetActLine()$/;"	f	class:TSHEdit	signature:()
GetActLine	cSHEdit.h	/^      int __fastcall GetActLine();                                                                   \/*!< returns line number of cursor (absolute position in buffer)*\/$/;"	p	class:SHEdit::TSHEdit	access:public	signature:()
GetChar	uCursor.cpp	/^      \/*AUTOGENERATED*\/ wchar_t  CIter::GetChar ()  { Init();  return  this->itr.GetChar ();} $/;"	f	class:CIter	signature:()
GetChar	uCursor.h	/^      \/*AUTOGENERATED*\/ wchar_t  CIter::GetChar ()  ; $/;"	p	class:SHEdit::CIter::CIter	access:public	signature:()
GetChar	uIter.cpp	/^wchar_t Iter::GetChar()$/;"	f	class:Iter	signature:()
GetChar	uIter.h	/^      wchar_t GetChar()\/*AUTOGEN_PASS*\/;$/;"	p	class:SHEdit::Iter	access:public	signature:()
GetCursor	cSHEdit.cpp	/^CIter TSHEdit::GetCursor()$/;"	f	class:TSHEdit	signature:()
GetCursor	cSHEdit.h	/^      CIter GetCursor();                                                                             \/*!< CIter returns a copy of the cursor (or selection start) Iter wrapped in a CIter instance. The CIter always behaves as a valid Iterator, and takes care of making changes to the canvas.*\/$/;"	p	class:SHEdit::TSHEdit	access:public	signature:()
GetCursorBegin	cSHEdit.cpp	/^CIter TSHEdit::GetCursorBegin()$/;"	f	class:TSHEdit	signature:()
GetCursorBegin	cSHEdit.h	/^      CIter GetCursorBegin();                                                                        \/*!< CIter returns a copy of the cursor (or selection start) Iter wrapped in a CIter instance. The CIter always behaves as a valid Iterator, and takes care of making changes to the canvas.*\/$/;"	p	class:SHEdit::TSHEdit	access:public	signature:()
GetCursorCaretX	cSHEdit.cpp	/^int TSHEdit::GetCursorCaretX()$/;"	f	class:TSHEdit	signature:()
GetCursorCaretX	cSHEdit.h	/^      int GetCursorCaretX();$/;"	p	class:SHEdit::TSHEdit	access:public	signature:()
GetCursorCaretY	cSHEdit.cpp	/^int TSHEdit::GetCursorCaretY()$/;"	f	class:TSHEdit	signature:()
GetCursorCaretY	cSHEdit.h	/^      int GetCursorCaretY();$/;"	p	class:SHEdit::TSHEdit	access:public	signature:()
GetCursorEnd	cSHEdit.cpp	/^CIter TSHEdit::GetCursorEnd()$/;"	f	class:TSHEdit	signature:()
GetCursorEnd	cSHEdit.h	/^      CIter GetCursorEnd();                                                                          \/*!< CIter returns a copy of the cursor (or selection end) Iter wrapped in a CIter instance. The CIter always behaves as a valid Iterator, and takes care of making changes to the canvas.*\/$/;"	p	class:SHEdit::TSHEdit	access:public	signature:()
GetCursorIter	cSHEdit.cpp	/^Iter * TSHEdit::GetCursorIter()$/;"	f	class:TSHEdit	signature:()
GetCursorIter	cSHEdit.h	/^      Iter * GetCursorIter();                                                                        \/*!< If part of text is selected, returns pointer to the beginning of selection (or cursor, if nothing is selected). Pointer points to the component's private iterator - do not modify it unless you know what you are doing. *\/$/;"	p	class:SHEdit::TSHEdit	access:public	signature:()
GetCursorIterEnd	cSHEdit.cpp	/^Iter * TSHEdit::GetCursorIterEnd()$/;"	f	class:TSHEdit	signature:()
GetCursorIterEnd	cSHEdit.h	/^      Iter * GetCursorIterEnd();                                                                     \/*!< If part of text is selected, returns pointer to the end of selection (or NULL, if nothing is selected). Pointer points to the component's private iterator - do not modify it unless you know what you are doing. *\/$/;"	p	class:SHEdit::TSHEdit	access:public	signature:()
GetCursorX	cSHEdit.cpp	/^int TSHEdit::GetCursorX()$/;"	f	class:TSHEdit	signature:()
GetCursorX	cSHEdit.h	/^      int GetCursorX();$/;"	p	class:SHEdit::TSHEdit	access:public	signature:()
GetCursorY	cSHEdit.cpp	/^int TSHEdit::GetCursorY()$/;"	f	class:TSHEdit	signature:()
GetCursorY	cSHEdit.h	/^      int GetCursorY();$/;"	p	class:SHEdit::TSHEdit	access:public	signature:()
GetDefSC	uLanguageDefinition.cpp	/^LanguageDefinition::SearchIter LanguageDefinition::GetDefSC(short id)$/;"	f	class:LanguageDefinition	signature:(short id)
GetDefSC	uLanguageDefinition.h	/^      SearchIter GetDefSC(short id);$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(short id)
GetDistance	uCursor.cpp	/^      \/*AUTOGENERATED*\/ int  CIter::GetDistance (Iter* itr)  { Init();  return  this->itr.GetDistance (itr);} $/;"	f	class:CIter	signature:(Iter* itr)
GetDistance	uCursor.h	/^      \/*AUTOGENERATED*\/ int  CIter::GetDistance (Iter* itr)  ; $/;"	p	class:SHEdit::CIter::CIter	access:public	signature:(Iter* itr)
GetDistance	uIter.cpp	/^int Iter::GetDistance(Iter* second)$/;"	f	class:Iter	signature:(Iter* second)
GetDistance	uIter.h	/^      int GetDistance(Iter* itr)\/*AUTOGEN_PASS*\/;$/;"	p	class:SHEdit::Iter	access:public	signature:(Iter* itr)
GetFontsize	cSHEdit.cpp	/^int __fastcall TSHEdit::GetFontsize()$/;"	f	class:TSHEdit	signature:()
GetFontsize	cSHEdit.h	/^      int __fastcall GetFontsize();$/;"	p	class:SHEdit::TSHEdit	access:public	signature:()
GetFontsize	uDrawer.cpp	/^int __fastcall Drawer::GetFontsize()$/;"	f	class:Drawer	signature:()
GetFontsize	uDrawer.h	/^      int __fastcall GetFontsize();$/;"	p	class:SHEdit::Drawer	access:public	signature:()
GetIter	uCursor.cpp	/^Iter* CIter::GetIter()$/;"	f	class:CIter	signature:()
GetIter	uCursor.h	/^               Iter * GetIter();$/;"	p	class:SHEdit::CIter	access:public	signature:()
GetItrCount	uBuffer.cpp	/^int Buffer::GetItrCount()$/;"	f	class:Buffer	signature:()
GetItrCount	uBuffer.h	/^      int GetItrCount();$/;"	p	class:SHEdit::Buffer	access:public	signature:()
GetKeepHistory	cSHEdit.cpp	/^bool _fastcall TSHEdit::GetKeepHistory()$/;"	f	class:TSHEdit	signature:()
GetKeepHistory	cSHEdit.h	/^      bool __fastcall GetKeepHistory();$/;"	p	class:SHEdit::TSHEdit	access:public	signature:()
GetLangDef	uParser.cpp	/^LanguageDefinition * Parser::GetLangDef()$/;"	f	class:Parser	signature:()
GetLangDef	uParser.h	/^      LanguageDefinition* GetLangDef();$/;"	p	class:SHEdit::Parser	access:public	signature:()
GetLanguageDefinition	cSHEdit.cpp	/^LanguageDefinition* __fastcall TSHEdit::GetLanguageDefinition()$/;"	f	class:TSHEdit	signature:()
GetLanguageDefinition	cSHEdit.h	/^      LanguageDefinition* __fastcall GetLanguageDefinition();$/;"	p	class:SHEdit::TSHEdit	access:public	signature:()
GetLeftOffset	uCursor.cpp	/^      \/*AUTOGENERATED*\/ int  CIter::GetLeftOffset ()  { Init();  return  this->itr.GetLeftOffset ();} \/*!< Returns left offset counting tabs as multiple characters according to the tabstop *\/$/;"	f	class:CIter	signature:()
GetLeftOffset	uCursor.h	/^      \/*AUTOGENERATED*\/ int  CIter::GetLeftOffset ()  ;                                              \/*!< Returns left offset counting tabs as multiple characters according to the tabstop *\/$/;"	p	class:SHEdit::CIter::CIter	access:public	signature:()
GetLeftOffset	uIter.cpp	/^int Iter::GetLeftOffset()$/;"	f	class:Iter	signature:()
GetLeftOffset	uIter.h	/^      int GetLeftOffset()\/*AUTOGEN_PASS*\/;                                                           \/*!< Returns left offset counting tabs as multiple characters according to the tabstop *\/$/;"	p	class:SHEdit::Iter	access:public	signature:()
GetLine	cSHEdit.cpp	/^String TSHEdit::GetLine(Iter* itr)$/;"	f	class:TSHEdit	signature:(Iter* itr)
GetLine	cSHEdit.cpp	/^String TSHEdit::GetLine(int index)$/;"	f	class:TSHEdit	signature:(int index)
GetLine	cSHEdit.h	/^      String GetLine(Iter* itr);$/;"	p	class:SHEdit::TSHEdit	access:public	signature:(Iter* itr)
GetLine	cSHEdit.h	/^      String GetLine(int index);$/;"	p	class:SHEdit::TSHEdit	access:public	signature:(int index)
GetLine	uBuffer.cpp	/^String Buffer::GetLine(Iter * line, bool replaceTabs)$/;"	f	class:Buffer	signature:(Iter * line, bool replaceTabs)
GetLine	uBuffer.h	/^      String GetLine(Iter * line, bool replaceTabs);$/;"	p	class:SHEdit::Buffer	access:public	signature:(Iter * line, bool replaceTabs)
GetLine	uCursor.cpp	/^      \/*AUTOGENERATED*\/ String  CIter::GetLine ()  { Init();  return  this->itr.GetLine ();} $/;"	f	class:CIter	signature:()
GetLine	uCursor.h	/^      \/*AUTOGENERATED*\/ String  CIter::GetLine ()  ; $/;"	p	class:SHEdit::CIter::CIter	access:public	signature:()
GetLine	uIter.cpp	/^String Iter::GetLine()$/;"	f	class:Iter	signature:()
GetLine	uIter.h	/^      String GetLine()\/*AUTOGEN_PASS*\/;$/;"	p	class:SHEdit::Iter	access:public	signature:()
GetLineByNum	cSHEdit.cpp	/^Iter __fastcall TSHEdit::GetLineByNum(int no)$/;"	f	class:TSHEdit	signature:(int no)
GetLineByNum	cSHEdit.cpp	/^Iter __fastcall TSHEdit::GetLineByNum(int no, bool allowEnd)$/;"	f	class:TSHEdit	signature:(int no, bool allowEnd)
GetLineByNum	cSHEdit.h	/^      Iter __fastcall GetLineByNum(int num);                                                         \/*!< returns iterator of line numth visible line*\/$/;"	p	class:SHEdit::TSHEdit	access:protected	signature:(int num)
GetLineByNum	cSHEdit.h	/^      Iter __fastcall GetLineByNum(int num, bool allowEnd);                                          \/*!< returns iterator of line numth visible line*\/$/;"	p	class:SHEdit::TSHEdit	access:protected	signature:(int num, bool allowEnd)
GetLineCount	cSHEdit.cpp	/^int __fastcall TSHEdit::GetLineCount()$/;"	f	class:TSHEdit	signature:()
GetLineCount	cSHEdit.h	/^      int __fastcall GetLineCount();$/;"	p	class:SHEdit::TSHEdit	access:public	signature:()
GetLineCount	uBuffer.cpp	/^int Buffer::GetLineCount()$/;"	f	class:Buffer	signature:()
GetLineCount	uBuffer.h	/^      int GetLineCount();$/;"	p	class:SHEdit::Buffer	access:public	signature:()
GetLineHeight	cSHEdit.cpp	/^int __fastcall TSHEdit::GetLineHeight()$/;"	f	class:TSHEdit	signature:()
GetLineHeight	cSHEdit.h	/^      int __fastcall GetLineHeight();$/;"	p	class:SHEdit::TSHEdit	access:public	signature:()
GetLineNum	cSHEdit.cpp	/^int __fastcall TSHEdit::GetLineNum(NSpan * line)$/;"	f	class:TSHEdit	signature:(NSpan * line)
GetLineNum	cSHEdit.h	/^      int __fastcall GetLineNum(NSpan * line);                                                       \/*!< Returns line number relative to the first visible line. Relic of a positionless handling*\/$/;"	p	class:SHEdit::TSHEdit	access:protected	signature:(NSpan * line)
GetLineNum	uCursor.cpp	/^      \/*AUTOGENERATED*\/ int  CIter::GetLineNum ()  { Init();  return  this->itr.GetLineNum ();} $/;"	f	class:CIter	signature:()
GetLineNum	uCursor.h	/^      \/*AUTOGENERATED*\/ int  CIter::GetLineNum ()  ; $/;"	p	class:SHEdit::CIter::CIter	access:public	signature:()
GetLineNum	uIter.cpp	/^int Iter::GetLineNum()$/;"	f	class:Iter	signature:()
GetLineNum	uIter.h	/^      int GetLineNum()\/*AUTOGEN_PASS*\/;$/;"	p	class:SHEdit::Iter	access:public	signature:()
GetLineTo	uBuffer.cpp	/^String Buffer::GetLineTo(Iter* To, bool replaceTabs)$/;"	f	class:Buffer	signature:(Iter* To, bool replaceTabs)
GetLineTo	uBuffer.h	/^      String GetLineTo(Iter * To, bool replaceTabs);$/;"	p	class:SHEdit::Buffer	access:public	signature:(Iter * To, bool replaceTabs)
GetLinenumWidth	uDrawer.cpp	/^int __fastcall Drawer::GetLinenumWidth()$/;"	f	class:Drawer	signature:()
GetLinenumWidth	uDrawer.h	/^      int __fastcall GetLinenumWidth();$/;"	p	class:SHEdit::Drawer	access:public	signature:()
GetLinenumsEnabled	cSHEdit.cpp	/^bool __fastcall TSHEdit::GetLinenumsEnabled()$/;"	f	class:TSHEdit	signature:()
GetLinenumsEnabled	cSHEdit.h	/^      bool __fastcall GetLinenumsEnabled();$/;"	p	class:SHEdit::TSHEdit	access:public	signature:()
GetLinenumsEnabled	uDrawer.cpp	/^bool __fastcall Drawer::GetLinenumsEnabled()$/;"	f	class:Drawer	signature:()
GetLinenumsEnabled	uDrawer.h	/^      bool __fastcall GetLinenumsEnabled();$/;"	p	class:SHEdit::Drawer	access:public	signature:()
GetLinesize	uDrawer.cpp	/^int __fastcall Drawer::GetLinesize()$/;"	f	class:Drawer	signature:()
GetLinesize	uDrawer.h	/^      int __fastcall GetLinesize();$/;"	p	class:SHEdit::Drawer	access:public	signature:()
GetMarkBefore	uFormat.cpp	/^IMark * Format::GetMarkBefore(IPos* ipos)$/;"	f	class:Format	signature:(IPos* ipos)
GetMarkBefore	uFormat.h	/^      IMark * GetMarkBefore(IPos * ipos);$/;"	p	class:SHEdit::Format	access:public	signature:(IPos * ipos)
GetName	uLanguageDefinition2.h	/^        const std::wstring& GetName()const{return term? t->name : nt->name;};$/;"	f	struct:SHEdit::LanguageDefinition::Rec	access:public	signature:() const
GetNextChar	uCursor.cpp	/^      \/*AUTOGENERATED*\/ wchar_t  CIter::GetNextChar ()  { Init();  return  this->itr.GetNextChar ();} $/;"	f	class:CIter	signature:()
GetNextChar	uCursor.h	/^      \/*AUTOGENERATED*\/ wchar_t  CIter::GetNextChar ()  ; $/;"	p	class:SHEdit::CIter::CIter	access:public	signature:()
GetNextChar	uIter.cpp	/^wchar_t Iter::GetNextChar()$/;"	f	class:Iter	signature:()
GetNextChar	uIter.h	/^      wchar_t GetNextChar()\/*AUTOGEN_PASS*\/;$/;"	p	class:SHEdit::Iter	access:public	signature:()
GetPrevChar	uIter.cpp	/^wchar_t Iter::GetPrevChar()$/;"	f	class:Iter	signature:()
GetPrevChar	uIter.h	/^      wchar_t GetPrevChar()\/*AUTOGEN_PASS*\/;$/;"	p	class:SHEdit::Iter	access:public	signature:()
GetRange	cSHEdit.cpp	/^String TSHEdit::GetRange(Iter * begin, Iter * end)$/;"	f	class:TSHEdit	signature:(Iter * begin, Iter * end)
GetRange	cSHEdit.h	/^      String GetRange(Iter * begin, Iter * end);$/;"	p	class:SHEdit::TSHEdit	access:public	signature:(Iter * begin, Iter * end)
GetScrollStep	cSHEdit.cpp	/^int TSHEdit::GetScrollStep()$/;"	f	class:TSHEdit	signature:()
GetScrollStep	cSHEdit.h	/^      int GetScrollStep();$/;"	p	class:SHEdit::TSHEdit	access:private	signature:()
GetSelLen	cSHEdit.cpp	/^int __fastcall TSHEdit::GetSelLen()$/;"	f	class:TSHEdit	signature:()
GetSelLen	cSHEdit.h	/^      int __fastcall GetSelLen();$/;"	p	class:SHEdit::TSHEdit	access:protected	signature:()
GetSelText	cSHEdit.cpp	/^String __fastcall TSHEdit::GetSelText()$/;"	f	class:TSHEdit	signature:()
GetSelText	cSHEdit.h	/^      String __fastcall GetSelText();$/;"	p	class:SHEdit::TSHEdit	access:protected	signature:()
GetText	cSHEdit.cpp	/^String __fastcall TSHEdit::GetText()$/;"	f	class:TSHEdit	signature:()
GetText	cSHEdit.h	/^      String __fastcall GetText();$/;"	p	class:SHEdit::TSHEdit	access:protected	signature:()
GetText	uBuffer.cpp	/^wchar_t * Buffer::GetText(Iter * From, Iter* To, bool addCR)$/;"	f	class:Buffer	signature:(Iter * From, Iter* To, bool addCR)
GetText	uBuffer.h	/^      wchar_t* GetText(Iter * From, Iter * To, bool addCariageReturns = false);$/;"	p	class:SHEdit::Buffer	access:public	signature:(Iter * From, Iter * To, bool addCariageReturns = false)
GetToken	uLanguageDefinition2.cpp	/^LanguageDefinition::TokType LanguageDefinition::GetToken(std::wstring& str, std::wstring& val, bool eat)$/;"	f	class:LanguageDefinition	signature:(std::wstring& str, std::wstring& val, bool eat)
GetToken	uLanguageDefinition2.h	/^      TokType GetToken(std::wstring& str, std::wstring& val);$/;"	p	class:SHEdit::LanguageDefinition	access:private	signature:(std::wstring& str, std::wstring& val)
GetToken	uLanguageDefinition2.h	/^      TokType GetToken(std::wstring& str, std::wstring& val, bool eat);$/;"	p	class:SHEdit::LanguageDefinition	access:private	signature:(std::wstring& str, std::wstring& val, bool eat)
GetTree	uLanguageDefinition.cpp	/^LanguageDefinition::TreeNode* LanguageDefinition::GetTree()$/;"	f	class:LanguageDefinition	signature:()
GetTree	uLanguageDefinition.h	/^      TreeNode* GetTree();$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:()
GetVisLineCount	cSHEdit.cpp	/^int __fastcall TSHEdit::GetVisLineCount()$/;"	f	class:TSHEdit	signature:()
GetVisLineCount	cSHEdit.h	/^      int __fastcall GetVisLineCount();$/;"	p	class:SHEdit::TSHEdit	access:public	signature:()
Go	uLanguageDefinition.cpp	/^LangDefSpecType LanguageDefinition::Go(SearchIter * item, wchar_t c, bool & lookahead)$/;"	f	class:LanguageDefinition	signature:(SearchIter * item, wchar_t c, bool & lookahead)
Go	uLanguageDefinition.h	/^      LangDefSpecType Go(SearchIter * item, wchar_t c, bool & lookahead);                            \/*!< Serves Parser for retrieving information about where to go further. Lookahead is set to true, if item was returned to empty and directly went to first unmatched character *\/$/;"	p	class:SHEdit::LanguageDefinition	access:private	signature:(SearchIter * item, wchar_t c, bool & lookahead)
GoBy	uCursor.cpp	/^      \/*AUTOGENERATED*\/ void  CIter::GoBy (int chars, bool multiline )  { Init();  this->itr.GoBy (chars,multiline); Update();  } \/*!< Goes forward counting tabs as single character. Always stays on the same line. *\/$/;"	f	class:CIter	signature:(int chars, bool multiline )
GoBy	uCursor.h	/^      \/*AUTOGENERATED*\/ void  CIter::GoBy (int chars, bool multiline = false)  ;                     \/*!< Goes forward counting tabs as single character. Always stays on the same line. *\/$/;"	p	class:SHEdit::CIter::CIter	access:public	signature:(int chars, bool multiline = false)
GoBy	uIter.cpp	/^void Iter::GoBy(int chars, bool multiline)$/;"	f	class:Iter	signature:(int chars, bool multiline)
GoBy	uIter.h	/^      void GoBy(int chars, bool multiline = false)\/*AUTOGEN_UPDATE*\/;                                \/*!< Goes forward counting tabs as single character. Always stays on the same line. *\/$/;"	p	class:SHEdit::Iter	access:public	signature:(int chars, bool multiline = false)
GoByOffset	uCursor.cpp	/^      \/*AUTOGENERATED*\/ void  CIter::GoByOffset (int chars)  { Init();  this->itr.GoByOffset (chars); Update();  } \/*!< Goes forward countint tabs as multiple characters according to the tabstop. Always stays on the same line. *\/$/;"	f	class:CIter	signature:(int chars)
GoByOffset	uCursor.h	/^      \/*AUTOGENERATED*\/ void  CIter::GoByOffset (int chars)  ;                                       \/*!< Goes forward countint tabs as multiple characters according to the tabstop. Always stays on the same line. *\/$/;"	p	class:SHEdit::CIter::CIter	access:public	signature:(int chars)
GoByOffset	uIter.cpp	/^void Iter::GoByOffset(int chars)$/;"	f	class:Iter	signature:(int chars)
GoByOffset	uIter.h	/^      void GoByOffset(int chars)\/*AUTOGEN_UPDATE*\/;                                                  \/*!< Goes forward countint tabs as multiple characters according to the tabstop. Always stays on the same line. *\/$/;"	p	class:SHEdit::Iter	access:public	signature:(int chars)
GoChar	uCursor.cpp	/^      \/*AUTOGENERATED*\/ bool  CIter::GoChar ()  { Init(); bool  tmp =  this->itr.GoChar (); Update();  return  tmp;} \/*!< Increments iterator by 1 *\/$/;"	f	class:CIter	signature:()
GoChar	uCursor.h	/^      \/*AUTOGENERATED*\/ bool  CIter::GoChar ()  ;                                                    \/*!< Increments iterator by 1 *\/$/;"	p	class:SHEdit::CIter::CIter	access:public	signature:()
GoChar	uIter.cpp	/^bool Iter::GoChar()$/;"	f	class:Iter	signature:()
GoChar	uIter.h	/^      bool GoChar()\/*AUTOGEN_UPDATE*\/;                                                               \/*!< Increments iterator by 1 *\/$/;"	p	class:SHEdit::Iter	access:public	signature:()
GoLeft	uCursor.cpp	/^      \/*AUTOGENERATED*\/ void  CIter::GoLeft (int chars, bool multiline )  { Init();  this->itr.GoLeft (chars,multiline); Update();  } \/*!< Goes forward counting tabs as single character. always stays on the same line *\/$/;"	f	class:CIter	signature:(int chars, bool multiline )
GoLeft	uCursor.h	/^      \/*AUTOGENERATED*\/ void  CIter::GoLeft (int chars, bool multiline = false)  ;                   \/*!< Goes forward counting tabs as single character. always stays on the same line *\/$/;"	p	class:SHEdit::CIter::CIter	access:public	signature:(int chars, bool multiline = false)
GoLeft	uIter.cpp	/^void Iter::GoLeft(int chars, bool multiline)$/;"	f	class:Iter	signature:(int chars, bool multiline)
GoLeft	uIter.h	/^      void GoLeft(int chars, bool multiline = false)\/*AUTOGEN_UPDATE*\/;                              \/*!< Goes forward counting tabs as single character. always stays on the same line *\/$/;"	p	class:SHEdit::Iter	access:public	signature:(int chars, bool multiline = false)
GoLine	uCursor.cpp	/^      \/*AUTOGENERATED*\/ bool  CIter::GoLine (bool allowEnd )  { Init(); bool  tmp =  this->itr.GoLine (allowEnd); Update();  return  tmp;} \/*!< Goes to the pos 0 of next line. That is the offset 0 of first Span after nextline NSpan *\/$/;"	f	class:CIter	signature:(bool allowEnd )
GoLine	uCursor.h	/^      \/*AUTOGENERATED*\/ bool  CIter::GoLine (bool allowEnd = false)  ;                               \/*!< Goes to the pos 0 of next line. That is the offset 0 of first Span after nextline NSpan *\/$/;"	p	class:SHEdit::CIter::CIter	access:public	signature:(bool allowEnd = false)
GoLine	uIter.cpp	/^bool Iter::GoLine(bool allowEnd)$/;"	f	class:Iter	signature:(bool allowEnd)
GoLine	uIter.h	/^      bool GoLine(bool allowEnd = false)\/*AUTOGEN_UPDATE*\/;                                          \/*!< Goes to the pos 0 of next line. That is the offset 0 of first Span after nextline NSpan *\/$/;"	p	class:SHEdit::Iter	access:public	signature:(bool allowEnd = false)
GoLineEnd	uCursor.cpp	/^      \/*AUTOGENERATED*\/ bool  CIter::GoLineEnd ()  { Init(); bool  tmp =  this->itr.GoLineEnd (); Update();  return  tmp;}  $/;"	f	class:CIter	signature:()
GoLineEnd	uCursor.h	/^      \/*AUTOGENERATED*\/ bool  CIter::GoLineEnd ()  ; $/;"	p	class:SHEdit::CIter::CIter	access:public	signature:()
GoLineEnd	uIter.cpp	/^bool Iter::GoLineEnd()$/;"	f	class:Iter	signature:()
GoLineEnd	uIter.h	/^      bool GoLineEnd()\/*AUTOGEN_UPDATE*\/;$/;"	p	class:SHEdit::Iter	access:public	signature:()
GoLineStart	uCursor.cpp	/^      \/*AUTOGENERATED*\/ bool  CIter::GoLineStart ()  { Init(); bool  tmp =  this->itr.GoLineStart (); Update();  return  tmp;}  $/;"	f	class:CIter	signature:()
GoLineStart	uCursor.h	/^      \/*AUTOGENERATED*\/ bool  CIter::GoLineStart ()  ; $/;"	p	class:SHEdit::CIter::CIter	access:public	signature:()
GoLineStart	uIter.cpp	/^bool Iter::GoLineStart()$/;"	f	class:Iter	signature:()
GoLineStart	uIter.h	/^      bool GoLineStart()\/*AUTOGEN_UPDATE*\/;$/;"	p	class:SHEdit::Iter	access:public	signature:()
GoToLine	uCursor.cpp	/^      \/*AUTOGENERATED*\/ void  CIter::GoToLine (int line)  { Init();  this->itr.GoToLine (line); Update();  }  $/;"	f	class:CIter	signature:(int line)
GoToLine	uCursor.h	/^      \/*AUTOGENERATED*\/ void  CIter::GoToLine (int line)  ; $/;"	p	class:SHEdit::CIter::CIter	access:public	signature:(int line)
GoToLine	uIter.cpp	/^void Iter::GoToLine(int line)$/;"	f	class:Iter	signature:(int line)
GoToLine	uIter.h	/^      void GoToLine(int line)\/*AUTOGEN_UPDATE*\/;$/;"	p	class:SHEdit::Iter	access:public	signature:(int line)
GoWord	uIter.cpp	/^bool Iter::GoWord()$/;"	f	class:Iter	signature:()
GoWord	uIter.h	/^      bool GoWord();                                                                                 \/*!< Goes to beginning of next Span *\/$/;"	p	class:SHEdit::Iter	access:protected	signature:()
GoWordEndLiteral	uIter.cpp	/^void Iter::GoWordEndLiteral()$/;"	f	class:Iter	signature:()
GoWordEndLiteral	uIter.h	/^      void GoWordEndLiteral();                                                                       \/*!< goes to next end of a word (alnum + underscore)*\/$/;"	p	class:SHEdit::Iter	access:public	signature:()
GoWordLiteral	uCursor.cpp	/^      \/*AUTOGENERATED*\/ void  CIter::GoWordLiteral ()  { Init();  this->itr.GoWordLiteral (); Update();  } \/*!< goes to next start of a word (alnum + underscore) *\/$/;"	f	class:CIter	signature:()
GoWordLiteral	uCursor.h	/^      \/*AUTOGENERATED*\/ void  CIter::GoWordLiteral ()  ;                                             \/*!< goes to next start of a word (alnum + underscore) *\/$/;"	p	class:SHEdit::CIter::CIter	access:public	signature:()
GoWordLiteral	uIter.cpp	/^void Iter::GoWordLiteral()$/;"	f	class:Iter	signature:()
GoWordLiteral	uIter.h	/^      void GoWordLiteral()\/*AUTOGEN_UPDATE*\/;                                                        \/*!< goes to next start of a word (alnum + underscore) *\/$/;"	p	class:SHEdit::Iter	access:public	signature:()
H	langdef.o	/^/;"	v
HBar	cSHEdit.h	/^      TScrollBar * HBar;$/;"	m	class:SHEdit::TSHEdit	access:private
HMax	uDrawer.h	/^      int HPos, HMax;$/;"	m	class:SHEdit::Drawer	access:private
HPos	uDrawer.h	/^      int HPos, HMax;$/;"	m	class:SHEdit::Drawer	access:private
HistoryOnOff	uBuffer.cpp	/^void Buffer::HistoryOnOff()$/;"	f	class:Buffer	signature:()
HistoryOnOff	uBuffer.h	/^      void HistoryOnOff();        \/\/purges stacks if the keepHistory flag is off; to be placed before returns in insert\/delete$/;"	p	class:SHEdit::Buffer	access:private	signature:()
IMPLIED	LICENSE	/^IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,$/;"	v
IMark	uMark.cpp	/^  IMark::IMark(SHEdit::Format * format, bool begin, IPos * itr)$/;"	f	class:IMark	signature:(SHEdit::Format * format, bool begin, IPos * itr)
IMark	uMark.h	/^      IMark(Format * format, bool begin, IPos * itr);$/;"	p	class:SHEdit::IMark	access:public	signature:(Format * format, bool begin, IPos * itr)
IMark	uMark.h	/^  class IMark : public IPos$/;"	c	namespace:SHEdit	inherits:IPos
IMark::IMark	uMark.cpp	/^  IMark::IMark(SHEdit::Format * format, bool begin, IPos * itr)$/;"	f	class:IMark	signature:(SHEdit::Format * format, bool begin, IPos * itr)
IMark::~IMark	uMark.cpp	/^IMark::~IMark()$/;"	f	class:IMark	signature:()
IMarkList	uBuffer.h	/^      std::set<IPos*, IPos::compare> IMarkList;$/;"	m	class:SHEdit::Buffer	access:private
IMarkupBegin	uIPos.cpp	/^IMark* IPos::IMarkupBegin(SHEdit::Format * format)$/;"	f	class:IPos	signature:(SHEdit::Format * format)
IMarkupBegin	uIPos.h	/^      IMark* IMarkupBegin(SHEdit::Format * format);                                                  \/*!< Places Iterator handled mark at IPos's position. For formatting overview see \\ref index . For more specific info see IMark class *\/$/;"	p	class:SHEdit::IPos	access:public	signature:(SHEdit::Format * format)
IMarkupEnd	uIPos.cpp	/^IMark* IPos::IMarkupEnd(SHEdit::Format * format)$/;"	f	class:IPos	signature:(SHEdit::Format * format)
IMarkupEnd	uIPos.h	/^      IMark* IMarkupEnd(SHEdit::Format * format);                                                    \/*!< Places Iterator handled mark at IPos's position. For formatting overview see \\ref index . For more specific info see IMark class *\/$/;"	p	class:SHEdit::IPos	access:public	signature:(SHEdit::Format * format)
IPType	uIPos.h	/^      enum IPType{iptPos, iptIter, iptMark};$/;"	g	class:SHEdit::IPos	access:public
IPos	uIPos.cpp	/^IPos::IPos()$/;"	f	class:IPos	signature:()
IPos	uIPos.cpp	/^IPos::IPos(Buffer * buffer, NSpan * line, int linenum, int pos)$/;"	f	class:IPos	signature:(Buffer * buffer, NSpan * line, int linenum, int pos)
IPos	uIPos.cpp	/^IPos::IPos(const IPos& ip)$/;"	f	class:IPos	signature:(const IPos& ip)
IPos	uIPos.h	/^      IPos();$/;"	p	class:SHEdit::IPos	access:public	signature:()
IPos	uIPos.h	/^      IPos(Buffer * buffer, NSpan * line, int linenum, int pos);$/;"	p	class:SHEdit::IPos	access:public	signature:(Buffer * buffer, NSpan * line, int linenum, int pos)
IPos	uIPos.h	/^      IPos(const IPos& ipos);$/;"	p	class:SHEdit::IPos	access:public	signature:(const IPos& ipos)
IPos	uIPos.h	/^  class IPos$/;"	c	namespace:SHEdit
IPos::Compare	uIPos.cpp	/^bool IPos::Compare(const IPos*& a, const IPos*& b)$/;"	f	class:IPos	signature:(const IPos*& a, const IPos*& b)
IPos::Copy	uIPos.cpp	/^void IPos::Copy(const IPos& ip)$/;"	f	class:IPos	signature:(const IPos& ip)
IPos::IMarkupBegin	uIPos.cpp	/^IMark* IPos::IMarkupBegin(SHEdit::Format * format)$/;"	f	class:IPos	signature:(SHEdit::Format * format)
IPos::IMarkupEnd	uIPos.cpp	/^IMark* IPos::IMarkupEnd(SHEdit::Format * format)$/;"	f	class:IPos	signature:(SHEdit::Format * format)
IPos::IPos	uIPos.cpp	/^IPos::IPos()$/;"	f	class:IPos	signature:()
IPos::IPos	uIPos.cpp	/^IPos::IPos(Buffer * buffer, NSpan * line, int linenum, int pos)$/;"	f	class:IPos	signature:(Buffer * buffer, NSpan * line, int linenum, int pos)
IPos::IPos	uIPos.cpp	/^IPos::IPos(const IPos& ip)$/;"	f	class:IPos	signature:(const IPos& ip)
IPos::Invalidate	uIPos.cpp	/^void IPos::Invalidate()$/;"	f	class:IPos	signature:()
IPos::RecalcPos	uIPos.cpp	/^void IPos::RecalcPos()$/;"	f	class:IPos	signature:()
IPos::ReconstructIMarkFontStyle	uIPos.cpp	/^FontStyle IPos::ReconstructIMarkFontStyle()$/;"	f	class:IPos	signature:()
IPos::Update	uIPos.cpp	/^void IPos::Update()$/;"	f	class:IPos	signature:()
IPos::UpdatePos	uIPos.cpp	/^void IPos::UpdatePos()$/;"	f	class:IPos	signature:()
IPos::Valid	uIPos.cpp	/^bool IPos::Valid()$/;"	f	class:IPos	signature:()
IPos::compare::operator ()	uIPos.cpp	/^bool IPos::compare::operator()(const IPos* a, const IPos* b) const$/;"	f	class:IPos::compare	signature:(const IPos* a, const IPos* b) const
IPos::operator =	uIPos.cpp	/^IPos& IPos::operator=(const IPos& p)$/;"	f	class:IPos	signature:(const IPos& p)
IPos::operator ==	uIPos.cpp	/^bool IPos::operator==(const IPos& p)$/;"	f	class:IPos	signature:(const IPos& p)
IPos::~IPos	uIPos.cpp	/^IPos::~IPos()$/;"	f	class:IPos	signature:()
Init	uCursor.cpp	/^void CIter::Init()$/;"	f	class:CIter	signature:()
Init	uCursor.h	/^                void Init();$/;"	p	class:SHEdit::CIter	access:private	signature:()
InitBanks	uParser.cpp	/^void Parser::ParserState::InitBanks(int count)$/;"	f	class:Parser::ParserState	signature:(int count)
InitBanks	uParser.h	/^        void InitBanks(int count);$/;"	p	struct:SHEdit::Parser::ParserState	access:public	signature:(int count)
Insert	cSHEdit.cpp	/^void TSHEdit::Insert(const wchar_t * text, Iter * itr)$/;"	f	class:TSHEdit	signature:(const wchar_t * text, Iter * itr)
Insert	cSHEdit.h	/^      void Insert(const wchar_t * text, Iter * itr = NULL);                                          \/*!< Handles all insertions.*\/$/;"	p	class:SHEdit::TSHEdit	access:protected	signature:(const wchar_t * text, Iter * itr = NULL)
Insert	uBuffer.cpp	/^int Buffer::Insert(Iter * At, const wchar_t * string)$/;"	f	class:Buffer	signature:(Iter * At, const wchar_t * string)
Insert	uBuffer.h	/^      int Insert(Iter * At, const wchar_t * string);$/;"	p	class:SHEdit::Buffer	access:public	signature:(Iter * At, const wchar_t * string)
Insert	uCursor.cpp	/^void CIter::Insert(String text)$/;"	f	class:CIter	signature:(String text)
Insert	uCursor.h	/^             void Insert(String xText);$/;"	p	class:SHEdit::CIter	access:public	signature:(String xText)
Invalidate	uIPos.cpp	/^void IPos::Invalidate()$/;"	f	class:IPos	signature:()
Invalidate	uIPos.h	/^      void Invalidate();$/;"	p	class:SHEdit::IPos	access:public	signature:()
Invalidate	uIter.cpp	/^void Iter::Invalidate()$/;"	f	class:Iter	signature:()
Invalidate	uIter.h	/^      void Invalidate();$/;"	p	class:SHEdit::Iter	access:public	signature:()
InvalidateAll	uParser.cpp	/^void Parser::InvalidateAll()$/;"	f	class:Parser	signature:()
InvalidateAll	uParser.h	/^      void InvalidateAll();$/;"	p	class:SHEdit::Parser	access:public	signature:()
IsAl	uLanguageDefinition.cpp	/^bool LanguageDefinition::IsAl(wchar_t c)$/;"	f	class:LanguageDefinition	signature:(wchar_t c)
IsAl	uLanguageDefinition.h	/^      virtual bool IsAl(wchar_t c);$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(wchar_t c)
IsAlNum	uLanguageDefinition.cpp	/^bool LanguageDefinition::IsAlNum(wchar_t c)$/;"	f	class:LanguageDefinition	signature:(wchar_t c)
IsAlNum	uLanguageDefinition.h	/^      virtual bool IsAlNum(wchar_t c);$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(wchar_t c)
IsLineFirstVisible	cSHEdit.cpp	/^bool __fastcall TSHEdit::IsLineFirstVisible(NSpan * line)$/;"	f	class:TSHEdit	signature:(NSpan * line)
IsLineFirstVisible	cSHEdit.h	/^      bool __fastcall IsLineFirstVisible(NSpan * line);$/;"	p	class:SHEdit::TSHEdit	access:protected	signature:(NSpan * line)
IsNum	uLanguageDefinition.cpp	/^bool LanguageDefinition::IsNum(wchar_t c)$/;"	f	class:LanguageDefinition	signature:(wchar_t c)
IsNum	uLanguageDefinition.h	/^      virtual bool IsNum(wchar_t c);$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(wchar_t c)
IsPlainWord	uBuffer.cpp	/^bool Buffer::IsPlainWord(const wchar_t * string)                \/\/OK$/;"	f	class:Buffer	signature:(const wchar_t * string)
IsPlainWord	uBuffer.h	/^      bool IsPlainWord(const wchar_t * string);$/;"	p	class:SHEdit::Buffer	access:public	signature:(const wchar_t * string)
IsUnderCursor	uCursor.cpp	/^      \/*AUTOGENERATED*\/ bool  CIter::IsUnderCursor (const wchar_t *& string, bool caseSensitive, bool wholeword)  { Init();  return  this->itr.IsUnderCursor (string,caseSensitive,wholeword);} \/*!< Tests if the string is at the position of cursor. Serves for FindNext\/FindNext. *\/$/;"	f	class:CIter	signature:(const wchar_t *& string, bool caseSensitive, bool wholeword)
IsUnderCursor	uCursor.h	/^      \/*AUTOGENERATED*\/ bool  CIter::IsUnderCursor (const wchar_t *& string, bool caseSensitive, bool wholeword)  ; \/*!< Tests if the string is at the position of cursor. Serves for FindNext\/FindNext. *\/$/;"	p	class:SHEdit::CIter::CIter	access:public	signature:(const wchar_t *& string, bool caseSensitive, bool wholeword)
IsUnderCursor	uIter.cpp	/^bool Iter::IsUnderCursor(const wchar_t *& string, bool caseSensitive, bool wholeword)$/;"	f	class:Iter	signature:(const wchar_t *& string, bool caseSensitive, bool wholeword)
IsUnderCursor	uIter.h	/^      bool IsUnderCursor(const wchar_t *& string, bool caseSensitive, bool wholeword)\/*AUTOGEN_PASS*\/; \/*!< Tests if the string is at the position of cursor. Serves for FindNext\/FindNext. *\/$/;"	p	class:SHEdit::Iter	access:public	signature:(const wchar_t *& string, bool caseSensitive, bool wholeword)
IsWhite	uLanguageDefinition.cpp	/^bool LanguageDefinition::IsWhite(wchar_t c)$/;"	f	class:LanguageDefinition	signature:(wchar_t c)
IsWhite	uLanguageDefinition.h	/^      virtual bool IsWhite(wchar_t c);                                                               \/*!< not used anywhere in project if I am not mistaken *\/$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(wchar_t c)
IsWordChar	uIter.cpp	/^bool Iter::IsWordChar(wchar_t c)$/;"	f	class:Iter	signature:(wchar_t c)
IsWordChar	uIter.h	/^      inline bool IsWordChar(wchar_t c);$/;"	p	class:SHEdit::Iter	access:private	signature:(wchar_t c)
Iter	uIter.cpp	/^  Iter::Iter()$/;"	f	class:Iter	signature:()
Iter	uIter.cpp	/^  Iter::Iter(NSpan * line)$/;"	f	class:Iter	signature:(NSpan * line)
Iter	uIter.cpp	/^  Iter::Iter(NSpan * line, int linenum, int pos, Buffer * buffer)$/;"	f	class:Iter	signature:(NSpan * line, int linenum, int pos, Buffer * buffer)
Iter	uIter.cpp	/^  Iter::Iter(const Iter& it)$/;"	f	class:Iter	signature:(const Iter& it)
Iter	uIter.cpp	/^  Iter::Iter(int offset, Span * word, NSpan * line, Buffer * buffer, int linenum)$/;"	f	class:Iter	signature:(int offset, Span * word, NSpan * line, Buffer * buffer, int linenum)
Iter	uIter.h	/^      Iter();$/;"	p	class:SHEdit::Iter	access:public	signature:()
Iter	uIter.h	/^      Iter(NSpan * line);$/;"	p	class:SHEdit::Iter	access:public	signature:(NSpan * line)
Iter	uIter.h	/^      Iter(NSpan * line, int linenum, int pos, Buffer * buffer);$/;"	p	class:SHEdit::Iter	access:public	signature:(NSpan * line, int linenum, int pos, Buffer * buffer)
Iter	uIter.h	/^      Iter(const Iter& itr);$/;"	p	class:SHEdit::Iter	access:public	signature:(const Iter& itr)
Iter	uIter.h	/^      Iter(int offset, Span * word, NSpan * line, Buffer * buffer, int linenum = -1);$/;"	p	class:SHEdit::Iter	access:public	signature:(int offset, Span * word, NSpan * line, Buffer * buffer, int linenum = -1)
Iter	uIter.h	/^  class Iter : protected IPos, public std::iterator<std::bidirectional_iterator_tag, const wchar_t>$/;"	c	namespace:SHEdit	inherits:IPos,std::iterator
Iter::Duplicate	uIter.cpp	/^Iter * Iter::Duplicate()$/;"	f	class:Iter	signature:()
Iter::FindNext	uIter.cpp	/^bool Iter::FindNext(wchar_t * string, bool skip, bool caseSensitive, bool wholeword)$/;"	f	class:Iter	signature:(wchar_t * string, bool skip, bool caseSensitive, bool wholeword)
Iter::FindPrev	uIter.cpp	/^bool Iter::FindPrev(wchar_t * string, bool skip, bool caseSensitive, bool wholeword)$/;"	f	class:Iter	signature:(wchar_t * string, bool skip, bool caseSensitive, bool wholeword)
Iter::GetChar	uIter.cpp	/^wchar_t Iter::GetChar()$/;"	f	class:Iter	signature:()
Iter::GetDistance	uIter.cpp	/^int Iter::GetDistance(Iter* second)$/;"	f	class:Iter	signature:(Iter* second)
Iter::GetLeftOffset	uIter.cpp	/^int Iter::GetLeftOffset()$/;"	f	class:Iter	signature:()
Iter::GetLine	uIter.cpp	/^String Iter::GetLine()$/;"	f	class:Iter	signature:()
Iter::GetLineNum	uIter.cpp	/^int Iter::GetLineNum()$/;"	f	class:Iter	signature:()
Iter::GetNextChar	uIter.cpp	/^wchar_t Iter::GetNextChar()$/;"	f	class:Iter	signature:()
Iter::GetPrevChar	uIter.cpp	/^wchar_t Iter::GetPrevChar()$/;"	f	class:Iter	signature:()
Iter::GoBy	uIter.cpp	/^void Iter::GoBy(int chars, bool multiline)$/;"	f	class:Iter	signature:(int chars, bool multiline)
Iter::GoByOffset	uIter.cpp	/^void Iter::GoByOffset(int chars)$/;"	f	class:Iter	signature:(int chars)
Iter::GoChar	uIter.cpp	/^bool Iter::GoChar()$/;"	f	class:Iter	signature:()
Iter::GoLeft	uIter.cpp	/^void Iter::GoLeft(int chars, bool multiline)$/;"	f	class:Iter	signature:(int chars, bool multiline)
Iter::GoLine	uIter.cpp	/^bool Iter::GoLine(bool allowEnd)$/;"	f	class:Iter	signature:(bool allowEnd)
Iter::GoLineEnd	uIter.cpp	/^bool Iter::GoLineEnd()$/;"	f	class:Iter	signature:()
Iter::GoLineStart	uIter.cpp	/^bool Iter::GoLineStart()$/;"	f	class:Iter	signature:()
Iter::GoToLine	uIter.cpp	/^void Iter::GoToLine(int line)$/;"	f	class:Iter	signature:(int line)
Iter::GoWord	uIter.cpp	/^bool Iter::GoWord()$/;"	f	class:Iter	signature:()
Iter::GoWordEndLiteral	uIter.cpp	/^void Iter::GoWordEndLiteral()$/;"	f	class:Iter	signature:()
Iter::GoWordLiteral	uIter.cpp	/^void Iter::GoWordLiteral()$/;"	f	class:Iter	signature:()
Iter::Invalidate	uIter.cpp	/^void Iter::Invalidate()$/;"	f	class:Iter	signature:()
Iter::IsUnderCursor	uIter.cpp	/^bool Iter::IsUnderCursor(const wchar_t *& string, bool caseSensitive, bool wholeword)$/;"	f	class:Iter	signature:(const wchar_t *& string, bool caseSensitive, bool wholeword)
Iter::IsWordChar	uIter.cpp	/^bool Iter::IsWordChar(wchar_t c)$/;"	f	class:Iter	signature:(wchar_t c)
Iter::Iter	uIter.cpp	/^  Iter::Iter()$/;"	f	class:Iter	signature:()
Iter::Iter	uIter.cpp	/^  Iter::Iter(NSpan * line)$/;"	f	class:Iter	signature:(NSpan * line)
Iter::Iter	uIter.cpp	/^  Iter::Iter(NSpan * line, int linenum, int pos, Buffer * buffer)$/;"	f	class:Iter	signature:(NSpan * line, int linenum, int pos, Buffer * buffer)
Iter::Iter	uIter.cpp	/^  Iter::Iter(const Iter& it)$/;"	f	class:Iter	signature:(const Iter& it)
Iter::Iter	uIter.cpp	/^  Iter::Iter(int offset, Span * word, NSpan * line, Buffer * buffer, int linenum)$/;"	f	class:Iter	signature:(int offset, Span * word, NSpan * line, Buffer * buffer, int linenum)
Iter::LineIsEmpty	uIter.cpp	/^bool Iter::LineIsEmpty(bool allowWhite)$/;"	f	class:Iter	signature:(bool allowWhite)
Iter::MarkupBegin	uIter.cpp	/^void Iter::MarkupBegin( SHEdit::Format * format)$/;"	f	class:Iter	signature:( SHEdit::Format * format)
Iter::MarkupEnd	uIter.cpp	/^void Iter::MarkupEnd( SHEdit::Format * format)$/;"	f	class:Iter	signature:( SHEdit::Format * format)
Iter::MarkupRem	uIter.cpp	/^void Iter::MarkupRem(SHEdit::Format * format)$/;"	f	class:Iter	signature:(SHEdit::Format * format)
Iter::RecalcPos	uIter.cpp	/^void Iter::RecalcPos()$/;"	f	class:Iter	signature:()
Iter::RevChar	uIter.cpp	/^bool Iter::RevChar()$/;"	f	class:Iter	signature:()
Iter::RevLine	uIter.cpp	/^bool Iter::RevLine()$/;"	f	class:Iter	signature:()
Iter::RevWord	uIter.cpp	/^bool Iter::RevWord()$/;"	f	class:Iter	signature:()
Iter::RevWordLiteral	uIter.cpp	/^void Iter::RevWordLiteral()$/;"	f	class:Iter	signature:()
Iter::Update	uIter.cpp	/^void Iter::Update()$/;"	f	class:Iter	signature:()
Iter::UpdateNextImark	uIter.cpp	/^void Iter::UpdateNextImark()$/;"	f	class:Iter	signature:()
Iter::UpdatePos	uIter.cpp	/^void Iter::UpdatePos()$/;"	f	class:Iter	signature:()
Iter::Valid	uIter.cpp	/^bool Iter::Valid()$/;"	f	class:Iter	signature:()
Iter::operator !=	uIter.cpp	/^bool Iter::operator!=(const Iter& itr)$/;"	f	class:Iter	signature:(const Iter& itr)
Iter::operator *	uIter.cpp	/^wchar_t& Iter::operator*()$/;"	f	class:Iter	signature:()
Iter::operator ++	uIter.cpp	/^Iter& Iter::operator++()$/;"	f	class:Iter	signature:()
Iter::operator --	uIter.cpp	/^Iter& Iter::operator--()$/;"	f	class:Iter	signature:()
Iter::operator <	uIter.cpp	/^bool Iter::operator<(const Iter& itr)$/;"	f	class:Iter	signature:(const Iter& itr)
Iter::operator =	uIter.cpp	/^Iter& Iter::operator=(const Iter& itr)$/;"	f	class:Iter	signature:(const Iter& itr)
Iter::operator ==	uIter.cpp	/^bool Iter::operator==(const Iter& itr)$/;"	f	class:Iter	signature:(const Iter& itr)
Iter::operator >	uIter.cpp	/^bool Iter::operator>(const Iter& itr)$/;"	f	class:Iter	signature:(const Iter& itr)
Iter::~Iter	uIter.cpp	/^Iter::~Iter()$/;"	f	class:Iter	signature:()
ItersTranslateDelete	uBuffer.cpp	/^void Buffer::ItersTranslateDelete(int fromlinenum, int frompos, int tolinenum, int topos, NSpan * toline)$/;"	f	class:Buffer	signature:(int fromlinenum, int frompos, int tolinenum, int topos, NSpan * toline)
ItersTranslateDelete	uBuffer.h	/^      void ItersTranslateDelete(int fromlinenum, int frompos, int tolinenum, int topos, NSpan * toline);$/;"	p	class:SHEdit::Buffer	access:private	signature:(int fromlinenum, int frompos, int tolinenum, int topos, NSpan * toline)
ItersTranslateInsert	uBuffer.cpp	/^void Buffer::ItersTranslateInsert(int linenum, int pos, int bylines, int topos, NSpan * toline)$/;"	f	class:Buffer	signature:(int linenum, int pos, int bylines, int topos, NSpan * toline)
ItersTranslateInsert	uBuffer.h	/^      void ItersTranslateInsert(int linenum, int pos, int bylines, int topos, NSpan * toline);$/;"	p	class:SHEdit::Buffer	access:private	signature:(int linenum, int pos, int bylines, int topos, NSpan * toline)
ItrList	uBuffer.h	/^      std::list<IPos*> ItrList;$/;"	m	class:SHEdit::Buffer	access:private
ItrToXY	cSHEdit.cpp	/^void TSHEdit::ItrToXY(Iter * itr, int& x, int& y)$/;"	f	class:TSHEdit	signature:(Iter * itr, int& x, int& y)
ItrToXY	cSHEdit.h	/^      void ItrToXY(Iter * itr, int& x, int& y);$/;"	p	class:SHEdit::TSHEdit	access:public	signature:(Iter * itr, int& x, int& y)
Jump	uLanguageDefinition.cpp	/^  LanguageDefinition::Jump::Jump()$/;"	f	class:LanguageDefinition::Jump	signature:()
Jump	uLanguageDefinition.cpp	/^  LanguageDefinition::Jump::Jump(short _pushmask, short _newmask, short _newgmask, LangDefJumpType _type, TreeNode * _next, FontStyle * _format)$/;"	f	class:LanguageDefinition::Jump	signature:(short _pushmask, short _newmask, short _newgmask, LangDefJumpType _type, TreeNode * _next, FontStyle * _format)
Jump	uLanguageDefinition.h	/^        Jump();$/;"	p	struct:SHEdit::LanguageDefinition::Jump	access:public	signature:()
Jump	uLanguageDefinition.h	/^        Jump(short _pushmask, short _newmask, short _newgmask, LangDefJumpType _type, TreeNode * _next, FontStyle * format);$/;"	p	struct:SHEdit::LanguageDefinition::Jump	access:public	signature:(short _pushmask, short _newmask, short _newgmask, LangDefJumpType _type, TreeNode * _next, FontStyle * format)
Jump	uLanguageDefinition.h	/^      struct Jump$/;"	s	class:SHEdit::LanguageDefinition	access:private
Jump	uLanguageDefinition.h	/^  enum LangDefSpecType{Empty = 0x1, Nomatch = 0x2, Normal=0x4, Jump=0x8, WordTag=0x20, LineTag=0x40, Lookahead = 0x80};$/;"	e	enum:SHEdit::LangDefSpecType
KBHook	cSHEdit.h	/^      HHOOK KBHook;                                                                                  \/*!< Serves for intercepting of keyboard events, that are not by default passed to components*\/$/;"	m	class:SHEdit::TSHEdit	access:private
KEEP_VIS_BOTTOM	config.h	24;"	d
KEEP_VIS_TOP	config.h	23;"	d
KIND	LICENSE	/^THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR$/;"	v
KeepHistory	cSHEdit.h	/^      __property bool KeepHistory = {read=GetKeepHistory, write=SetKeepHistory, default=true};$/;"	m	class:SHEdit::TSHEdit	access:public
KeyDownHandler	cSHEdit.cpp	/^void __fastcall TSHEdit::KeyDownHandler(System::TObject * Sender,System::Word &Key, Classes::TShiftState Shift)$/;"	f	class:TSHEdit	signature:(System::TObject * Sender,System::Word &Key, Classes::TShiftState Shift)
KeyDownHandler	cSHEdit.h	/^      void __fastcall KeyDownHandler(System::TObject * Sender, System::Word &Key, Classes::TShiftState Shift)     ;$/;"	p	class:SHEdit::TSHEdit	access:protected	signature:(System::TObject * Sender, System::Word &Key, Classes::TShiftState Shift)
KeyPressHandler	cSHEdit.cpp	/^void __fastcall TSHEdit::KeyPressHandler(System::TObject * Sender, System::WideChar &Key)$/;"	f	class:TSHEdit	signature:(System::TObject * Sender, System::WideChar &Key)
KeyPressHandler	cSHEdit.h	/^      void __fastcall KeyPressHandler(System::TObject * Sender,System::WideChar &Key)     ;$/;"	p	class:SHEdit::TSHEdit	access:protected	signature:(System::TObject * Sender,System::WideChar &Key)
KeyUpHandler	cSHEdit.cpp	/^void __fastcall TSHEdit::KeyUpHandler(System::TObject * Sender,System::Word &Key, Classes::TShiftState Shift)$/;"	f	class:TSHEdit	signature:(System::TObject * Sender,System::Word &Key, Classes::TShiftState Shift)
KeyUpHandler	cSHEdit.h	/^      void __fastcall KeyUpHandler(System::TObject * Sender,System::Word &Key, Classes::TShiftState Shift)         ;$/;"	p	class:SHEdit::TSHEdit	access:protected	signature:(System::TObject * Sender,System::Word &Key, Classes::TShiftState Shift)
LIABILITY	LICENSE	/^LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING$/;"	v
Label1	fSearchBar.h	/^  TLabel *Label1;$/;"	m	class:TSearchBar	access:private
LangDefJumpType	uLanguageDefinition.h	/^  enum LangDefJumpType{tJump, tPush, tMask};$/;"	g	namespace:SHEdit
LangDefSpecType	uLanguageDefinition.h	/^  enum LangDefSpecType{Empty = 0x1, Nomatch = 0x2, Normal=0x4, Jump=0x8, WordTag=0x20, LineTag=0x40, Lookahead = 0x80};$/;"	g	namespace:SHEdit
LanguageDefinition	uLangDef2Test.h	/^LanguageDefinition::LanguageDefinition()$/;"	f	class:LanguageDefinition	signature:()
LanguageDefinition	uLanguageDefinition.cpp	/^LanguageDefinition::LanguageDefinition()$/;"	f	class:LanguageDefinition	signature:()
LanguageDefinition	uLanguageDefinition.h	/^      LanguageDefinition();$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:()
LanguageDefinition	uLanguageDefinition.h	/^  class LanguageDefinition$/;"	c	namespace:SHEdit
LanguageDefinition	uLanguageDefinition2.cpp	/^LanguageDefinition::LanguageDefinition(const std::locale& l) : loc(l), tokenizer(), ids(1)$/;"	f	class:LanguageDefinition	signature:(const std::locale& l)
LanguageDefinition	uLanguageDefinition2.h	/^      LanguageDefinition(const std::locale& loc = std::locale());$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(const std::locale& loc = std::locale())
LanguageDefinition	uLanguageDefinition2.h	/^  class LanguageDefinition$/;"	c	namespace:SHEdit
LanguageDefinition::AddDupTree	uLanguageDefinition.cpp	/^LanguageDefinition::TreeNode * LanguageDefinition::AddDupTree(LanguageDefinition::TreeNode * tree, FontStyle * format)$/;"	f	class:LanguageDefinition	signature:(LanguageDefinition::TreeNode * tree, FontStyle * format)
LanguageDefinition::AddJump	uLanguageDefinition.cpp	/^void LanguageDefinition::AddJump(wchar_t * string, FontStyle * format, LangDefJumpType type, TreeNode * at, TreeNode * to, short jumpmask, short newmask, short gmask)$/;"	f	class:LanguageDefinition	signature:(wchar_t * string, FontStyle * format, LangDefJumpType type, TreeNode * at, TreeNode * to, short jumpmask, short newmask, short gmask)
LanguageDefinition::AddJumpFront	uLanguageDefinition.cpp	/^void LanguageDefinition::AddJumpFront(wchar_t * string, FontStyle * format, LangDefJumpType type, TreeNode * at, TreeNode * to, short jumpmask, short newmask, short gmask)$/;"	f	class:LanguageDefinition	signature:(wchar_t * string, FontStyle * format, LangDefJumpType type, TreeNode * at, TreeNode * to, short jumpmask, short newmask, short gmask)
LanguageDefinition::AddJumps	uLanguageDefinition.cpp	/^void LanguageDefinition::AddJumps(wchar_t * string, FontStyle * format, LangDefJumpType type, TreeNode * at, TreeNode * to, short jumpmask, short newmask, short gmask)$/;"	f	class:LanguageDefinition	signature:(wchar_t * string, FontStyle * format, LangDefJumpType type, TreeNode * at, TreeNode * to, short jumpmask, short newmask, short gmask)
LanguageDefinition::AddJumpsFront	uLanguageDefinition.cpp	/^void LanguageDefinition::AddJumpsFront(wchar_t * string, FontStyle * format, LangDefJumpType type, TreeNode * at, TreeNode * to, short jumpmask, short newmask, short gmask)$/;"	f	class:LanguageDefinition	signature:(wchar_t * string, FontStyle * format, LangDefJumpType type, TreeNode * at, TreeNode * to, short jumpmask, short newmask, short gmask)
LanguageDefinition::AddKeywords	uLanguageDefinition.cpp	/^void LanguageDefinition::AddKeywords(wchar_t * string, FontStyle * format, TreeNode * at)$/;"	f	class:LanguageDefinition	signature:(wchar_t * string, FontStyle * format, TreeNode * at)
LanguageDefinition::AddLine	uLanguageDefinition.cpp	/^LanguageDefinition::TreeNode* LanguageDefinition::AddLine(wchar_t * string, FontStyle * format, TreeNode * at, TreeNode * to)$/;"	f	class:LanguageDefinition	signature:(wchar_t * string, FontStyle * format, TreeNode * at, TreeNode * to)
LanguageDefinition::AddLineStrong	uLanguageDefinition.cpp	/^LanguageDefinition::TreeNode* LanguageDefinition::AddLineStrong(wchar_t * string, FontStyle * format, TreeNode * at, TreeNode * to)$/;"	f	class:LanguageDefinition	signature:(wchar_t * string, FontStyle * format, TreeNode * at, TreeNode * to)
LanguageDefinition::AddNewTree	uLanguageDefinition.cpp	/^LanguageDefinition::TreeNode * LanguageDefinition::AddNewTree(FontStyle * format)$/;"	f	class:LanguageDefinition	signature:(FontStyle * format)
LanguageDefinition::AddNewTree	uLanguageDefinition.cpp	/^LanguageDefinition::TreeNode * LanguageDefinition::AddNewTree(FontStyle * format, bool caseSensit)$/;"	f	class:LanguageDefinition	signature:(FontStyle * format, bool caseSensit)
LanguageDefinition::AddNonTerm	uLanguageDefinition2.cpp	/^void LanguageDefinition::AddNonTerm(const std::wstring& name, FontStyle* fs, int id, int flags)$/;"	f	class:LanguageDefinition	signature:(const std::wstring& name, FontStyle* fs, int id, int flags)
LanguageDefinition::AddPair	uLanguageDefinition.cpp	/^LanguageDefinition::TreeNode* LanguageDefinition::AddPair(wchar_t * opening, wchar_t * closing, FontStyle * format, TreeNode * at, TreeNode * to)$/;"	f	class:LanguageDefinition	signature:(wchar_t * opening, wchar_t * closing, FontStyle * format, TreeNode * at, TreeNode * to)
LanguageDefinition::AddPop	uLanguageDefinition.cpp	/^void LanguageDefinition::AddPop(wchar_t * string, FontStyle * format, TreeNode * at, short popmask, short popcount, short newgmask)$/;"	f	class:LanguageDefinition	signature:(wchar_t * string, FontStyle * format, TreeNode * at, short popmask, short popcount, short newgmask)
LanguageDefinition::AddPops	uLanguageDefinition.cpp	/^void LanguageDefinition::AddPops(wchar_t * string, FontStyle * format, TreeNode * at, short popmask, short popcount, short gmask)$/;"	f	class:LanguageDefinition	signature:(wchar_t * string, FontStyle * format, TreeNode * at, short popmask, short popcount, short gmask)
LanguageDefinition::AddPush	uLanguageDefinition.cpp	/^void LanguageDefinition::AddPush(wchar_t * string, FontStyle * format, TreeNode * at, TreeNode * to, short pushmask, short newmask, short gmask)$/;"	f	class:LanguageDefinition	signature:(wchar_t * string, FontStyle * format, TreeNode * at, TreeNode * to, short pushmask, short newmask, short gmask)
LanguageDefinition::AddPushFront	uLanguageDefinition.cpp	/^void LanguageDefinition::AddPushFront(wchar_t * string, FontStyle * format, TreeNode * at, TreeNode * to, short pushmask, short newmask, short gmask)$/;"	f	class:LanguageDefinition	signature:(wchar_t * string, FontStyle * format, TreeNode * at, TreeNode * to, short pushmask, short newmask, short gmask)
LanguageDefinition::AddPushPopPair	uLanguageDefinition.cpp	/^LanguageDefinition::TreeNode* LanguageDefinition::AddPushPopPair(wchar_t * opening, wchar_t * closing, FontStyle * format, TreeNode * at, TreeNode * to, short mask)$/;"	f	class:LanguageDefinition	signature:(wchar_t * opening, wchar_t * closing, FontStyle * format, TreeNode * at, TreeNode * to, short mask)
LanguageDefinition::AddPushes	uLanguageDefinition.cpp	/^void LanguageDefinition::AddPushes(wchar_t * string, FontStyle * format, TreeNode * at, TreeNode * to, short pushmask, short newmask, short gmask)$/;"	f	class:LanguageDefinition	signature:(wchar_t * string, FontStyle * format, TreeNode * at, TreeNode * to, short pushmask, short newmask, short gmask)
LanguageDefinition::AddPushesFront	uLanguageDefinition.cpp	/^void LanguageDefinition::AddPushesFront(wchar_t * string, FontStyle * format, TreeNode * at, TreeNode * to, short pushmask, short newmask, short gmask)$/;"	f	class:LanguageDefinition	signature:(wchar_t * string, FontStyle * format, TreeNode * at, TreeNode * to, short pushmask, short newmask, short gmask)
LanguageDefinition::AddRule	uLanguageDefinition2.cpp	/^void LanguageDefinition::AddRule(const std::wstring& name, std::wstring rule)$/;"	f	class:LanguageDefinition	signature:(const std::wstring& name, std::wstring rule)
LanguageDefinition::AddTerm	uLanguageDefinition2.cpp	/^void LanguageDefinition::AddTerm(const std::wstring& name,FontStyle* fs,const std::wstring& rgx, int id, int flags)$/;"	f	class:LanguageDefinition	signature:(const std::wstring& name,FontStyle* fs,const std::wstring& rgx, int id, int flags)
LanguageDefinition::AddWord	uLanguageDefinition.cpp	/^void LanguageDefinition::AddWord(wchar_t * string, FontStyle * format, TreeNode * at)$/;"	f	class:LanguageDefinition	signature:(wchar_t * string, FontStyle * format, TreeNode * at)
LanguageDefinition::Construct	uLanguageDefinition2.cpp	/^void LanguageDefinition::Construct(std::wstring& rule, std::vector<Node*>& endnodes)$/;"	f	class:LanguageDefinition	signature:(std::wstring& rule, std::vector<Node*>& endnodes)
LanguageDefinition::Finalize	uLanguageDefinition2.cpp	/^void LanguageDefinition::Finalize()$/;"	f	class:LanguageDefinition	signature:()
LanguageDefinition::FindOrCreateItem	uLanguageDefinition.cpp	/^LanguageDefinition::TreeNode* LanguageDefinition::FindOrCreateItem(TreeNode * item, wchar_t comp, TreeNode * at)$/;"	f	class:LanguageDefinition	signature:(TreeNode * item, wchar_t comp, TreeNode * at)
LanguageDefinition::GetDefSC	uLanguageDefinition.cpp	/^LanguageDefinition::SearchIter LanguageDefinition::GetDefSC(short id)$/;"	f	class:LanguageDefinition	signature:(short id)
LanguageDefinition::GetToken	uLanguageDefinition2.cpp	/^LanguageDefinition::TokType LanguageDefinition::GetToken(std::wstring& str, std::wstring& val, bool eat)$/;"	f	class:LanguageDefinition	signature:(std::wstring& str, std::wstring& val, bool eat)
LanguageDefinition::GetTree	uLanguageDefinition.cpp	/^LanguageDefinition::TreeNode* LanguageDefinition::GetTree()$/;"	f	class:LanguageDefinition	signature:()
LanguageDefinition::Go	uLanguageDefinition.cpp	/^LangDefSpecType LanguageDefinition::Go(SearchIter * item, wchar_t c, bool & lookahead)$/;"	f	class:LanguageDefinition	signature:(SearchIter * item, wchar_t c, bool & lookahead)
LanguageDefinition::IsAl	uLanguageDefinition.cpp	/^bool LanguageDefinition::IsAl(wchar_t c)$/;"	f	class:LanguageDefinition	signature:(wchar_t c)
LanguageDefinition::IsAlNum	uLanguageDefinition.cpp	/^bool LanguageDefinition::IsAlNum(wchar_t c)$/;"	f	class:LanguageDefinition	signature:(wchar_t c)
LanguageDefinition::IsNum	uLanguageDefinition.cpp	/^bool LanguageDefinition::IsNum(wchar_t c)$/;"	f	class:LanguageDefinition	signature:(wchar_t c)
LanguageDefinition::IsWhite	uLanguageDefinition.cpp	/^bool LanguageDefinition::IsWhite(wchar_t c)$/;"	f	class:LanguageDefinition	signature:(wchar_t c)
LanguageDefinition::Jump::Jump	uLanguageDefinition.cpp	/^  LanguageDefinition::Jump::Jump()$/;"	f	class:LanguageDefinition::Jump	signature:()
LanguageDefinition::Jump::Jump	uLanguageDefinition.cpp	/^  LanguageDefinition::Jump::Jump(short _pushmask, short _newmask, short _newgmask, LangDefJumpType _type, TreeNode * _next, FontStyle * _format)$/;"	f	class:LanguageDefinition::Jump	signature:(short _pushmask, short _newmask, short _newgmask, LangDefJumpType _type, TreeNode * _next, FontStyle * _format)
LanguageDefinition::LanguageDefinition	uLangDef2Test.h	/^LanguageDefinition::LanguageDefinition()$/;"	f	class:LanguageDefinition	signature:()
LanguageDefinition::LanguageDefinition	uLanguageDefinition.cpp	/^LanguageDefinition::LanguageDefinition()$/;"	f	class:LanguageDefinition	signature:()
LanguageDefinition::LanguageDefinition	uLanguageDefinition2.cpp	/^LanguageDefinition::LanguageDefinition(const std::locale& l) : loc(l), tokenizer(), ids(1)$/;"	f	class:LanguageDefinition	signature:(const std::locale& l)
LanguageDefinition::Node::Add	uLanguageDefinition2.cpp	/^LanguageDefinition::Node* LanguageDefinition::Node::Add(const Node& n)$/;"	f	class:LanguageDefinition::Node	signature:(const Node& n)
LanguageDefinition::Node::Cq	uLanguageDefinition2.cpp	/^bool LanguageDefinition::Node::Cq(const Node& n)$/;"	f	class:LanguageDefinition::Node	signature:(const Node& n)
LanguageDefinition::Node::Eq	uLanguageDefinition2.cpp	/^bool LanguageDefinition::Node::Eq(const Node& n)$/;"	f	class:LanguageDefinition::Node	signature:(const Node& n)
LanguageDefinition::Node::ExpandLambda	uLanguageDefinition2.cpp	/^void LanguageDefinition::Node::ExpandLambda(std::map<int, Node*>& index, Node* next)$/;"	f	class:LanguageDefinition::Node	signature:(std::map<int, Node*>& index, Node* next)
LanguageDefinition::Node::Finalize	uLanguageDefinition2.cpp	/^void LanguageDefinition::Node::Finalize()$/;"	f	class:LanguageDefinition::Node	signature:()
LanguageDefinition::Node::operator ==	uLanguageDefinition2.cpp	/^bool LanguageDefinition::Node::operator==(const Node& n)$/;"	f	class:LanguageDefinition::Node	signature:(const Node& n)
LanguageDefinition::Parse	uLanguageDefinition2.cpp	/^void LanguageDefinition::Parse(IT& from, const IT& to, PState& s, bool& stylechanged, FontStyle*&fs)$/;"	f	class:LanguageDefinition	signature:(IT& from, const IT& to, PState& s, bool& stylechanged, FontStyle*&fs)
LanguageDefinition::ParseString	uLanguageDefinition2.cpp	/^void LanguageDefinition::ParseString(std::wstring& rule, std::vector<Node*>& endnodes)$/;"	f	class:LanguageDefinition	signature:(std::wstring& rule, std::vector<Node*>& endnodes)
LanguageDefinition::Pop::Pop	uLanguageDefinition.cpp	/^  LanguageDefinition::Pop::Pop()$/;"	f	class:LanguageDefinition::Pop	signature:()
LanguageDefinition::Pop::Pop	uLanguageDefinition.cpp	/^  LanguageDefinition::Pop::Pop(short _popmask, short _newgmask, short _popcount, FontStyle * _format)$/;"	f	class:LanguageDefinition::Pop	signature:(short _popmask, short _newgmask, short _popcount, FontStyle * _format)
LanguageDefinition::SearchIter::SearchIter	uLanguageDefinition.cpp	/^  LanguageDefinition::SearchIter::SearchIter()$/;"	f	class:LanguageDefinition::SearchIter	signature:()
LanguageDefinition::SearchIter::operator !=	uLanguageDefinition.cpp	/^bool LanguageDefinition::SearchIter::operator!=(const SearchIter& sit)$/;"	f	class:LanguageDefinition::SearchIter	signature:(const SearchIter& sit)
LanguageDefinition::SearchIter::operator ==	uLanguageDefinition.cpp	/^bool LanguageDefinition::SearchIter::operator==(const SearchIter& sit)$/;"	f	class:LanguageDefinition::SearchIter	signature:(const SearchIter& sit)
LanguageDefinition::SetAllowWhiteSkipping	uLanguageDefinition.cpp	/^void LanguageDefinition::SetAllowWhiteSkipping(bool allow)$/;"	f	class:LanguageDefinition	signature:(bool allow)
LanguageDefinition::SetCaseSensitive	uLanguageDefinition.cpp	/^void LanguageDefinition::SetCaseSensitive(bool casesensitive)$/;"	f	class:LanguageDefinition	signature:(bool casesensitive)
LanguageDefinition::SetDefaultColor	uLanguageDefinition.cpp	/^void LanguageDefinition::SetDefaultColor(TColor * defColor)$/;"	f	class:LanguageDefinition	signature:(TColor * defColor)
LanguageDefinition::SetTreeCaseSensitive	uLanguageDefinition.cpp	/^void LanguageDefinition::SetTreeCaseSensitive(TreeNode * item, bool casesensitive)$/;"	f	class:LanguageDefinition	signature:(TreeNode * item, bool casesensitive)
LanguageDefinition::TreeNode::AddJump	uLanguageDefinition.cpp	/^void LanguageDefinition::TreeNode::AddJump(short pushmask, short newmask, short gmask, LangDefJumpType _type, TreeNode * to, bool begin, FontStyle * format)$/;"	f	class:LanguageDefinition::TreeNode	signature:(short pushmask, short newmask, short gmask, LangDefJumpType _type, TreeNode * to, bool begin, FontStyle * format)
LanguageDefinition::TreeNode::AddPop	uLanguageDefinition.cpp	/^void LanguageDefinition::TreeNode::AddPop(short popmask, short newgmask, short popcount, bool begin, FontStyle * format)$/;"	f	class:LanguageDefinition::TreeNode	signature:(short popmask, short newgmask, short popcount, bool begin, FontStyle * format)
LanguageDefinition::TreeNode::TreeNode	uLanguageDefinition.cpp	/^LanguageDefinition::TreeNode::TreeNode(TreeNode * tree, SHEdit::FontStyle * format)$/;"	f	class:LanguageDefinition::TreeNode	signature:(TreeNode * tree, SHEdit::FontStyle * format)
LanguageDefinition::TreeNode::TreeNode	uLanguageDefinition.cpp	/^LanguageDefinition::TreeNode::TreeNode(wchar_t c, LangDefSpecType type, SHEdit::FontStyle * format, bool caseSensitive)$/;"	f	class:LanguageDefinition::TreeNode	signature:(wchar_t c, LangDefSpecType type, SHEdit::FontStyle * format, bool caseSensitive)
LanguageDefinition::_AddJump	uLanguageDefinition.cpp	/^void LanguageDefinition::_AddJump(bool begin, wchar_t * string, FontStyle * format, LangDefJumpType type, TreeNode * at, TreeNode * to, short jumpmask, short newmask, short gmask)$/;"	f	class:LanguageDefinition	signature:(bool begin, wchar_t * string, FontStyle * format, LangDefJumpType type, TreeNode * at, TreeNode * to, short jumpmask, short newmask, short gmask)
LanguageDefinition::_AddPush	uLanguageDefinition.cpp	/^void LanguageDefinition::_AddPush(bool begin, wchar_t * string, FontStyle * format, TreeNode * at, TreeNode * to, short pushmask, short newmask, short gmask)$/;"	f	class:LanguageDefinition	signature:(bool begin, wchar_t * string, FontStyle * format, TreeNode * at, TreeNode * to, short pushmask, short newmask, short gmask)
LanguageDefinition::~LanguageDefinition	uLanguageDefinition.cpp	/^LanguageDefinition::~LanguageDefinition()$/;"	f	class:LanguageDefinition	signature:()
LanguageDefinition::~LanguageDefinition	uLanguageDefinition2.cpp	/^LanguageDefinition::~LanguageDefinition()$/;"	f	class:LanguageDefinition	signature:()
LanguageDefinitionSQL	uLanguageDefinitionSQL.cpp	/^  LanguageDefinitionSQL::LanguageDefinitionSQL()$/;"	f	class:LanguageDefinitionSQL	signature:()
LanguageDefinitionSQL	uLanguageDefinitionSQL.h	/^    LanguageDefinitionSQL();$/;"	p	class:SHEdit::LanguageDefinitionSQL	access:public	signature:()
LanguageDefinitionSQL	uLanguageDefinitionSQL.h	/^  class LanguageDefinitionSQL : public LanguageDefinition$/;"	c	namespace:SHEdit	inherits:LanguageDefinition
LanguageDefinitionSQL::LanguageDefinitionSQL	uLanguageDefinitionSQL.cpp	/^  LanguageDefinitionSQL::LanguageDefinitionSQL()$/;"	f	class:LanguageDefinitionSQL	signature:()
LanguageDefinitionWebLangs	uLanguageDefinitionWebLangs.cpp	/^  LanguageDefinitionWebLangs::LanguageDefinitionWebLangs()$/;"	f	class:LanguageDefinitionWebLangs	signature:()
LanguageDefinitionWebLangs	uLanguageDefinitionWebLangs.h	/^      LanguageDefinitionWebLangs();$/;"	p	class:SHEdit::LanguageDefinitionWebLangs	access:public	signature:()
LanguageDefinitionWebLangs	uLanguageDefinitionWebLangs.h	/^  class LanguageDefinitionWebLangs : public LanguageDefinition$/;"	c	namespace:SHEdit	inherits:LanguageDefinition
LanguageDefinitionWebLangs::AddPops	uLanguageDefinitionWebLangs.cpp	/^void LanguageDefinitionWebLangs::AddPops(LanguageDefinition::TreeNode * at)$/;"	f	class:LanguageDefinitionWebLangs	signature:(LanguageDefinition::TreeNode * at)
LanguageDefinitionWebLangs::AddSafetyJumps	uLanguageDefinitionWebLangs.cpp	/^void LanguageDefinitionWebLangs::AddSafetyJumps()$/;"	f	class:LanguageDefinitionWebLangs	signature:()
LanguageDefinitionWebLangs::ConstructCss	uLanguageDefinitionWebLangs.cpp	/^void LanguageDefinitionWebLangs::ConstructCss(LanguageDefinition::TreeNode * at, TColor * bg, TColor * fg)$/;"	f	class:LanguageDefinitionWebLangs	signature:(LanguageDefinition::TreeNode * at, TColor * bg, TColor * fg)
LanguageDefinitionWebLangs::ConstructHtml	uLanguageDefinitionWebLangs.cpp	/^void LanguageDefinitionWebLangs::ConstructHtml(LanguageDefinition::TreeNode * at, TColor * bg, TColor * fg)$/;"	f	class:LanguageDefinitionWebLangs	signature:(LanguageDefinition::TreeNode * at, TColor * bg, TColor * fg)
LanguageDefinitionWebLangs::ConstructJavascript	uLanguageDefinitionWebLangs.cpp	/^void LanguageDefinitionWebLangs::ConstructJavascript(LanguageDefinition::TreeNode * at, TColor * bg, TColor * fg)$/;"	f	class:LanguageDefinitionWebLangs	signature:(LanguageDefinition::TreeNode * at, TColor * bg, TColor * fg)
LanguageDefinitionWebLangs::ConstructPhp	uLanguageDefinitionWebLangs.cpp	/^void LanguageDefinitionWebLangs::ConstructPhp(LanguageDefinition::TreeNode * at, TColor * bg, TColor * fg)$/;"	f	class:LanguageDefinitionWebLangs	signature:(LanguageDefinition::TreeNode * at, TColor * bg, TColor * fg)
LanguageDefinitionWebLangs::LanguageDefinitionWebLangs	uLanguageDefinitionWebLangs.cpp	/^  LanguageDefinitionWebLangs::LanguageDefinitionWebLangs()$/;"	f	class:LanguageDefinitionWebLangs	signature:()
LineIsEmpty	uCursor.cpp	/^      \/*AUTOGENERATED*\/ bool  CIter::LineIsEmpty ( bool allowWhite )  { Init();  return  this->itr.LineIsEmpty (allowWhite);} $/;"	f	class:CIter	signature:( bool allowWhite )
LineIsEmpty	uCursor.h	/^      \/*AUTOGENERATED*\/ bool  CIter::LineIsEmpty ( bool allowWhite = false)  ; $/;"	p	class:SHEdit::CIter::CIter	access:public	signature:( bool allowWhite = false)
LineIsEmpty	uIter.cpp	/^bool Iter::LineIsEmpty(bool allowWhite)$/;"	f	class:Iter	signature:(bool allowWhite)
LineIsEmpty	uIter.h	/^      bool LineIsEmpty( bool allowWhite = false)\/*AUTOGEN_PASS*\/;$/;"	p	class:SHEdit::Iter	access:public	signature:( bool allowWhite = false)
LineNums	cSHEdit.h	/^      __property bool LineNums = {read=GetLinenumsEnabled,write=SetLinenumsEnabled, default=true};$/;"	m	class:SHEdit::TSHEdit	access:public
LineTag	uLanguageDefinition.h	/^  enum LangDefSpecType{Empty = 0x1, Nomatch = 0x2, Normal=0x4, Jump=0x8, WordTag=0x20, LineTag=0x40, Lookahead = 0x80};$/;"	e	enum:SHEdit::LangDefSpecType
LoadFile	cSHEdit.cpp	/^void TSHEdit::LoadFile(const wchar_t * filename)$/;"	f	class:TSHEdit	signature:(const wchar_t * filename)
LoadFile	cSHEdit.h	/^      void LoadFile(const wchar_t * filename);$/;"	p	class:SHEdit::TSHEdit	access:public	signature:(const wchar_t * filename)
Log	cSHEdit.cpp	/^void __fastcall TSHEdit::Log(String str)$/;"	f	class:TSHEdit	signature:(String str)
Log	cSHEdit.h	/^      void __fastcall Log(String str);$/;"	p	class:SHEdit::TSHEdit	access:public	signature:(String str)
Lookahead	uLanguageDefinition.h	/^  enum LangDefSpecType{Empty = 0x1, Nomatch = 0x2, Normal=0x4, Jump=0x8, WordTag=0x20, LineTag=0x40, Lookahead = 0x80};$/;"	e	enum:SHEdit::LangDefSpecType
MARGINS	config.h	26;"	d
MASK_APOSTROPHE	uLanguageDefinitionWebLangs.h	10;"	d
MASK_DOUBLE_QUOTE	uLanguageDefinitionWebLangs.h	12;"	d
MASK_ECHO_IGNORE	uLanguageDefinitionWebLangs.h	15;"	d
MASK_ECHO_MODE	uLanguageDefinitionWebLangs.h	13;"	d
MASK_PHP	uLanguageDefinitionWebLangs.h	14;"	d
MASK_PHP_APOSTROPHE	uLanguageDefinitionWebLangs.h	16;"	d
MASK_PHP_QUOTE	uLanguageDefinitionWebLangs.h	17;"	d
MASK_PREDICTION	uLanguageDefinitionWebLangs.h	18;"	d
MASK_QUOTE	uLanguageDefinitionWebLangs.h	11;"	d
MAX_SCROLL_STEP	config.h	37;"	d
MERCHANTABILITY	LICENSE	/^IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,$/;"	v
Mark	uMark.cpp	/^Mark::Mark(SHEdit::Format * format, bool begin, short pos)$/;"	f	class:Mark	signature:(SHEdit::Format * format, bool begin, short pos)
Mark	uMark.h	/^      Mark(Format * format, bool begin, short pos);$/;"	p	class:SHEdit::Mark	access:public	signature:(Format * format, bool begin, short pos)
Mark	uMark.h	/^  class Mark$/;"	c	namespace:SHEdit
Mark::Mark	uMark.cpp	/^Mark::Mark(SHEdit::Format * format, bool begin, short pos)$/;"	f	class:Mark	signature:(SHEdit::Format * format, bool begin, short pos)
MarkAll	cSHEdit.cpp	/^void TSHEdit::MarkAll(const String& text, bool caseSensitive, bool wholeWord)$/;"	f	class:TSHEdit	signature:(const String& text, bool caseSensitive, bool wholeWord)
MarkAll	cSHEdit.h	/^      void MarkAll(const String& text, bool caseSensitive = false, bool wholeWord = false);$/;"	p	class:SHEdit::TSHEdit	access:public	signature:(const String& text, bool caseSensitive = false, bool wholeWord = false)
MarkupBegin	uCursor.cpp	/^      \/*AUTOGENERATED*\/ void  CIter::MarkupBegin (SHEdit::Format * format)  { Init();  this->itr.MarkupBegin (format);} \/*!< Adds positionless markup. For formatting overview see \\ref index *\/$/;"	f	class:CIter	signature:(SHEdit::Format * format)
MarkupBegin	uCursor.h	/^      \/*AUTOGENERATED*\/ void  CIter::MarkupBegin (SHEdit::Format * format)  ;                        \/*!< Adds positionless markup. For formatting overview see \\ref index *\/$/;"	p	class:SHEdit::CIter::CIter	access:public	signature:(SHEdit::Format * format)
MarkupBegin	uIter.cpp	/^void Iter::MarkupBegin( SHEdit::Format * format)$/;"	f	class:Iter	signature:( SHEdit::Format * format)
MarkupBegin	uIter.h	/^      void MarkupBegin(SHEdit::Format * format)\/*AUTOGEN_PASS*\/;                                     \/*!< Adds positionless markup. For formatting overview see \\ref index *\/$/;"	p	class:SHEdit::Iter	access:public	signature:(SHEdit::Format * format)
MarkupEnd	uCursor.cpp	/^      \/*AUTOGENERATED*\/ void  CIter::MarkupEnd (SHEdit::Format * format)  { Init();  this->itr.MarkupEnd (format);} \/*!< Adds positionless markup. For formatting overview see \\ref index *\/$/;"	f	class:CIter	signature:(SHEdit::Format * format)
MarkupEnd	uCursor.h	/^      \/*AUTOGENERATED*\/ void  CIter::MarkupEnd (SHEdit::Format * format)  ;                          \/*!< Adds positionless markup. For formatting overview see \\ref index *\/$/;"	p	class:SHEdit::CIter::CIter	access:public	signature:(SHEdit::Format * format)
MarkupEnd	uIter.cpp	/^void Iter::MarkupEnd( SHEdit::Format * format)$/;"	f	class:Iter	signature:( SHEdit::Format * format)
MarkupEnd	uIter.h	/^      void MarkupEnd(SHEdit::Format * format)\/*AUTOGEN_PASS*\/;                                       \/*!< Adds positionless markup. For formatting overview see \\ref index *\/$/;"	p	class:SHEdit::Iter	access:public	signature:(SHEdit::Format * format)
MarkupRem	uCursor.cpp	/^      \/*AUTOGENERATED*\/ void  CIter::MarkupRem (SHEdit::Format * format)  { Init();  this->itr.MarkupRem (format);} \/*!< Removes all positionless markup from current position. For formatting overview see \\ref index *\/$/;"	f	class:CIter	signature:(SHEdit::Format * format)
MarkupRem	uCursor.h	/^      \/*AUTOGENERATED*\/ void  CIter::MarkupRem (SHEdit::Format * format)  ;                          \/*!< Removes all positionless markup from current position. For formatting overview see \\ref index *\/$/;"	p	class:SHEdit::CIter::CIter	access:public	signature:(SHEdit::Format * format)
MarkupRem	uIter.cpp	/^void Iter::MarkupRem(SHEdit::Format * format)$/;"	f	class:Iter	signature:(SHEdit::Format * format)
MarkupRem	uIter.h	/^      void MarkupRem(SHEdit::Format * format)\/*AUTOGEN_PASS*\/;                                       \/*!< Removes all positionless markup from current position. For formatting overview see \\ref index *\/$/;"	p	class:SHEdit::Iter	access:public	signature:(SHEdit::Format * format)
MouseDown	cSHEdit.cpp	/^void __fastcall TSHEdit::MouseDown(TMouseButton Button, Classes::TShiftState Shift, int X, int Y)$/;"	f	class:TSHEdit	signature:(TMouseButton Button, Classes::TShiftState Shift, int X, int Y)
MouseDown	cSHEdit.h	/^      DYNAMIC void __fastcall MouseDown(TMouseButton Button, Classes::TShiftState Shift, int X, int Y);$/;"	p	class:SHEdit::TSHEdit	access:protected	signature:(TMouseButton Button, Classes::TShiftState Shift, int X, int Y)
MouseMove	cSHEdit.cpp	/^void __fastcall TSHEdit::MouseMove(Classes::TShiftState Shift, int X, int Y)$/;"	f	class:TSHEdit	signature:(Classes::TShiftState Shift, int X, int Y)
MouseMove	cSHEdit.h	/^      DYNAMIC void __fastcall MouseMove(Classes::TShiftState Shift, int X, int Y);$/;"	p	class:SHEdit::TSHEdit	access:protected	signature:(Classes::TShiftState Shift, int X, int Y)
MouseUp	cSHEdit.cpp	/^void __fastcall TSHEdit::MouseUp(TMouseButton Button, Classes::TShiftState Shift, int X, int Y)$/;"	f	class:TSHEdit	signature:(TMouseButton Button, Classes::TShiftState Shift, int X, int Y)
MouseUp	cSHEdit.h	/^      DYNAMIC void __fastcall MouseUp(TMouseButton Button, Classes::TShiftState Shift, int X, int Y);$/;"	p	class:SHEdit::TSHEdit	access:protected	signature:(TMouseButton Button, Classes::TShiftState Shift, int X, int Y)
NDEBUG	SHEditPackage.cbproj	/^			<Defines>NDEBUG;$(Defines)<\/Defines>$/;"	v
NDEBUG	config.h	14;"	d
NSpan	uSpan.cpp	/^  NSpan::NSpan()$/;"	f	class:NSpan	signature:()
NSpan	uSpan.cpp	/^  NSpan::NSpan(Iter * After)$/;"	f	class:NSpan	signature:(Iter * After)
NSpan	uSpan.cpp	/^  NSpan::NSpan(Span* afterword, NSpan* afterline)$/;"	f	class:NSpan	signature:(Span* afterword, NSpan* afterline)
NSpan	uSpan.h	/^    NSpan();$/;"	p	struct:SHEdit::NSpan	access:public	signature:()
NSpan	uSpan.h	/^    NSpan(Iter * After);$/;"	p	struct:SHEdit::NSpan	access:public	signature:(Iter * After)
NSpan	uSpan.h	/^    NSpan(Span* afterword, NSpan* afterline);$/;"	p	struct:SHEdit::NSpan	access:public	signature:(Span* afterword, NSpan* afterline)
NSpan	uSpan.h	/^  struct NSpan : Span$/;"	s	namespace:SHEdit	inherits:Span
NSpan::NSpan	uSpan.cpp	/^  NSpan::NSpan()$/;"	f	class:NSpan	signature:()
NSpan::NSpan	uSpan.cpp	/^  NSpan::NSpan(Iter * After)$/;"	f	class:NSpan	signature:(Iter * After)
NSpan::NSpan	uSpan.cpp	/^  NSpan::NSpan(Span* afterword, NSpan* afterline)$/;"	f	class:NSpan	signature:(Span* afterword, NSpan* afterline)
NSpan::~NSpan	uSpan.cpp	/^NSpan::~NSpan()$/;"	f	class:NSpan	signature:()
NTerm	uLanguageDefinition2.h	/^        NTerm(const std::wstring& n, FontStyle* f, int i, bool g, bool c);$/;"	p	struct:SHEdit::LanguageDefinition::NTerm	access:public	signature:(const std::wstring& n, FontStyle* f, int i, bool g, bool c)
NTerm	uLanguageDefinition2.h	/^      struct NTerm$/;"	s	class:SHEdit::LanguageDefinition	access:private
NType	uLanguageDefinition2.h	/^      enum NType {ntTerm, ntNTerm, ntLambda, ntEnd, ntTailrec};$/;"	g	class:SHEdit::LanguageDefinition	access:private
Name	uLanguageDefinition.h	/^        wchar_t * Name;$/;"	m	struct:SHEdit::LanguageDefinition::TreeNode	access:public
Node	uLanguageDefinition2.h	/^        Node() : type(ntLambda), r(), nextnodes(), lftidx(), recidx(){};$/;"	f	struct:SHEdit::LanguageDefinition::Node	access:public	signature:()
Node	uLanguageDefinition2.h	/^        Node(NTerm* t) : type(ntNTerm), r(t), nextnodes(), lftidx(), recidx(){};$/;"	f	struct:SHEdit::LanguageDefinition::Node	access:public	signature:(NTerm* t)
Node	uLanguageDefinition2.h	/^        Node(NType t) : type(t), r(), nextnodes(), lftidx(), recidx(){};$/;"	f	struct:SHEdit::LanguageDefinition::Node	access:public	signature:(NType t)
Node	uLanguageDefinition2.h	/^        Node(Term* t) : type(ntTerm), r(t), nextnodes(), lftidx(), recidx(){};$/;"	f	struct:SHEdit::LanguageDefinition::Node	access:public	signature:(Term* t)
Node	uLanguageDefinition2.h	/^      struct Node$/;"	s	class:SHEdit::LanguageDefinition	access:private
Node	uStack.h	/^      Node(T_data _data) : data(_data) { };$/;"	f	struct:Stack::Node	access:public	signature:(T_data _data)
Node	uStack.h	/^    struct Node$/;"	s	class:Stack	access:public
Nomatch	uLanguageDefinition.h	/^  enum LangDefSpecType{Empty = 0x1, Nomatch = 0x2, Normal=0x4, Jump=0x8, WordTag=0x20, LineTag=0x40, Lookahead = 0x80};$/;"	e	enum:SHEdit::LangDefSpecType
Normal	uLanguageDefinition.h	/^  enum LangDefSpecType{Empty = 0x1, Nomatch = 0x2, Normal=0x4, Jump=0x8, WordTag=0x20, LineTag=0x40, Lookahead = 0x80};$/;"	e	enum:SHEdit::LangDefSpecType
OTHERWISE	LICENSE	/^LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING$/;"	v
OnChange	cSHEdit.h	/^      __property TMessage OnChange = {read=FOnChange, write=FOnChange, default=NULL};$/;"	m	class:SHEdit::TSHEdit	access:public
OnClick	cSHEdit.h	/^      __property TMessage OnClick = {read=FOnClick, write=FOnClick, default=NULL};$/;"	m	class:SHEdit::TSHEdit	access:public
OnEnter	cSHEdit.h	/^      __property TMessage OnEnter = {read=FOnEnter, write=FOnEnter, default=NULL};$/;"	m	class:SHEdit::TSHEdit	access:public
OnEnterHandler	cSHEdit.cpp	/^void __fastcall TSHEdit::OnEnterHandler(TObject * Sender)$/;"	f	class:TSHEdit	signature:(TObject * Sender)
OnEnterHandler	cSHEdit.h	/^      void __fastcall OnEnterHandler(TObject * Sender);$/;"	p	class:SHEdit::TSHEdit	access:private	signature:(TObject * Sender)
OnExit	cSHEdit.h	/^      __property TMessage OnExit = {read=FOnExit, write=FOnExit, default=NULL};$/;"	m	class:SHEdit::TSHEdit	access:public
OnHScroll	cSHEdit.cpp	/^void __fastcall TSHEdit::OnHScroll(TObject *Sender, TScrollCode ScrollCode, int &ScrollPos)$/;"	f	class:TSHEdit	signature:(TObject *Sender, TScrollCode ScrollCode, int &ScrollPos)
OnHScroll	cSHEdit.h	/^      void __fastcall OnHScroll(TObject *Sender, TScrollCode ScrollCode, int &ScrollPos);$/;"	p	class:SHEdit::TSHEdit	access:private	signature:(TObject *Sender, TScrollCode ScrollCode, int &ScrollPos)
OnIdle	uParser.cpp	/^void __fastcall Parser::OnIdle(TObject * Sender, bool & Done)$/;"	f	class:Parser	signature:(TObject * Sender, bool & Done)
OnIdle	uParser.h	/^      void __fastcall OnIdle(TObject * Sender, bool& Done);$/;"	p	class:SHEdit::Parser	access:public	signature:(TObject * Sender, bool& Done)
OnKeyDown	cSHEdit.h	/^      __property TKeyEvent OnKeyDown = {read=FOnKeyDown, write=FOnKeyDown, default=NULL};$/;"	m	class:SHEdit::TSHEdit	access:public
OnKeyPress	cSHEdit.h	/^      __property TKeyPressEvent OnKeyPress = {read=FOnKeyPress, write=FOnKeyPress, default=NULL};$/;"	m	class:SHEdit::TSHEdit	access:public
OnKeyUp	cSHEdit.h	/^      __property TKeyEvent OnKeyUp = {read=FOnKeyUp, write=FOnKeyUp, default=NULL};$/;"	m	class:SHEdit::TSHEdit	access:public
OnMouseUp	cSHEdit.h	/^      __property TMouseEvent OnMouseUp = {read=FOnMouseUp, write=FOnMouseUp, default=NULL};$/;"	m	class:SHEdit::TSHEdit	access:public
OnResizeCallback	cSHEdit.cpp	/^void __fastcall TSHEdit::OnResizeCallback(TObject * Sender)$/;"	f	class:TSHEdit	signature:(TObject * Sender)
OnResizeCallback	cSHEdit.h	/^      void __fastcall OnResizeCallback(TObject* Sender);$/;"	p	class:SHEdit::TSHEdit	access:private	signature:(TObject* Sender)
OnTimer	cSHEdit.cpp	/^void __fastcall TSHEdit::OnTimer(TObject * Sender)$/;"	f	class:TSHEdit	signature:(TObject * Sender)
OnTimer	cSHEdit.h	/^      void __fastcall OnTimer(TObject * Sender);                                                     \/*!< ensures cursor blinking :) *\/$/;"	p	class:SHEdit::TSHEdit	access:private	signature:(TObject * Sender)
OnVScroll	cSHEdit.cpp	/^void __fastcall TSHEdit::OnVScroll(TObject *Sender, TScrollCode ScrollCode, int &ScrollPos)$/;"	f	class:TSHEdit	signature:(TObject *Sender, TScrollCode ScrollCode, int &ScrollPos)
OnVScroll	cSHEdit.h	/^      void __fastcall OnVScroll(TObject *Sender, TScrollCode ScrollCode, int &ScrollPos);$/;"	p	class:SHEdit::TSHEdit	access:private	signature:(TObject *Sender, TScrollCode ScrollCode, int &ScrollPos)
PARSEINADVANCE	config.h	28;"	d
PARSEINONEGO	config.h	29;"	d
POP_AUTO	uLanguageDefinition.h	68;"	d
POP_AUTO	uLanguageDefinitionWebLangs.h	20;"	d
PState	uLanguageDefinition2.h	/^        PState() : st(){};$/;"	f	struct:SHEdit::LanguageDefinition::PState	access:public	signature:()
PState	uLanguageDefinition2.h	/^      struct PState$/;"	s	class:SHEdit::LanguageDefinition	access:public
PUSH_ALWAYS	uLanguageDefinition.h	67;"	d
PUSH_ALWAYS	uLanguageDefinitionWebLangs.h	21;"	d
Paint	cSHEdit.cpp	/^void __fastcall TSHEdit::Paint()$/;"	f	class:TSHEdit	signature:()
Paint	cSHEdit.h	/^      virtual void __fastcall Paint();$/;"	p	class:SHEdit::TSHEdit	access:protected	signature:()
Paint	uDrawer.cpp	/^void __fastcall Drawer::Paint()$/;"	f	class:Drawer	signature:()
Paint	uDrawer.h	/^      void __fastcall Paint();$/;"	p	class:SHEdit::Drawer	access:private	signature:()
PaintWindow	cSHEdit.cpp	/^void __fastcall TSHEdit::PaintWindow(HDC DC)$/;"	f	class:TSHEdit	signature:(HDC DC)
PaintWindow	cSHEdit.h	/^      virtual void __fastcall PaintWindow(HDC DC);$/;"	p	class:SHEdit::TSHEdit	access:protected	signature:(HDC DC)
Parse	uLanguageDefinition2.cpp	/^void LanguageDefinition::Parse(IT& from, const IT& to, PState& s, bool& stylechanged, FontStyle*&fs)$/;"	f	class:LanguageDefinition	signature:(IT& from, const IT& to, PState& s, bool& stylechanged, FontStyle*&fs)
Parse	uLanguageDefinition2.h	/^      void Parse(IT& from, const IT& to, PState&, bool& stylechanged, FontStyle*&fs);$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(IT& from, const IT& to, PState&, bool& stylechanged, FontStyle*&fs)
ParseFromLine	uParser.cpp	/^void Parser::ParseFromLine(NSpan * line, int linenum, int prior)$/;"	f	class:Parser	signature:(NSpan * line, int linenum, int prior)
ParseFromLine	uParser.h	/^      void ParseFromLine(NSpan * line, int linenum, int prior);$/;"	p	class:SHEdit::Parser	access:public	signature:(NSpan * line, int linenum, int prior)
ParseFromToLine	uParser.cpp	/^void Parser::ParseFromToLine(NSpan * line, int linenum, int count, int prior)$/;"	f	class:Parser	signature:(NSpan * line, int linenum, int count, int prior)
ParseFromToLine	uParser.h	/^      void ParseFromToLine(NSpan * line, int linenum, int count, int prior);$/;"	p	class:SHEdit::Parser	access:public	signature:(NSpan * line, int linenum, int count, int prior)
ParseLine	uParser.cpp	/^void Parser::ParseLine(Iter * itr, LanguageDefinition::SearchIter * searchiter, bool paint)$/;"	f	class:Parser	signature:(Iter * itr, LanguageDefinition::SearchIter * searchiter, bool paint)
ParseLine	uParser.h	/^      void ParseLine(Iter * itr, LanguageDefinition::SearchIter * searchiter, bool paint);$/;"	p	class:SHEdit::Parser	access:private	signature:(Iter * itr, LanguageDefinition::SearchIter * searchiter, bool paint)
ParseScreenBetween	cSHEdit.cpp	/^void TSHEdit::ParseScreenBetween(Iter * it1, Iter * it2)$/;"	f	class:TSHEdit	signature:(Iter * it1, Iter * it2)
ParseScreenBetween	cSHEdit.h	/^      void ParseScreenBetween(Iter * it1, Iter * it2);                                               \/*!< Pushes visible lines between it1 and it2 to parser. Takes care of right order of iters, and of trimming the. *\/$/;"	p	class:SHEdit::TSHEdit	access:protected	signature:(Iter * it1, Iter * it2)
ParseString	uLanguageDefinition2.cpp	/^void LanguageDefinition::ParseString(std::wstring& rule, std::vector<Node*>& endnodes)$/;"	f	class:LanguageDefinition	signature:(std::wstring& rule, std::vector<Node*>& endnodes)
ParseString	uLanguageDefinition2.h	/^      void ParseString(std::wstring& rule, std::vector<Node*>& endnodes);$/;"	p	class:SHEdit::LanguageDefinition	access:private	signature:(std::wstring& rule, std::vector<Node*>& endnodes)
ParseTask	uParser.cpp	/^Parser::ParseTask::ParseTask()$/;"	f	class:Parser::ParseTask	signature:()
ParseTask	uParser.cpp	/^Parser::ParseTask::ParseTask(NSpan * l, int ln)$/;"	f	class:Parser::ParseTask	signature:(NSpan * l, int ln)
ParseTask	uParser.h	/^        ParseTask();$/;"	p	struct:SHEdit::Parser::ParseTask	access:public	signature:()
ParseTask	uParser.h	/^        ParseTask(NSpan * line, int linenum);$/;"	p	struct:SHEdit::Parser::ParseTask	access:public	signature:(NSpan * line, int linenum)
ParseTask	uParser.h	/^      struct ParseTask$/;"	s	class:SHEdit::Parser	access:public
Parser	uParser.cpp	/^__fastcall Parser::Parser(TSHEdit * parent, Drawer * drawer)$/;"	f	class:Parser	signature:(TSHEdit * parent, Drawer * drawer)
Parser	uParser.h	/^      __fastcall Parser(TSHEdit * parent, Drawer * drawer);$/;"	p	class:SHEdit::Parser	access:public	signature:(TSHEdit * parent, Drawer * drawer)
Parser	uParser.h	/^  class Parser$/;"	c	namespace:SHEdit
Parser::AddChar	uParser.cpp	/^void Parser::AddChar(Iter * itr, int & pos)$/;"	f	class:Parser	signature:(Iter * itr, int & pos)
Parser::CanGoFurther	uParser.cpp	/^bool Parser::CanGoFurther(LanguageDefinition::SearchIter sit, Iter * itr, bool inword, bool checkbefore, bool recursive)$/;"	f	class:Parser	signature:(LanguageDefinition::SearchIter sit, Iter * itr, bool inword, bool checkbefore, bool recursive)
Parser::CheckMarkup	uParser.cpp	/^void Parser::CheckMarkup(Iter * itr, bool paint)$/;"	f	class:Parser	signature:(Iter * itr, bool paint)
Parser::Draw	uParser.cpp	/^void __fastcall Parser::Draw()$/;"	f	class:Parser	signature:()
Parser::DumpStackState	uParser.cpp	/^void Parser::DumpStackState()$/;"	f	class:Parser	signature:()
Parser::Execute	uParser.cpp	/^bool __fastcall Parser::Execute(bool paint)$/;"	f	class:Parser	signature:(bool paint)
Parser::Flush	uParser.cpp	/^void Parser::Flush()$/;"	f	class:Parser	signature:()
Parser::FlushAll	uParser.cpp	/^void Parser::FlushAll()$/;"	f	class:Parser	signature:()
Parser::GetLangDef	uParser.cpp	/^LanguageDefinition * Parser::GetLangDef()$/;"	f	class:Parser	signature:()
Parser::InvalidateAll	uParser.cpp	/^void Parser::InvalidateAll()$/;"	f	class:Parser	signature:()
Parser::OnIdle	uParser.cpp	/^void __fastcall Parser::OnIdle(TObject * Sender, bool & Done)$/;"	f	class:Parser	signature:(TObject * Sender, bool & Done)
Parser::ParseFromLine	uParser.cpp	/^void Parser::ParseFromLine(NSpan * line, int linenum, int prior)$/;"	f	class:Parser	signature:(NSpan * line, int linenum, int prior)
Parser::ParseFromToLine	uParser.cpp	/^void Parser::ParseFromToLine(NSpan * line, int linenum, int count, int prior)$/;"	f	class:Parser	signature:(NSpan * line, int linenum, int count, int prior)
Parser::ParseLine	uParser.cpp	/^void Parser::ParseLine(Iter * itr, LanguageDefinition::SearchIter * searchiter, bool paint)$/;"	f	class:Parser	signature:(Iter * itr, LanguageDefinition::SearchIter * searchiter, bool paint)
Parser::ParseTask::ParseTask	uParser.cpp	/^Parser::ParseTask::ParseTask()$/;"	f	class:Parser::ParseTask	signature:()
Parser::ParseTask::ParseTask	uParser.cpp	/^Parser::ParseTask::ParseTask(NSpan * l, int ln)$/;"	f	class:Parser::ParseTask	signature:(NSpan * l, int ln)
Parser::ParseTask::operator <	uParser.cpp	/^bool Parser::ParseTask::operator<(const Parser::ParseTask & pt)  const$/;"	f	class:Parser::ParseTask	signature:(const Parser::ParseTask & pt) const
Parser::ParseTask::operator ==	uParser.cpp	/^bool Parser::ParseTask::operator==(const Parser::ParseTask & pt) const$/;"	f	class:Parser::ParseTask	signature:(const Parser::ParseTask & pt) const
Parser::Parser	uParser.cpp	/^__fastcall Parser::Parser(TSHEdit * parent, Drawer * drawer)$/;"	f	class:Parser	signature:(TSHEdit * parent, Drawer * drawer)
Parser::ParserState::InitBanks	uParser.cpp	/^void Parser::ParserState::InitBanks(int count)$/;"	f	class:Parser::ParserState	signature:(int count)
Parser::ParserState::ParserState	uParser.cpp	/^  Parser::ParserState::ParserState()$/;"	f	class:Parser::ParserState	signature:()
Parser::ParserState::operator !=	uParser.cpp	/^bool Parser::ParserState::operator!=(const ParserState& state)$/;"	f	class:Parser::ParserState	signature:(const ParserState& state)
Parser::ParserState::operator =	uParser.cpp	/^SHEdit::Parser::ParserState& Parser::ParserState::operator=(const SHEdit::Parser::ParserState& p)$/;"	f	class:Parser::ParserState	signature:(const SHEdit::Parser::ParserState& p)
Parser::ParserState::operator ==	uParser.cpp	/^bool Parser::ParserState::operator==(const ParserState& state)$/;"	f	class:Parser::ParserState	signature:(const ParserState& state)
Parser::ParserState::~ParserState	uParser.cpp	/^Parser::ParserState::~ParserState()$/;"	f	class:Parser::ParserState	signature:()
Parser::PerformJumpPush	uParser.cpp	/^void Parser::PerformJumpPush(LanguageDefinition::SearchIter *& sit)$/;"	f	class:Parser	signature:(LanguageDefinition::SearchIter *& sit)
Parser::PerformPop	uParser.cpp	/^bool Parser::PerformPop(LanguageDefinition::SearchIter *& sit)$/;"	f	class:Parser	signature:(LanguageDefinition::SearchIter *& sit)
Parser::ReconstructMarkup	uParser.cpp	/^void Parser::ReconstructMarkup()$/;"	f	class:Parser	signature:()
Parser::SendEof	uParser.cpp	/^void Parser::SendEof()$/;"	f	class:Parser	signature:()
Parser::SetLangDef	uParser.cpp	/^void Parser::SetLangDef(LanguageDefinition * langdef)$/;"	f	class:Parser	signature:(LanguageDefinition * langdef)
Parser::Write	uParser.cpp	/^void Parser::Write(AnsiString message)$/;"	f	class:Parser	signature:(AnsiString message)
Parser::~Parser	uParser.cpp	/^__fastcall Parser::~Parser()$/;"	f	class:Parser	signature:()
ParserState	uParser.cpp	/^  Parser::ParserState::ParserState()$/;"	f	class:Parser::ParserState	signature:()
ParserState	uParser.h	/^        ParserState();$/;"	p	struct:SHEdit::Parser::ParserState	access:public	signature:()
ParserState	uParser.h	/^      struct ParserState$/;"	s	class:SHEdit::Parser	access:public
Paste	cSHEdit.cpp	/^void TSHEdit::Paste()$/;"	f	class:TSHEdit	signature:()
Paste	cSHEdit.h	/^      void Paste();$/;"	p	class:SHEdit::TSHEdit	access:public	signature:()
PerformJumpPush	uParser.cpp	/^void Parser::PerformJumpPush(LanguageDefinition::SearchIter *& sit)$/;"	f	class:Parser	signature:(LanguageDefinition::SearchIter *& sit)
PerformJumpPush	uParser.h	/^      void PerformJumpPush(LanguageDefinition::SearchIter *& sit);$/;"	p	class:SHEdit::Parser	access:private	signature:(LanguageDefinition::SearchIter *& sit)
PerformPop	uParser.cpp	/^bool Parser::PerformPop(LanguageDefinition::SearchIter *& sit)$/;"	f	class:Parser	signature:(LanguageDefinition::SearchIter *& sit)
PerformPop	uParser.h	/^      bool PerformPop(LanguageDefinition::SearchIter *& sit);$/;"	p	class:SHEdit::Parser	access:private	signature:(LanguageDefinition::SearchIter *& sit)
Pop	uLanguageDefinition.cpp	/^  LanguageDefinition::Pop::Pop()$/;"	f	class:LanguageDefinition::Pop	signature:()
Pop	uLanguageDefinition.cpp	/^  LanguageDefinition::Pop::Pop(short _popmask, short _newgmask, short _popcount, FontStyle * _format)$/;"	f	class:LanguageDefinition::Pop	signature:(short _popmask, short _newgmask, short _popcount, FontStyle * _format)
Pop	uLanguageDefinition.h	/^        Pop();$/;"	p	struct:SHEdit::LanguageDefinition::Pop	access:public	signature:()
Pop	uLanguageDefinition.h	/^        Pop(short _popmask, short _newgmask, short _popcount, FontStyle * format);$/;"	p	struct:SHEdit::LanguageDefinition::Pop	access:public	signature:(short _popmask, short _newgmask, short _popcount, FontStyle * format)
Pop	uLanguageDefinition.h	/^      struct Pop$/;"	s	class:SHEdit::LanguageDefinition	access:private
Pop	uStack.h	/^    void Pop();$/;"	p	class:Stack	access:public	signature:()
Pop	uStack.h	/^void Stack<T_data>::Pop()$/;"	f	class:Stack	signature:()
PositionDescription	cSHEdit.cpp	/^String TSHEdit::PositionDescription()$/;"	f	class:TSHEdit	signature:()
PositionDescription	cSHEdit.h	/^      String PositionDescription();$/;"	p	class:SHEdit::TSHEdit	access:public	signature:()
ProcessChange	cSHEdit.cpp	/^void TSHEdit::ProcessChange(int linesMovedFrom, int linesMoved, NSpan * changed)$/;"	f	class:TSHEdit	signature:(int linesMovedFrom, int linesMoved, NSpan * changed)
ProcessChange	cSHEdit.h	/^      void ProcessChange(int linesMovedFrom, int linesMoved, NSpan * changed);                       \/*!< Handles painting of most actions that need just partial movement of some data - line insertions and deletions, scrolling, etc.*\/$/;"	p	class:SHEdit::TSHEdit	access:protected	signature:(int linesMovedFrom, int linesMoved, NSpan * changed)
ProcessKey	cSHEdit.cpp	/^LRESULT CALLBACK TSHEdit::ProcessKey(int code, WPARAM wParam, LPARAM lParam)$/;"	f	class:TSHEdit	signature:(int code, WPARAM wParam, LPARAM lParam)
ProcessKey	cSHEdit.h	/^      virtual LRESULT CALLBACK ProcessKey(int code, WPARAM wParam, LPARAM lParam);                   \/*!< intercepts key messages that would not be otherwise handed to the component.*\/$/;"	p	class:SHEdit::TSHEdit	access:public	signature:(int code, WPARAM wParam, LPARAM lParam)
ProcessKeyCall	cSHEdit.cpp	/^LRESULT CALLBACK SHEdit::ProcessKeyCall(int code, WPARAM wParam, LPARAM lParam)$/;"	f	class:SHEdit	signature:(int code, WPARAM wParam, LPARAM lParam)
ProcessKeyCall	cSHEdit.h	/^  LRESULT CALLBACK ProcessKeyCall(int code, WPARAM wParam, LPARAM lParam);$/;"	p	namespace:SHEdit	signature:(int code, WPARAM wParam, LPARAM lParam)
ProcessMouseClear	cSHEdit.cpp	/^void TSHEdit::ProcessMouseClear(bool redraw, bool deleteiter, bool execredraw)$/;"	f	class:TSHEdit	signature:(bool redraw, bool deleteiter, bool execredraw)
ProcessMouseClear	cSHEdit.h	/^      void ProcessMouseClear(bool redraw, bool deletecursord, bool execredraw = true);               \/*!< clears selection *\/$/;"	p	class:SHEdit::TSHEdit	access:private	signature:(bool redraw, bool deletecursord, bool execredraw = true)
ProcessMouseMove	cSHEdit.cpp	/^void TSHEdit::ProcessMouseMove(int &x, int &y)$/;"	f	class:TSHEdit	signature:(int &x, int &y)
ProcessMouseMove	cSHEdit.h	/^      void ProcessMouseMove(int& x, int& y);                                                         \/*!< processes mouse drag info (called from mouse move and mouse up handlers). *\/$/;"	p	class:SHEdit::TSHEdit	access:private	signature:(int& x, int& y)
ProcessNewSelection	cSHEdit.cpp	/^void TSHEdit::ProcessNewSelection(bool execredraw, bool draw)$/;"	f	class:TSHEdit	signature:(bool execredraw, bool draw)
ProcessNewSelection	cSHEdit.h	/^      void ProcessNewSelection(bool execdraw = true, bool draw = true);$/;"	p	class:SHEdit::TSHEdit	access:protected	signature:(bool execdraw = true, bool draw = true)
PurgeStack	uBuffer.cpp	/^void Buffer::PurgeStack(std::stack<UndoTask*>& stack)$/;"	f	class:Buffer	signature:(std::stack<UndoTask*>& stack)
PurgeStack	uBuffer.h	/^      void PurgeStack(std::stack<UndoTask*>& stack);$/;"	p	class:SHEdit::Buffer	access:private	signature:(std::stack<UndoTask*>& stack)
Push	uStack.h	/^    Node* Push(const T_data& d);$/;"	p	class:Stack	access:public	signature:(const T_data& d)
Push	uStack.h	/^typename Stack<T_data>::Node* Stack<T_data>::Push(const T_data& d)$/;"	f	class:Stack	signature:(const T_data& d)
QueueDump	uDrawer.h	/^      void QueueDump();$/;"	p	class:SHEdit::Drawer	access:private	signature:()
Range	uSpan.cpp	/^Range::Range(Span * first, Span * last, bool empty, NSpan * firstLine, NSpan * lastLine, bool lineempty, int linecount)$/;"	f	class:Range	signature:(Span * first, Span * last, bool empty, NSpan * firstLine, NSpan * lastLine, bool lineempty, int linecount)
Range	uSpan.h	/^    Range(Span * first, Span * last, bool empty, NSpan * firstLine, NSpan * lastLine, bool lineempty, int linecount);$/;"	p	struct:SHEdit::Range	access:public	signature:(Span * first, Span * last, bool empty, NSpan * firstLine, NSpan * lastLine, bool lineempty, int linecount)
Range	uSpan.h	/^  struct Range$/;"	s	namespace:SHEdit
Range::Free	uSpan.cpp	/^void Range::Free()$/;"	f	class:Range	signature:()
Range::Range	uSpan.cpp	/^Range::Range(Span * first, Span * last, bool empty, NSpan * firstLine, NSpan * lastLine, bool lineempty, int linecount)$/;"	f	class:Range	signature:(Span * first, Span * last, bool empty, NSpan * firstLine, NSpan * lastLine, bool lineempty, int linecount)
Range::~Range	uSpan.cpp	/^Range::~Range()$/;"	f	class:Range	signature:()
ReadOnly	cSHEdit.h	/^      __property bool ReadOnly= {read=readonly,write=readonly, default=false};$/;"	m	class:SHEdit::TSHEdit	access:public
Rec	uLanguageDefinition2.h	/^        Rec() : t(NULL), nt(NULL), term(false){};$/;"	f	struct:SHEdit::LanguageDefinition::Rec	access:public	signature:()
Rec	uLanguageDefinition2.h	/^        Rec(NTerm* t_) : nt(t_), t(NULL), term(false){};$/;"	f	struct:SHEdit::LanguageDefinition::Rec	access:public	signature:(NTerm* t_)
Rec	uLanguageDefinition2.h	/^        Rec(Term* t_) : t(t_), nt(NULL), term(true){};$/;"	f	struct:SHEdit::LanguageDefinition::Rec	access:public	signature:(Term* t_)
Rec	uLanguageDefinition2.h	/^      struct Rec$/;"	s	class:SHEdit::LanguageDefinition	access:private
RecalcPos	uIPos.cpp	/^void IPos::RecalcPos()$/;"	f	class:IPos	signature:()
RecalcPos	uIPos.h	/^      virtual void RecalcPos();                                                                      \/*!< Recalculates IPos::pos, according to descendant's own positioning *\/$/;"	p	class:SHEdit::IPos	access:public	signature:()
RecalcPos	uIter.cpp	/^void Iter::RecalcPos()$/;"	f	class:Iter	signature:()
RecalcPos	uIter.h	/^      virtual void RecalcPos();                                                                      \/*!< Recalculates IPos::pos, according to descendant's own positioning *\/$/;"	p	class:SHEdit::Iter	access:protected	signature:()
ReconstructIMarkFontStyle	uIPos.cpp	/^FontStyle IPos::ReconstructIMarkFontStyle()$/;"	f	class:IPos	signature:()
ReconstructIMarkFontStyle	uIPos.h	/^      FontStyle ReconstructIMarkFontStyle();                                                         \/*!< Returns current FontStyle determined by Iterator handled markup. For formatting overview see \\ref index . For more specific info see IMark class *\/$/;"	p	class:SHEdit::IPos	access:public	signature:()
ReconstructMarkup	uParser.cpp	/^void Parser::ReconstructMarkup()$/;"	f	class:Parser	signature:()
ReconstructMarkup	uParser.h	/^      void ReconstructMarkup();                                                                      \/*!< Reconstructs ActMarkup (that holds positionless markup). Does not update actMarkupCombined. *\/$/;"	p	class:SHEdit::Parser	access:private	signature:()
Redo	uBuffer.cpp	/^Iter * Buffer::Redo(Iter *& begin)$/;"	f	class:Buffer	signature:(Iter *& begin)
Redo	uBuffer.h	/^      Iter * Redo(Iter *& begin);$/;"	p	class:SHEdit::Buffer	access:public	signature:(Iter *& begin)
Register	cSHEdit.cpp	/^  void __fastcall PACKAGE Register()$/;"	f	namespace:Cshedit	signature:()
RegisterF	uBuffer.cpp	/^void Buffer::RegisterF(SHEdit::Format * f)$/;"	f	class:Buffer	signature:(SHEdit::Format * f)
RegisterF	uBuffer.h	/^      void RegisterF(Format * form);$/;"	p	class:SHEdit::Buffer	access:public	signature:(Format * form)
RegisterIM	uBuffer.cpp	/^void Buffer::RegisterIM(IMark * itr)$/;"	f	class:Buffer	signature:(IMark * itr)
RegisterIM	uBuffer.h	/^      void RegisterIM(IMark * itr);$/;"	p	class:SHEdit::Buffer	access:public	signature:(IMark * itr)
RegisterIP	uBuffer.cpp	/^void Buffer::RegisterIP(IPos * itr)$/;"	f	class:Buffer	signature:(IPos * itr)
RegisterIP	uBuffer.h	/^      void RegisterIP(IPos * itr);$/;"	p	class:SHEdit::Buffer	access:public	signature:(IPos * itr)
Remove	uFormat.cpp	/^void Format::Remove( Stack<SHEdit::Mark>::Node* mark)$/;"	f	class:Format	signature:( Stack<SHEdit::Mark>::Node* mark)
Remove	uFormat.h	/^      void Remove(Stack<Mark>::Node * mark);$/;"	p	class:SHEdit::Format	access:public	signature:(Stack<Mark>::Node * mark)
Remove	uStack.h	/^      Node* Remove();                                                                                \/*!< Returns pointer to the next node, for easier removal of elements while iterating through. Any item of Stack can be removed directly from outside of stack by this. Removed node is directly deleted. *\/$/;"	p	struct:Stack::Node	access:public	signature:()
Remove	uStack.h	/^    void Remove(T_data d);$/;"	p	class:Stack	access:public	signature:(T_data d)
Remove	uStack.h	/^typename Stack<T_data>::Node* Stack<T_data>::Node::Remove()$/;"	f	class:Stack::Node	signature:()
Remove	uStack.h	/^void Stack<T_data>::Remove(T_data d)$/;"	f	class:Stack	signature:(T_data d)
RemoveAllMarks	uFormat.cpp	/^void Format::RemoveAllMarks()$/;"	f	class:Format	signature:()
RemoveAllMarks	uFormat.h	/^      void RemoveAllMarks();$/;"	p	class:SHEdit::Format	access:public	signature:()
RemoveIM	uFormat.cpp	/^void Format::RemoveIM( IMark * mark)$/;"	f	class:Format	signature:( IMark * mark)
RemoveIM	uFormat.h	/^      void RemoveIM(IMark * mark);$/;"	p	class:SHEdit::Format	access:public	signature:(IMark * mark)
RepaintWindow	cSHEdit.cpp	/^void __fastcall TSHEdit::RepaintWindow(bool force)$/;"	f	class:TSHEdit	signature:(bool force)
RepaintWindow	cSHEdit.h	/^      virtual void __fastcall RepaintWindow(bool force = true);$/;"	p	class:SHEdit::TSHEdit	access:public	signature:(bool force = true)
RevChar	uCursor.cpp	/^      \/*AUTOGENERATED*\/ bool  CIter::RevChar ()  { Init(); bool  tmp =  this->itr.RevChar (); Update();  return  tmp;}  $/;"	f	class:CIter	signature:()
RevChar	uCursor.h	/^      \/*AUTOGENERATED*\/ bool  CIter::RevChar ()  ; $/;"	p	class:SHEdit::CIter::CIter	access:public	signature:()
RevChar	uIter.cpp	/^bool Iter::RevChar()$/;"	f	class:Iter	signature:()
RevChar	uIter.h	/^      bool RevChar()\/*AUTOGEN_UPDATE*\/;$/;"	p	class:SHEdit::Iter	access:public	signature:()
RevLine	uCursor.cpp	/^      \/*AUTOGENERATED*\/ bool  CIter::RevLine ()  { Init(); bool  tmp =  this->itr.RevLine (); Update();  return  tmp;}  $/;"	f	class:CIter	signature:()
RevLine	uCursor.h	/^      \/*AUTOGENERATED*\/ bool  CIter::RevLine ()  ; $/;"	p	class:SHEdit::CIter::CIter	access:public	signature:()
RevLine	uIter.cpp	/^bool Iter::RevLine()$/;"	f	class:Iter	signature:()
RevLine	uIter.h	/^      bool RevLine()\/*AUTOGEN_UPDATE*\/;$/;"	p	class:SHEdit::Iter	access:public	signature:()
RevLineBegin	uCursor.cpp	/^      \/*AUTOGENERATED*\/ bool  CIter::RevLineBegin ()  { Init(); bool  tmp =  this->itr.RevLineBegin (); Update();  return  tmp;}  $/;"	f	class:CIter	signature:()
RevLineBegin	uCursor.h	/^      \/*AUTOGENERATED*\/ bool  CIter::RevLineBegin ()  ; $/;"	p	class:SHEdit::CIter::CIter	access:public	signature:()
RevLineBegin	uIter.h	/^      bool RevLineBegin()\/*AUTOGEN_UPDATE*\/;$/;"	p	class:SHEdit::Iter	access:public	signature:()
RevWord	uIter.cpp	/^bool Iter::RevWord()$/;"	f	class:Iter	signature:()
RevWord	uIter.h	/^      bool RevWord();$/;"	p	class:SHEdit::Iter	access:protected	signature:()
RevWordBegin	uIter.h	/^      bool RevWordBegin();$/;"	p	class:SHEdit::Iter	access:protected	signature:()
RevWordLiteral	uCursor.cpp	/^      \/*AUTOGENERATED*\/ void  CIter::RevWordLiteral ()  { Init();  this->itr.RevWordLiteral (); Update();  } \/*!< goes to previous start of a word (alnum + underscore) *\/$/;"	f	class:CIter	signature:()
RevWordLiteral	uCursor.h	/^      \/*AUTOGENERATED*\/ void  CIter::RevWordLiteral ()  ;                                            \/*!< goes to previous start of a word (alnum + underscore) *\/$/;"	p	class:SHEdit::CIter::CIter	access:public	signature:()
RevWordLiteral	uIter.cpp	/^void Iter::RevWordLiteral()$/;"	f	class:Iter	signature:()
RevWordLiteral	uIter.h	/^      void RevWordLiteral()\/*AUTOGEN_UPDATE*\/;                                                       \/*!< goes to previous start of a word (alnum + underscore) *\/$/;"	p	class:SHEdit::Iter	access:public	signature:()
RightBorder	uDrawer.cpp	/^int Drawer::RightBorder()$/;"	f	class:Drawer	signature:()
RightBorder	uDrawer.h	/^      inline int RightBorder();$/;"	p	class:SHEdit::Drawer	access:private	signature:()
SHEdit	cSHEdit.h	/^namespace SHEdit$/;"	n
SHEdit	uBuffer.h	/^namespace SHEdit$/;"	n
SHEdit	uCursor.h	/^namespace SHEdit$/;"	n
SHEdit	uDrawer.h	/^namespace SHEdit$/;"	n
SHEdit	uFormat.h	/^namespace SHEdit$/;"	n
SHEdit	uIPos.h	/^namespace SHEdit$/;"	n
SHEdit	uIter.h	/^namespace SHEdit$/;"	n
SHEdit	uLanguageDefinition.h	/^namespace SHEdit$/;"	n
SHEdit	uLanguageDefinition2.h	/^namespace SHEdit$/;"	n
SHEdit	uLanguageDefinitionSQL.h	/^namespace SHEdit$/;"	n
SHEdit	uLanguageDefinitionWebLangs.h	/^namespace SHEdit$/;"	n
SHEdit	uMark.h	/^namespace SHEdit$/;"	n
SHEdit	uParser.h	/^namespace SHEdit$/;"	n
SHEdit	uSpan.h	/^namespace SHEdit$/;"	n
SHEdit::Action	uSpan.h	/^  struct Action$/;"	s	namespace:SHEdit
SHEdit::Action::Action	uSpan.h	/^    Action(int fromlinenum, int tolinenum, int frompos, int topos, ActionType type);$/;"	p	struct:SHEdit::Action	access:public	signature:(int fromlinenum, int tolinenum, int frompos, int topos, ActionType type)
SHEdit::Action::ActionType	uSpan.h	/^    enum ActionType{deletion, insertion};$/;"	g	struct:SHEdit::Action	access:public
SHEdit::Action::deletion	uSpan.h	/^    enum ActionType{deletion, insertion};$/;"	e	enum:SHEdit::Action::ActionType
SHEdit::Action::fromlinenum	uSpan.h	/^    int fromlinenum;$/;"	m	struct:SHEdit::Action	access:public
SHEdit::Action::frompos	uSpan.h	/^    int frompos;$/;"	m	struct:SHEdit::Action	access:public
SHEdit::Action::insertion	uSpan.h	/^    enum ActionType{deletion, insertion};$/;"	e	enum:SHEdit::Action::ActionType
SHEdit::Action::tolinenum	uSpan.h	/^    int tolinenum;$/;"	m	struct:SHEdit::Action	access:public
SHEdit::Action::topos	uSpan.h	/^    int topos;$/;"	m	struct:SHEdit::Action	access:public
SHEdit::Action::type	uSpan.h	/^    ActionType type;$/;"	m	struct:SHEdit::Action	access:public
SHEdit::Action::~Action	uSpan.h	/^    ~Action();$/;"	p	struct:SHEdit::Action	access:public	signature:()
SHEdit::Buffer	uBuffer.h	/^  class Buffer$/;"	c	namespace:SHEdit
SHEdit::Buffer::Begin	uBuffer.h	/^      Iter * Begin();$/;"	p	class:SHEdit::Buffer	access:public	signature:()
SHEdit::Buffer::Buffer	uBuffer.h	/^      Buffer();$/;"	p	class:SHEdit::Buffer	access:public	signature:()
SHEdit::Buffer::CheckIntegrity	uBuffer.h	/^      int CheckIntegrity(int& emptyCount);$/;"	p	class:SHEdit::Buffer	access:public	signature:(int& emptyCount)
SHEdit::Buffer::Delete	uBuffer.h	/^      int Delete(Iter * From, Iter * To);$/;"	p	class:SHEdit::Buffer	access:public	signature:(Iter * From, Iter * To)
SHEdit::Buffer::End	uBuffer.h	/^      Iter * End();$/;"	p	class:SHEdit::Buffer	access:public	signature:()
SHEdit::Buffer::First	uBuffer.h	/^      Iter * First();$/;"	p	class:SHEdit::Buffer	access:public	signature:()
SHEdit::Buffer::FirstLine	uBuffer.h	/^      NSpan * FirstLine();$/;"	p	class:SHEdit::Buffer	access:public	signature:()
SHEdit::Buffer::FormatList	uBuffer.h	/^      std::set<Format*> FormatList;$/;"	m	class:SHEdit::Buffer	access:private
SHEdit::Buffer::GetItrCount	uBuffer.h	/^      int GetItrCount();$/;"	p	class:SHEdit::Buffer	access:public	signature:()
SHEdit::Buffer::GetLine	uBuffer.h	/^      String GetLine(Iter * line, bool replaceTabs);$/;"	p	class:SHEdit::Buffer	access:public	signature:(Iter * line, bool replaceTabs)
SHEdit::Buffer::GetLineCount	uBuffer.h	/^      int GetLineCount();$/;"	p	class:SHEdit::Buffer	access:public	signature:()
SHEdit::Buffer::GetLineTo	uBuffer.h	/^      String GetLineTo(Iter * To, bool replaceTabs);$/;"	p	class:SHEdit::Buffer	access:public	signature:(Iter * To, bool replaceTabs)
SHEdit::Buffer::GetText	uBuffer.h	/^      wchar_t* GetText(Iter * From, Iter * To, bool addCariageReturns = false);$/;"	p	class:SHEdit::Buffer	access:public	signature:(Iter * From, Iter * To, bool addCariageReturns = false)
SHEdit::Buffer::HistoryOnOff	uBuffer.h	/^      void HistoryOnOff();        \/\/purges stacks if the keepHistory flag is off; to be placed before returns in insert\/delete$/;"	p	class:SHEdit::Buffer	access:private	signature:()
SHEdit::Buffer::IMarkList	uBuffer.h	/^      std::set<IPos*, IPos::compare> IMarkList;$/;"	m	class:SHEdit::Buffer	access:private
SHEdit::Buffer::Insert	uBuffer.h	/^      int Insert(Iter * At, const wchar_t * string);$/;"	p	class:SHEdit::Buffer	access:public	signature:(Iter * At, const wchar_t * string)
SHEdit::Buffer::IsPlainWord	uBuffer.h	/^      bool IsPlainWord(const wchar_t * string);$/;"	p	class:SHEdit::Buffer	access:public	signature:(const wchar_t * string)
SHEdit::Buffer::ItersTranslateDelete	uBuffer.h	/^      void ItersTranslateDelete(int fromlinenum, int frompos, int tolinenum, int topos, NSpan * toline);$/;"	p	class:SHEdit::Buffer	access:private	signature:(int fromlinenum, int frompos, int tolinenum, int topos, NSpan * toline)
SHEdit::Buffer::ItersTranslateInsert	uBuffer.h	/^      void ItersTranslateInsert(int linenum, int pos, int bylines, int topos, NSpan * toline);$/;"	p	class:SHEdit::Buffer	access:private	signature:(int linenum, int pos, int bylines, int topos, NSpan * toline)
SHEdit::Buffer::ItrList	uBuffer.h	/^      std::list<IPos*> ItrList;$/;"	m	class:SHEdit::Buffer	access:private
SHEdit::Buffer::PurgeStack	uBuffer.h	/^      void PurgeStack(std::stack<UndoTask*>& stack);$/;"	p	class:SHEdit::Buffer	access:private	signature:(std::stack<UndoTask*>& stack)
SHEdit::Buffer::Redo	uBuffer.h	/^      Iter * Redo(Iter *& begin);$/;"	p	class:SHEdit::Buffer	access:public	signature:(Iter *& begin)
SHEdit::Buffer::RegisterF	uBuffer.h	/^      void RegisterF(Format * form);$/;"	p	class:SHEdit::Buffer	access:public	signature:(Format * form)
SHEdit::Buffer::RegisterIM	uBuffer.h	/^      void RegisterIM(IMark * itr);$/;"	p	class:SHEdit::Buffer	access:public	signature:(IMark * itr)
SHEdit::Buffer::RegisterIP	uBuffer.h	/^      void RegisterIP(IPos * itr);$/;"	p	class:SHEdit::Buffer	access:public	signature:(IPos * itr)
SHEdit::Buffer::SimpleLoadFile	uBuffer.h	/^      void SimpleLoadFile(const wchar_t * filename);$/;"	p	class:SHEdit::Buffer	access:public	signature:(const wchar_t * filename)
SHEdit::Buffer::SimpleSaveFile	uBuffer.h	/^      void SimpleSaveFile(const wchar_t * filename);$/;"	p	class:SHEdit::Buffer	access:public	signature:(const wchar_t * filename)
SHEdit::Buffer::Undo	uBuffer.h	/^      Iter * Undo(Iter *& begin);$/;"	p	class:SHEdit::Buffer	access:public	signature:(Iter *& begin)
SHEdit::Buffer::UndoPush	uBuffer.h	/^      void UndoPush(UndoTask * event);$/;"	p	class:SHEdit::Buffer	access:private	signature:(UndoTask * event)
SHEdit::Buffer::UndoRedo	uBuffer.h	/^      Iter * UndoRedo(std::stack<UndoTask*> * stackUndo, std::stack<UndoTask*> * stackRedo, Iter *& begin);$/;"	p	class:SHEdit::Buffer	access:private	signature:(std::stack<UndoTask*> * stackUndo, std::stack<UndoTask*> * stackRedo, Iter *& begin)
SHEdit::Buffer::UnregisterF	uBuffer.h	/^      void UnregisterF(Format * form);$/;"	p	class:SHEdit::Buffer	access:public	signature:(Format * form)
SHEdit::Buffer::UnregisterIM	uBuffer.h	/^      void UnregisterIM(IMark * itr);$/;"	p	class:SHEdit::Buffer	access:public	signature:(IMark * itr)
SHEdit::Buffer::UnregisterIP	uBuffer.h	/^      void UnregisterIP(IPos * itr);$/;"	p	class:SHEdit::Buffer	access:public	signature:(IPos * itr)
SHEdit::Buffer::Write	uBuffer.h	/^      void Write(AnsiString message);$/;"	p	class:SHEdit::Buffer	access:private	signature:(AnsiString message)
SHEdit::Buffer::_Delete	uBuffer.h	/^      void _Delete(NSpan * word);$/;"	p	class:SHEdit::Buffer	access:private	signature:(NSpan * word)
SHEdit::Buffer::_Delete	uBuffer.h	/^      void _Delete(Span * word);$/;"	p	class:SHEdit::Buffer	access:private	signature:(Span * word)
SHEdit::Buffer::_DeleteAt	uBuffer.h	/^      Range * _DeleteAt(Iter * From, Iter * To, bool writeundo, bool forcenew);$/;"	p	class:SHEdit::Buffer	access:private	signature:(Iter * From, Iter * To, bool writeundo, bool forcenew)
SHEdit::Buffer::_Insert	uBuffer.h	/^      void _Insert(NSpan * word);$/;"	p	class:SHEdit::Buffer	access:private	signature:(NSpan * word)
SHEdit::Buffer::_Insert	uBuffer.h	/^      void _Insert(Span * word);$/;"	p	class:SHEdit::Buffer	access:private	signature:(Span * word)
SHEdit::Buffer::_InsertAt	uBuffer.h	/^      Range * _InsertAt(NSpan * line, Span * word, int pos, const wchar_t * string, bool writeundo, bool forcenew);$/;"	p	class:SHEdit::Buffer	access:private	signature:(NSpan * line, Span * word, int pos, const wchar_t * string, bool writeundo, bool forcenew)
SHEdit::Buffer::_ParseWord	uBuffer.h	/^      wchar_t * _ParseWord(const wchar_t *& ptr, const wchar_t * ptrend);$/;"	p	class:SHEdit::Buffer	access:private	signature:(const wchar_t *& ptr, const wchar_t * ptrend)
SHEdit::Buffer::_SplitAt	uBuffer.h	/^      Span* _SplitAt(Iter * At);$/;"	p	class:SHEdit::Buffer	access:private	signature:(Iter * At)
SHEdit::Buffer::_SplitBegin	uBuffer.h	/^      Span* _SplitBegin(Iter * At);$/;"	p	class:SHEdit::Buffer	access:private	signature:(Iter * At)
SHEdit::Buffer::_SplitEnd	uBuffer.h	/^      Span* _SplitEnd(Iter * At);$/;"	p	class:SHEdit::Buffer	access:private	signature:(Iter * At)
SHEdit::Buffer::begin	uBuffer.h	/^      Iter begin();$/;"	p	class:SHEdit::Buffer	access:public	signature:()
SHEdit::Buffer::data	uBuffer.h	/^      Range* data;$/;"	m	class:SHEdit::Buffer	access:private
SHEdit::Buffer::end	uBuffer.h	/^      Iter end();$/;"	p	class:SHEdit::Buffer	access:public	signature:()
SHEdit::Buffer::first	uBuffer.h	/^      Iter first();$/;"	p	class:SHEdit::Buffer	access:public	signature:()
SHEdit::Buffer::keepHistory	uBuffer.h	/^      bool keepHistory;$/;"	m	class:SHEdit::Buffer	access:public
SHEdit::Buffer::markupMask	uBuffer.h	/^      short markupMask;$/;"	m	class:SHEdit::Buffer	access:private
SHEdit::Buffer::preload	uBuffer.h	/^      Range* preload;$/;"	m	class:SHEdit::Buffer	access:private
SHEdit::Buffer::preloadFile	uBuffer.h	/^      std::ifstream * preloadFile;$/;"	m	class:SHEdit::Buffer	access:private
SHEdit::Buffer::stackRedo	uBuffer.h	/^      std::stack<UndoTask*> stackRedo;$/;"	m	class:SHEdit::Buffer	access:private
SHEdit::Buffer::stackUndo	uBuffer.h	/^      std::stack<UndoTask*> stackUndo;$/;"	m	class:SHEdit::Buffer	access:private
SHEdit::Buffer::wordBeingEdited	uBuffer.h	/^      Span * wordBeingEdited;$/;"	m	class:SHEdit::Buffer	access:private
SHEdit::Buffer::~Buffer	uBuffer.h	/^      ~Buffer();$/;"	p	class:SHEdit::Buffer	access:public	signature:()
SHEdit::CIter	uCursor.h	/^    class CIter$/;"	c	namespace:SHEdit
SHEdit::CIter::CIter	uCursor.h	/^               CIter(const CIter& c);$/;"	p	class:SHEdit::CIter	access:public	signature:(const CIter& c)
SHEdit::CIter::CIter	uCursor.h	/^             CIter(TSHEdit * component, const Iter& itr, short type, bool myown); \/\/to be called only by the component$/;"	p	class:SHEdit::CIter	access:private	signature:(TSHEdit * component, const Iter& itr, short type, bool myown)
SHEdit::CIter::CIter::FindNext	uCursor.h	/^      \/*AUTOGENERATED*\/ bool  CIter::FindNext (wchar_t * string, bool skip = true, bool caseSensitive = true, bool wholeword = false)  ; \/*!< skip defines whether to match word directly at cursor or not *\/$/;"	p	class:SHEdit::CIter::CIter	access:public	signature:(wchar_t * string, bool skip = true, bool caseSensitive = true, bool wholeword = false)
SHEdit::CIter::CIter::FindPrev	uCursor.h	/^      \/*AUTOGENERATED*\/ bool  CIter::FindPrev (wchar_t * string, bool skip = true, bool caseSensitive = true, bool wholeword= false)  ; \/*!< same as findnext *\/$/;"	p	class:SHEdit::CIter::CIter	access:public	signature:(wchar_t * string, bool skip = true, bool caseSensitive = true, bool wholeword= false)
SHEdit::CIter::CIter::GetChar	uCursor.h	/^      \/*AUTOGENERATED*\/ wchar_t  CIter::GetChar ()  ; $/;"	p	class:SHEdit::CIter::CIter	access:public	signature:()
SHEdit::CIter::CIter::GetDistance	uCursor.h	/^      \/*AUTOGENERATED*\/ int  CIter::GetDistance (Iter* itr)  ; $/;"	p	class:SHEdit::CIter::CIter	access:public	signature:(Iter* itr)
SHEdit::CIter::CIter::GetLeftOffset	uCursor.h	/^      \/*AUTOGENERATED*\/ int  CIter::GetLeftOffset ()  ;                                              \/*!< Returns left offset counting tabs as multiple characters according to the tabstop *\/$/;"	p	class:SHEdit::CIter::CIter	access:public	signature:()
SHEdit::CIter::CIter::GetLine	uCursor.h	/^      \/*AUTOGENERATED*\/ String  CIter::GetLine ()  ; $/;"	p	class:SHEdit::CIter::CIter	access:public	signature:()
SHEdit::CIter::CIter::GetLineNum	uCursor.h	/^      \/*AUTOGENERATED*\/ int  CIter::GetLineNum ()  ; $/;"	p	class:SHEdit::CIter::CIter	access:public	signature:()
SHEdit::CIter::CIter::GetNextChar	uCursor.h	/^      \/*AUTOGENERATED*\/ wchar_t  CIter::GetNextChar ()  ; $/;"	p	class:SHEdit::CIter::CIter	access:public	signature:()
SHEdit::CIter::CIter::GoBy	uCursor.h	/^      \/*AUTOGENERATED*\/ void  CIter::GoBy (int chars, bool multiline = false)  ;                     \/*!< Goes forward counting tabs as single character. Always stays on the same line. *\/$/;"	p	class:SHEdit::CIter::CIter	access:public	signature:(int chars, bool multiline = false)
SHEdit::CIter::CIter::GoByOffset	uCursor.h	/^      \/*AUTOGENERATED*\/ void  CIter::GoByOffset (int chars)  ;                                       \/*!< Goes forward countint tabs as multiple characters according to the tabstop. Always stays on the same line. *\/$/;"	p	class:SHEdit::CIter::CIter	access:public	signature:(int chars)
SHEdit::CIter::CIter::GoChar	uCursor.h	/^      \/*AUTOGENERATED*\/ bool  CIter::GoChar ()  ;                                                    \/*!< Increments iterator by 1 *\/$/;"	p	class:SHEdit::CIter::CIter	access:public	signature:()
SHEdit::CIter::CIter::GoLeft	uCursor.h	/^      \/*AUTOGENERATED*\/ void  CIter::GoLeft (int chars, bool multiline = false)  ;                   \/*!< Goes forward counting tabs as single character. always stays on the same line *\/$/;"	p	class:SHEdit::CIter::CIter	access:public	signature:(int chars, bool multiline = false)
SHEdit::CIter::CIter::GoLine	uCursor.h	/^      \/*AUTOGENERATED*\/ bool  CIter::GoLine (bool allowEnd = false)  ;                               \/*!< Goes to the pos 0 of next line. That is the offset 0 of first Span after nextline NSpan *\/$/;"	p	class:SHEdit::CIter::CIter	access:public	signature:(bool allowEnd = false)
SHEdit::CIter::CIter::GoLineEnd	uCursor.h	/^      \/*AUTOGENERATED*\/ bool  CIter::GoLineEnd ()  ; $/;"	p	class:SHEdit::CIter::CIter	access:public	signature:()
SHEdit::CIter::CIter::GoLineStart	uCursor.h	/^      \/*AUTOGENERATED*\/ bool  CIter::GoLineStart ()  ; $/;"	p	class:SHEdit::CIter::CIter	access:public	signature:()
SHEdit::CIter::CIter::GoToLine	uCursor.h	/^      \/*AUTOGENERATED*\/ void  CIter::GoToLine (int line)  ; $/;"	p	class:SHEdit::CIter::CIter	access:public	signature:(int line)
SHEdit::CIter::CIter::GoWordLiteral	uCursor.h	/^      \/*AUTOGENERATED*\/ void  CIter::GoWordLiteral ()  ;                                             \/*!< goes to next start of a word (alnum + underscore) *\/$/;"	p	class:SHEdit::CIter::CIter	access:public	signature:()
SHEdit::CIter::CIter::IsUnderCursor	uCursor.h	/^      \/*AUTOGENERATED*\/ bool  CIter::IsUnderCursor (const wchar_t *& string, bool caseSensitive, bool wholeword)  ; \/*!< Tests if the string is at the position of cursor. Serves for FindNext\/FindNext. *\/$/;"	p	class:SHEdit::CIter::CIter	access:public	signature:(const wchar_t *& string, bool caseSensitive, bool wholeword)
SHEdit::CIter::CIter::LineIsEmpty	uCursor.h	/^      \/*AUTOGENERATED*\/ bool  CIter::LineIsEmpty ( bool allowWhite = false)  ; $/;"	p	class:SHEdit::CIter::CIter	access:public	signature:( bool allowWhite = false)
SHEdit::CIter::CIter::MarkupBegin	uCursor.h	/^      \/*AUTOGENERATED*\/ void  CIter::MarkupBegin (SHEdit::Format * format)  ;                        \/*!< Adds positionless markup. For formatting overview see \\ref index *\/$/;"	p	class:SHEdit::CIter::CIter	access:public	signature:(SHEdit::Format * format)
SHEdit::CIter::CIter::MarkupEnd	uCursor.h	/^      \/*AUTOGENERATED*\/ void  CIter::MarkupEnd (SHEdit::Format * format)  ;                          \/*!< Adds positionless markup. For formatting overview see \\ref index *\/$/;"	p	class:SHEdit::CIter::CIter	access:public	signature:(SHEdit::Format * format)
SHEdit::CIter::CIter::MarkupRem	uCursor.h	/^      \/*AUTOGENERATED*\/ void  CIter::MarkupRem (SHEdit::Format * format)  ;                          \/*!< Removes all positionless markup from current position. For formatting overview see \\ref index *\/$/;"	p	class:SHEdit::CIter::CIter	access:public	signature:(SHEdit::Format * format)
SHEdit::CIter::CIter::RevChar	uCursor.h	/^      \/*AUTOGENERATED*\/ bool  CIter::RevChar ()  ; $/;"	p	class:SHEdit::CIter::CIter	access:public	signature:()
SHEdit::CIter::CIter::RevLine	uCursor.h	/^      \/*AUTOGENERATED*\/ bool  CIter::RevLine ()  ; $/;"	p	class:SHEdit::CIter::CIter	access:public	signature:()
SHEdit::CIter::CIter::RevLineBegin	uCursor.h	/^      \/*AUTOGENERATED*\/ bool  CIter::RevLineBegin ()  ; $/;"	p	class:SHEdit::CIter::CIter	access:public	signature:()
SHEdit::CIter::CIter::RevWordLiteral	uCursor.h	/^      \/*AUTOGENERATED*\/ void  CIter::RevWordLiteral ()  ;                                            \/*!< goes to previous start of a word (alnum + underscore) *\/$/;"	p	class:SHEdit::CIter::CIter	access:public	signature:()
SHEdit::CIter::CIter::Valid	uCursor.h	/^      \/*AUTOGENERATED*\/ bool  CIter::Valid ()   ; $/;"	p	class:SHEdit::CIter::CIter	access:public	signature:()
SHEdit::CIter::DeleteTo	uCursor.h	/^             void DeleteTo(CIter& itr);$/;"	p	class:SHEdit::CIter	access:public	signature:(CIter& itr)
SHEdit::CIter::GetIter	uCursor.h	/^               Iter * GetIter();$/;"	p	class:SHEdit::CIter	access:public	signature:()
SHEdit::CIter::Init	uCursor.h	/^                void Init();$/;"	p	class:SHEdit::CIter	access:private	signature:()
SHEdit::CIter::Insert	uCursor.h	/^             void Insert(String xText);$/;"	p	class:SHEdit::CIter	access:public	signature:(String xText)
SHEdit::CIter::Update	uCursor.h	/^                void Update();$/;"	p	class:SHEdit::CIter	access:private	signature:()
SHEdit::CIter::component	uCursor.h	/^              TSHEdit * component;$/;"	m	class:SHEdit::CIter	access:private
SHEdit::CIter::itr	uCursor.h	/^                Iter itr;$/;"	m	class:SHEdit::CIter	access:private
SHEdit::CIter::myown	uCursor.h	/^                bool myown;$/;"	m	class:SHEdit::CIter	access:private
SHEdit::CIter::type	uCursor.h	/^                short type;$/;"	m	class:SHEdit::CIter	access:private
SHEdit::CIter::~CIter	uCursor.h	/^               ~CIter();$/;"	p	class:SHEdit::CIter	access:public	signature:()
SHEdit::Drawer	uDrawer.h	/^  class Drawer$/;"	c	namespace:SHEdit
SHEdit::Drawer::BottomBorder	uDrawer.h	/^      inline int BottomBorder();$/;"	p	class:SHEdit::Drawer	access:private	signature:()
SHEdit::Drawer::DrawCursor	uDrawer.h	/^      void DrawCursor();$/;"	p	class:SHEdit::Drawer	access:private	signature:()
SHEdit::Drawer::DrawEndl	uDrawer.h	/^      void __fastcall DrawEndl(short linenum, FontStyle format);$/;"	p	class:SHEdit::Drawer	access:private	signature:(short linenum, FontStyle format)
SHEdit::Drawer::DrawEof	uDrawer.h	/^      void __fastcall DrawEof(short linenum);$/;"	p	class:SHEdit::Drawer	access:private	signature:(short linenum)
SHEdit::Drawer::DrawLinenum	uDrawer.h	/^      void __fastcall DrawLinenum(int from);$/;"	p	class:SHEdit::Drawer	access:private	signature:(int from)
SHEdit::Drawer::DrawMove	uDrawer.h	/^      void __fastcall DrawMove(int from, int to, int by);$/;"	p	class:SHEdit::Drawer	access:private	signature:(int from, int to, int by)
SHEdit::Drawer::DrawResize	uDrawer.h	/^      void __fastcall DrawResize(int w, int h);$/;"	p	class:SHEdit::Drawer	access:private	signature:(int w, int h)
SHEdit::Drawer::DrawText	uDrawer.h	/^      void __fastcall DrawText(String text, bool newline, short linenum, FontStyle format);$/;"	p	class:SHEdit::Drawer	access:private	signature:(String text, bool newline, short linenum, FontStyle format)
SHEdit::Drawer::Drawer	uDrawer.h	/^      __fastcall Drawer(TCanvas * Canvas, TSHEdit * parent) ;$/;"	p	class:SHEdit::Drawer	access:public	signature:(TCanvas * Canvas, TSHEdit * parent)
SHEdit::Drawer::GetFontsize	uDrawer.h	/^      int __fastcall GetFontsize();$/;"	p	class:SHEdit::Drawer	access:public	signature:()
SHEdit::Drawer::GetLinenumWidth	uDrawer.h	/^      int __fastcall GetLinenumWidth();$/;"	p	class:SHEdit::Drawer	access:public	signature:()
SHEdit::Drawer::GetLinenumsEnabled	uDrawer.h	/^      bool __fastcall GetLinenumsEnabled();$/;"	p	class:SHEdit::Drawer	access:public	signature:()
SHEdit::Drawer::GetLinesize	uDrawer.h	/^      int __fastcall GetLinesize();$/;"	p	class:SHEdit::Drawer	access:public	signature:()
SHEdit::Drawer::HMax	uDrawer.h	/^      int HPos, HMax;$/;"	m	class:SHEdit::Drawer	access:private
SHEdit::Drawer::HPos	uDrawer.h	/^      int HPos, HMax;$/;"	m	class:SHEdit::Drawer	access:private
SHEdit::Drawer::Paint	uDrawer.h	/^      void __fastcall Paint();$/;"	p	class:SHEdit::Drawer	access:private	signature:()
SHEdit::Drawer::QueueDump	uDrawer.h	/^      void QueueDump();$/;"	p	class:SHEdit::Drawer	access:private	signature:()
SHEdit::Drawer::RightBorder	uDrawer.h	/^      inline int RightBorder();$/;"	p	class:SHEdit::Drawer	access:private	signature:()
SHEdit::Drawer::SetFontsize	uDrawer.h	/^      void __fastcall SetFontsize(int size);$/;"	p	class:SHEdit::Drawer	access:public	signature:(int size)
SHEdit::Drawer::SetLinenumsEnabled	uDrawer.h	/^      void __fastcall SetLinenumsEnabled(bool enable);$/;"	p	class:SHEdit::Drawer	access:public	signature:(bool enable)
SHEdit::Drawer::StressTest	uDrawer.h	/^      void StressTest();$/;"	p	class:SHEdit::Drawer	access:private	signature:()
SHEdit::Drawer::UpdateCursor	uDrawer.h	/^      void __fastcall UpdateCursor(int x, int y);$/;"	p	class:SHEdit::Drawer	access:private	signature:(int x, int y)
SHEdit::Drawer::UpdateHBar	uDrawer.h	/^      void __fastcall UpdateHBar();$/;"	p	class:SHEdit::Drawer	access:private	signature:()
SHEdit::Drawer::UpdateLinenumWidth	uDrawer.h	/^      bool __fastcall UpdateLinenumWidth(int count);$/;"	p	class:SHEdit::Drawer	access:public	signature:(int count)
SHEdit::Drawer::Write	uDrawer.h	/^      void Write(String message);$/;"	p	class:SHEdit::Drawer	access:private	signature:(String message)
SHEdit::Drawer::bitmap	uDrawer.h	/^      Graphics::TBitmap * bitmap;$/;"	m	class:SHEdit::Drawer	access:private
SHEdit::Drawer::canvas	uDrawer.h	/^      TCanvas * canvas;$/;"	m	class:SHEdit::Drawer	access:private
SHEdit::Drawer::con	uDrawer.h	/^      bool con;   \/\/cursorOn$/;"	m	class:SHEdit::Drawer	access:private
SHEdit::Drawer::cursorBGcolor	uDrawer.h	/^      TColor cursorBGcolor;$/;"	m	class:SHEdit::Drawer	access:private
SHEdit::Drawer::cx	uDrawer.h	/^      int cx, cy;$/;"	m	class:SHEdit::Drawer	access:private
SHEdit::Drawer::cy	uDrawer.h	/^      int cx, cy;$/;"	m	class:SHEdit::Drawer	access:private
SHEdit::Drawer::debugcount	uDrawer.h	/^      int debugcount;$/;"	m	class:SHEdit::Drawer	access:private
SHEdit::Drawer::debugtasks	uDrawer.h	/^      int debugtasks;$/;"	m	class:SHEdit::Drawer	access:private
SHEdit::Drawer::drawcanvas	uDrawer.h	/^      TCanvas * drawcanvas;$/;"	m	class:SHEdit::Drawer	access:private
SHEdit::Drawer::fontsize	uDrawer.h	/^      int fontsize;$/;"	m	class:SHEdit::Drawer	access:private
SHEdit::Drawer::lastlinenumcount	uDrawer.h	/^      int lastlinenumcount; \/\/to be able to update lw automatically$/;"	m	class:SHEdit::Drawer	access:private
SHEdit::Drawer::linenumsenabled	uDrawer.h	/^      bool linenumsenabled;$/;"	m	class:SHEdit::Drawer	access:private
SHEdit::Drawer::linenumwidth	uDrawer.h	/^      int linenumwidth;$/;"	m	class:SHEdit::Drawer	access:private
SHEdit::Drawer::linesize	uDrawer.h	/^      int linesize;$/;"	m	class:SHEdit::Drawer	access:private
SHEdit::Drawer::parent	uDrawer.h	/^      TSHEdit * parent;$/;"	m	class:SHEdit::Drawer	access:private
SHEdit::Drawer::x	uDrawer.h	/^      int x, y;$/;"	m	class:SHEdit::Drawer	access:private
SHEdit::Drawer::y	uDrawer.h	/^      int x, y;$/;"	m	class:SHEdit::Drawer	access:private
SHEdit::Drawer::~Drawer	uDrawer.h	/^      virtual __fastcall ~Drawer();$/;"	p	class:SHEdit::Drawer	access:public	signature:()
SHEdit::Empty	uLanguageDefinition.h	/^  enum LangDefSpecType{Empty = 0x1, Nomatch = 0x2, Normal=0x4, Jump=0x8, WordTag=0x20, LineTag=0x40, Lookahead = 0x80};$/;"	e	enum:SHEdit::LangDefSpecType
SHEdit::FontStyle	uFormat.h	/^  class FontStyle$/;"	c	namespace:SHEdit
SHEdit::FontStyle::FontStyle	uFormat.h	/^      FontStyle();$/;"	p	class:SHEdit::FontStyle	access:public	signature:()
SHEdit::FontStyle::FontStyle	uFormat.h	/^      FontStyle(TColor * foreground);$/;"	p	class:SHEdit::FontStyle	access:public	signature:(TColor * foreground)
SHEdit::FontStyle::FontStyle	uFormat.h	/^      FontStyle(TColor * foreground, TColor * background);$/;"	p	class:SHEdit::FontStyle	access:public	signature:(TColor * foreground, TColor * background)
SHEdit::FontStyle::FontStyle	uFormat.h	/^      FontStyle(TColor * foreground, TColor * background, TFontStyles style);$/;"	p	class:SHEdit::FontStyle	access:public	signature:(TColor * foreground, TColor * background, TFontStyles style)
SHEdit::FontStyle::background	uFormat.h	/^      TColor * background;$/;"	m	class:SHEdit::FontStyle	access:public
SHEdit::FontStyle::foreground	uFormat.h	/^      TColor * foreground;$/;"	m	class:SHEdit::FontStyle	access:public
SHEdit::FontStyle::operator !=	uFormat.h	/^      bool operator!=(const FontStyle& f);$/;"	p	class:SHEdit::FontStyle	access:public	signature:(const FontStyle& f)
SHEdit::FontStyle::operator +=	uFormat.h	/^      FontStyle& operator+=(const FontStyle& f);$/;"	p	class:SHEdit::FontStyle	access:public	signature:(const FontStyle& f)
SHEdit::FontStyle::operator +=	uFormat.h	/^      FontStyle& operator+=(const Format& f);$/;"	p	class:SHEdit::FontStyle	access:public	signature:(const Format& f)
SHEdit::FontStyle::operator =	uFormat.h	/^      FontStyle& operator=(const FontStyle& f);$/;"	p	class:SHEdit::FontStyle	access:public	signature:(const FontStyle& f)
SHEdit::FontStyle::operator =	uFormat.h	/^      FontStyle& operator=(const Format& f);$/;"	p	class:SHEdit::FontStyle	access:public	signature:(const Format& f)
SHEdit::FontStyle::operator ==	uFormat.h	/^      bool operator==(const FontStyle& f);$/;"	p	class:SHEdit::FontStyle	access:public	signature:(const FontStyle& f)
SHEdit::FontStyle::style	uFormat.h	/^      TFontStyles style;$/;"	m	class:SHEdit::FontStyle	access:public
SHEdit::Format	uFormat.h	/^  class Format : public FontStyle$/;"	c	namespace:SHEdit	inherits:FontStyle
SHEdit::Format::Add	uFormat.h	/^      void Add(Stack<Mark>::Node * mark);$/;"	p	class:SHEdit::Format	access:public	signature:(Stack<Mark>::Node * mark)
SHEdit::Format::AddIM	uFormat.h	/^      void AddIM(IMark * mark);$/;"	p	class:SHEdit::Format	access:public	signature:(IMark * mark)
SHEdit::Format::Format	uFormat.h	/^      Format();$/;"	p	class:SHEdit::Format	access:public	signature:()
SHEdit::Format::Format	uFormat.h	/^      Format(TColor * foreground, TColor * background);$/;"	p	class:SHEdit::Format	access:public	signature:(TColor * foreground, TColor * background)
SHEdit::Format::Format	uFormat.h	/^      Format(TColor * foreground, TColor * background, TFontStyles style);$/;"	p	class:SHEdit::Format	access:public	signature:(TColor * foreground, TColor * background, TFontStyles style)
SHEdit::Format::GetMarkBefore	uFormat.h	/^      IMark * GetMarkBefore(IPos * ipos);$/;"	p	class:SHEdit::Format	access:public	signature:(IPos * ipos)
SHEdit::Format::Remove	uFormat.h	/^      void Remove(Stack<Mark>::Node * mark);$/;"	p	class:SHEdit::Format	access:public	signature:(Stack<Mark>::Node * mark)
SHEdit::Format::RemoveAllMarks	uFormat.h	/^      void RemoveAllMarks();$/;"	p	class:SHEdit::Format	access:public	signature:()
SHEdit::Format::RemoveIM	uFormat.h	/^      void RemoveIM(IMark * mark);$/;"	p	class:SHEdit::Format	access:public	signature:(IMark * mark)
SHEdit::Format::imarks	uFormat.h	/^      std::set<IPos*, IMark::compare> imarks; \/\/Actually stores IMark pointers casted to pos for comparison$/;"	m	class:SHEdit::Format	access:private
SHEdit::Format::marks	uFormat.h	/^      std::list< Stack<Mark >::Node* > marks;$/;"	m	class:SHEdit::Format	access:private
SHEdit::Format::operator !=	uFormat.h	/^      bool operator!=(const Format& f);$/;"	p	class:SHEdit::Format	access:public	signature:(const Format& f)
SHEdit::Format::operator +=	uFormat.h	/^      Format& operator+=(const Format& f);$/;"	p	class:SHEdit::Format	access:public	signature:(const Format& f)
SHEdit::Format::operator =	uFormat.h	/^      Format& operator=(const Format& f);$/;"	p	class:SHEdit::Format	access:public	signature:(const Format& f)
SHEdit::Format::operator ==	uFormat.h	/^      bool operator==(const Format& f);$/;"	p	class:SHEdit::Format	access:public	signature:(const Format& f)
SHEdit::Format::~Format	uFormat.h	/^      ~Format();$/;"	p	class:SHEdit::Format	access:public	signature:()
SHEdit::IMark	uMark.h	/^  class IMark : public IPos$/;"	c	namespace:SHEdit	inherits:IPos
SHEdit::IMark::IMark	uMark.h	/^      IMark(Format * format, bool begin, IPos * itr);$/;"	p	class:SHEdit::IMark	access:public	signature:(Format * format, bool begin, IPos * itr)
SHEdit::IMark::begin	uMark.h	/^      bool begin;$/;"	m	class:SHEdit::IMark	access:public
SHEdit::IMark::format	uMark.h	/^      Format * format;$/;"	m	class:SHEdit::IMark	access:public
SHEdit::IMark::~IMark	uMark.h	/^      ~IMark();$/;"	p	class:SHEdit::IMark	access:public	signature:()
SHEdit::IPos	uIPos.h	/^  class IPos$/;"	c	namespace:SHEdit
SHEdit::IPos::Compare	uIPos.h	/^      static bool Compare(const IPos*& a, const IPos*& b);                                           \/*!< Returns true if "a" is to be considered to go befor "b" in buffer. For descendants should be also able to take into acount their positioning needs (i.e. when the position itself is the same, but some markup should be processed before other; its implemented this way to work with template asociative containers that do not allow comparing against other then template type) *\/$/;"	p	class:SHEdit::IPos	access:public	signature:(const IPos*& a, const IPos*& b)
SHEdit::IPos::Copy	uIPos.h	/^      void Copy(const IPos& ip);$/;"	p	class:SHEdit::IPos	access:private	signature:(const IPos& ip)
SHEdit::IPos::IMarkupBegin	uIPos.h	/^      IMark* IMarkupBegin(SHEdit::Format * format);                                                  \/*!< Places Iterator handled mark at IPos's position. For formatting overview see \\ref index . For more specific info see IMark class *\/$/;"	p	class:SHEdit::IPos	access:public	signature:(SHEdit::Format * format)
SHEdit::IPos::IMarkupEnd	uIPos.h	/^      IMark* IMarkupEnd(SHEdit::Format * format);                                                    \/*!< Places Iterator handled mark at IPos's position. For formatting overview see \\ref index . For more specific info see IMark class *\/$/;"	p	class:SHEdit::IPos	access:public	signature:(SHEdit::Format * format)
SHEdit::IPos::IPType	uIPos.h	/^      enum IPType{iptPos, iptIter, iptMark};$/;"	g	class:SHEdit::IPos	access:public
SHEdit::IPos::IPos	uIPos.h	/^      IPos();$/;"	p	class:SHEdit::IPos	access:public	signature:()
SHEdit::IPos::IPos	uIPos.h	/^      IPos(Buffer * buffer, NSpan * line, int linenum, int pos);$/;"	p	class:SHEdit::IPos	access:public	signature:(Buffer * buffer, NSpan * line, int linenum, int pos)
SHEdit::IPos::IPos	uIPos.h	/^      IPos(const IPos& ipos);$/;"	p	class:SHEdit::IPos	access:public	signature:(const IPos& ipos)
SHEdit::IPos::Invalidate	uIPos.h	/^      void Invalidate();$/;"	p	class:SHEdit::IPos	access:public	signature:()
SHEdit::IPos::RecalcPos	uIPos.h	/^      virtual void RecalcPos();                                                                      \/*!< Recalculates IPos::pos, according to descendant's own positioning *\/$/;"	p	class:SHEdit::IPos	access:public	signature:()
SHEdit::IPos::ReconstructIMarkFontStyle	uIPos.h	/^      FontStyle ReconstructIMarkFontStyle();                                                         \/*!< Returns current FontStyle determined by Iterator handled markup. For formatting overview see \\ref index . For more specific info see IMark class *\/$/;"	p	class:SHEdit::IPos	access:public	signature:()
SHEdit::IPos::Update	uIPos.h	/^      virtual void Update();                                                                         \/*!< Is called when structure of underlying buffer changed, to allow descendants to update their links to the physical structure. *\/$/;"	p	class:SHEdit::IPos	access:public	signature:()
SHEdit::IPos::UpdatePos	uIPos.h	/^      virtual void UpdatePos();                                                                      \/*!< Basically same as Update(), but handles repositioning *\/$/;"	p	class:SHEdit::IPos	access:public	signature:()
SHEdit::IPos::Valid	uIPos.h	/^      bool Valid();$/;"	p	class:SHEdit::IPos	access:public	signature:()
SHEdit::IPos::buffer	uIPos.h	/^      Buffer * buffer;                                                                               \/*!< A pointer to buffer that owns data pointed to by IPos instance. If buffer is null, then IPos or Iter respectively works in a "position less mode", and in that case does not guarantee to remain valid*\/$/;"	m	class:SHEdit::IPos	access:public
SHEdit::IPos::compare	uIPos.h	/^      struct compare$/;"	s	class:SHEdit::IPos	access:public
SHEdit::IPos::compare::operator ()	uIPos.h	/^        bool operator()(const IPos* a, const IPos* b) const;$/;"	p	struct:SHEdit::IPos::compare	access:public	signature:(const IPos* a, const IPos* b) const
SHEdit::IPos::iptIter	uIPos.h	/^      enum IPType{iptPos, iptIter, iptMark};$/;"	e	enum:SHEdit::IPos::IPType
SHEdit::IPos::iptMark	uIPos.h	/^      enum IPType{iptPos, iptIter, iptMark};$/;"	e	enum:SHEdit::IPos::IPType
SHEdit::IPos::iptPos	uIPos.h	/^      enum IPType{iptPos, iptIter, iptMark};$/;"	e	enum:SHEdit::IPos::IPType
SHEdit::IPos::line	uIPos.h	/^      NSpan * line;                                                                                  \/*!< Pointer to the befinning of current line. Positioning relies on correct line and linenum initialization. Other members can be recalculated *\/$/;"	m	class:SHEdit::IPos	access:public
SHEdit::IPos::linenum	uIPos.h	/^      int linenum;                                                                                   \/*!< Line number of relative line. Is correct as long as it was correctly initialized and the buffer pointer is valid *\/$/;"	m	class:SHEdit::IPos	access:public
SHEdit::IPos::operator =	uIPos.h	/^      IPos& operator=(const IPos& p);$/;"	p	class:SHEdit::IPos	access:public	signature:(const IPos& p)
SHEdit::IPos::operator ==	uIPos.h	/^      bool operator==(const IPos& p);$/;"	p	class:SHEdit::IPos	access:public	signature:(const IPos& p)
SHEdit::IPos::pos	uIPos.h	/^      int pos;                                                                                       \/*!< Left offset. Does treat tabs as characters. *\/$/;"	m	class:SHEdit::IPos	access:public
SHEdit::IPos::type	uIPos.h	/^      IPType type;                                                                                   \/*!< Determines type of object - allows IPos casted IMark\/Iter comparisons without requiring dynamic casting. *\/$/;"	m	class:SHEdit::IPos	access:public
SHEdit::IPos::~IPos	uIPos.h	/^      ~IPos();$/;"	p	class:SHEdit::IPos	access:public	signature:()
SHEdit::Iter	uIter.h	/^  class Iter : protected IPos, public std::iterator<std::bidirectional_iterator_tag, const wchar_t>$/;"	c	namespace:SHEdit	inherits:IPos,std::iterator
SHEdit::Iter::Duplicate	uIter.h	/^      Iter * Duplicate();                                                                            \/*!<  returns pointer to valid duplicate of Iter. *\/$/;"	p	class:SHEdit::Iter	access:public	signature:()
SHEdit::Iter::FindNext	uIter.h	/^      bool FindNext(wchar_t * string, bool skip = true, bool caseSensitive = true, bool wholeword = false)\/*AUTOGEN_UPDATE*\/; \/*!< skip defines whether to match word directly at cursor or not *\/$/;"	p	class:SHEdit::Iter	access:public	signature:(wchar_t * string, bool skip = true, bool caseSensitive = true, bool wholeword = false)
SHEdit::Iter::FindPrev	uIter.h	/^      bool FindPrev(wchar_t * string, bool skip = true, bool caseSensitive = true, bool wholeword= false)\/*AUTOGEN_UPDATE*\/; \/*!< same as findnext *\/$/;"	p	class:SHEdit::Iter	access:public	signature:(wchar_t * string, bool skip = true, bool caseSensitive = true, bool wholeword= false)
SHEdit::Iter::GetChar	uIter.h	/^      wchar_t GetChar()\/*AUTOGEN_PASS*\/;$/;"	p	class:SHEdit::Iter	access:public	signature:()
SHEdit::Iter::GetDistance	uIter.h	/^      int GetDistance(Iter* itr)\/*AUTOGEN_PASS*\/;$/;"	p	class:SHEdit::Iter	access:public	signature:(Iter* itr)
SHEdit::Iter::GetLeftOffset	uIter.h	/^      int GetLeftOffset()\/*AUTOGEN_PASS*\/;                                                           \/*!< Returns left offset counting tabs as multiple characters according to the tabstop *\/$/;"	p	class:SHEdit::Iter	access:public	signature:()
SHEdit::Iter::GetLine	uIter.h	/^      String GetLine()\/*AUTOGEN_PASS*\/;$/;"	p	class:SHEdit::Iter	access:public	signature:()
SHEdit::Iter::GetLineNum	uIter.h	/^      int GetLineNum()\/*AUTOGEN_PASS*\/;$/;"	p	class:SHEdit::Iter	access:public	signature:()
SHEdit::Iter::GetNextChar	uIter.h	/^      wchar_t GetNextChar()\/*AUTOGEN_PASS*\/;$/;"	p	class:SHEdit::Iter	access:public	signature:()
SHEdit::Iter::GetPrevChar	uIter.h	/^      wchar_t GetPrevChar()\/*AUTOGEN_PASS*\/;$/;"	p	class:SHEdit::Iter	access:public	signature:()
SHEdit::Iter::GoBy	uIter.h	/^      void GoBy(int chars, bool multiline = false)\/*AUTOGEN_UPDATE*\/;                                \/*!< Goes forward counting tabs as single character. Always stays on the same line. *\/$/;"	p	class:SHEdit::Iter	access:public	signature:(int chars, bool multiline = false)
SHEdit::Iter::GoByOffset	uIter.h	/^      void GoByOffset(int chars)\/*AUTOGEN_UPDATE*\/;                                                  \/*!< Goes forward countint tabs as multiple characters according to the tabstop. Always stays on the same line. *\/$/;"	p	class:SHEdit::Iter	access:public	signature:(int chars)
SHEdit::Iter::GoChar	uIter.h	/^      bool GoChar()\/*AUTOGEN_UPDATE*\/;                                                               \/*!< Increments iterator by 1 *\/$/;"	p	class:SHEdit::Iter	access:public	signature:()
SHEdit::Iter::GoLeft	uIter.h	/^      void GoLeft(int chars, bool multiline = false)\/*AUTOGEN_UPDATE*\/;                              \/*!< Goes forward counting tabs as single character. always stays on the same line *\/$/;"	p	class:SHEdit::Iter	access:public	signature:(int chars, bool multiline = false)
SHEdit::Iter::GoLine	uIter.h	/^      bool GoLine(bool allowEnd = false)\/*AUTOGEN_UPDATE*\/;                                          \/*!< Goes to the pos 0 of next line. That is the offset 0 of first Span after nextline NSpan *\/$/;"	p	class:SHEdit::Iter	access:public	signature:(bool allowEnd = false)
SHEdit::Iter::GoLineEnd	uIter.h	/^      bool GoLineEnd()\/*AUTOGEN_UPDATE*\/;$/;"	p	class:SHEdit::Iter	access:public	signature:()
SHEdit::Iter::GoLineStart	uIter.h	/^      bool GoLineStart()\/*AUTOGEN_UPDATE*\/;$/;"	p	class:SHEdit::Iter	access:public	signature:()
SHEdit::Iter::GoToLine	uIter.h	/^      void GoToLine(int line)\/*AUTOGEN_UPDATE*\/;$/;"	p	class:SHEdit::Iter	access:public	signature:(int line)
SHEdit::Iter::GoWord	uIter.h	/^      bool GoWord();                                                                                 \/*!< Goes to beginning of next Span *\/$/;"	p	class:SHEdit::Iter	access:protected	signature:()
SHEdit::Iter::GoWordEndLiteral	uIter.h	/^      void GoWordEndLiteral();                                                                       \/*!< goes to next end of a word (alnum + underscore)*\/$/;"	p	class:SHEdit::Iter	access:public	signature:()
SHEdit::Iter::GoWordLiteral	uIter.h	/^      void GoWordLiteral()\/*AUTOGEN_UPDATE*\/;                                                        \/*!< goes to next start of a word (alnum + underscore) *\/$/;"	p	class:SHEdit::Iter	access:public	signature:()
SHEdit::Iter::Invalidate	uIter.h	/^      void Invalidate();$/;"	p	class:SHEdit::Iter	access:public	signature:()
SHEdit::Iter::IsUnderCursor	uIter.h	/^      bool IsUnderCursor(const wchar_t *& string, bool caseSensitive, bool wholeword)\/*AUTOGEN_PASS*\/; \/*!< Tests if the string is at the position of cursor. Serves for FindNext\/FindNext. *\/$/;"	p	class:SHEdit::Iter	access:public	signature:(const wchar_t *& string, bool caseSensitive, bool wholeword)
SHEdit::Iter::IsWordChar	uIter.h	/^      inline bool IsWordChar(wchar_t c);$/;"	p	class:SHEdit::Iter	access:private	signature:(wchar_t c)
SHEdit::Iter::Iter	uIter.h	/^      Iter();$/;"	p	class:SHEdit::Iter	access:public	signature:()
SHEdit::Iter::Iter	uIter.h	/^      Iter(NSpan * line);$/;"	p	class:SHEdit::Iter	access:public	signature:(NSpan * line)
SHEdit::Iter::Iter	uIter.h	/^      Iter(NSpan * line, int linenum, int pos, Buffer * buffer);$/;"	p	class:SHEdit::Iter	access:public	signature:(NSpan * line, int linenum, int pos, Buffer * buffer)
SHEdit::Iter::Iter	uIter.h	/^      Iter(const Iter& itr);$/;"	p	class:SHEdit::Iter	access:public	signature:(const Iter& itr)
SHEdit::Iter::Iter	uIter.h	/^      Iter(int offset, Span * word, NSpan * line, Buffer * buffer, int linenum = -1);$/;"	p	class:SHEdit::Iter	access:public	signature:(int offset, Span * word, NSpan * line, Buffer * buffer, int linenum = -1)
SHEdit::Iter::LineIsEmpty	uIter.h	/^      bool LineIsEmpty( bool allowWhite = false)\/*AUTOGEN_PASS*\/;$/;"	p	class:SHEdit::Iter	access:public	signature:( bool allowWhite = false)
SHEdit::Iter::MarkupBegin	uIter.h	/^      void MarkupBegin(SHEdit::Format * format)\/*AUTOGEN_PASS*\/;                                     \/*!< Adds positionless markup. For formatting overview see \\ref index *\/$/;"	p	class:SHEdit::Iter	access:public	signature:(SHEdit::Format * format)
SHEdit::Iter::MarkupEnd	uIter.h	/^      void MarkupEnd(SHEdit::Format * format)\/*AUTOGEN_PASS*\/;                                       \/*!< Adds positionless markup. For formatting overview see \\ref index *\/$/;"	p	class:SHEdit::Iter	access:public	signature:(SHEdit::Format * format)
SHEdit::Iter::MarkupRem	uIter.h	/^      void MarkupRem(SHEdit::Format * format)\/*AUTOGEN_PASS*\/;                                       \/*!< Removes all positionless markup from current position. For formatting overview see \\ref index *\/$/;"	p	class:SHEdit::Iter	access:public	signature:(SHEdit::Format * format)
SHEdit::Iter::RecalcPos	uIter.h	/^      virtual void RecalcPos();                                                                      \/*!< Recalculates IPos::pos, according to descendant's own positioning *\/$/;"	p	class:SHEdit::Iter	access:protected	signature:()
SHEdit::Iter::RevChar	uIter.h	/^      bool RevChar()\/*AUTOGEN_UPDATE*\/;$/;"	p	class:SHEdit::Iter	access:public	signature:()
SHEdit::Iter::RevLine	uIter.h	/^      bool RevLine()\/*AUTOGEN_UPDATE*\/;$/;"	p	class:SHEdit::Iter	access:public	signature:()
SHEdit::Iter::RevLineBegin	uIter.h	/^      bool RevLineBegin()\/*AUTOGEN_UPDATE*\/;$/;"	p	class:SHEdit::Iter	access:public	signature:()
SHEdit::Iter::RevWord	uIter.h	/^      bool RevWord();$/;"	p	class:SHEdit::Iter	access:protected	signature:()
SHEdit::Iter::RevWordBegin	uIter.h	/^      bool RevWordBegin();$/;"	p	class:SHEdit::Iter	access:protected	signature:()
SHEdit::Iter::RevWordLiteral	uIter.h	/^      void RevWordLiteral()\/*AUTOGEN_UPDATE*\/;                                                       \/*!< goes to previous start of a word (alnum + underscore) *\/$/;"	p	class:SHEdit::Iter	access:public	signature:()
SHEdit::Iter::Update	uIter.h	/^      virtual void Update();                                                                         \/*!< Is called when structure of underlying buffer changed, to allow descendants to update their links to the physical structure. *\/$/;"	p	class:SHEdit::Iter	access:protected	signature:()
SHEdit::Iter::UpdateNextImark	uIter.h	/^      void UpdateNextImark();                                                                        \/*!< See the Iter class info for explanation *\/$/;"	p	class:SHEdit::Iter	access:protected	signature:()
SHEdit::Iter::UpdatePos	uIter.h	/^      virtual void UpdatePos();                                                                      \/*!< Basically same as Update(), but handles repositioning *\/$/;"	p	class:SHEdit::Iter	access:protected	signature:()
SHEdit::Iter::Valid	uIter.h	/^      bool Valid() \/*AUTOGEN_PASS*\/;$/;"	p	class:SHEdit::Iter	access:public	signature:()
SHEdit::Iter::nextimark	uIter.h	/^      int nextimark;                                                                                 \/*!< See the Iter class info for explanation *\/$/;"	m	class:SHEdit::Iter	access:protected
SHEdit::Iter::nextimarkln	uIter.h	/^      int nextimarkln;                                                                               \/*!< See the Iter class info for explanation *\/$/;"	m	class:SHEdit::Iter	access:protected
SHEdit::Iter::offset	uIter.h	/^      int offset;                                                                                    \/*!< Offset from beginning of current Span *\/$/;"	m	class:SHEdit::Iter	access:protected
SHEdit::Iter::operator !=	uIter.h	/^      bool operator!=(const Iter& itr);$/;"	p	class:SHEdit::Iter	access:public	signature:(const Iter& itr)
SHEdit::Iter::operator *	uIter.h	/^      wchar_t& operator*();$/;"	p	class:SHEdit::Iter	access:public	signature:()
SHEdit::Iter::operator ++	uIter.h	/^      Iter& operator++();$/;"	p	class:SHEdit::Iter	access:public	signature:()
SHEdit::Iter::operator --	uIter.h	/^      Iter& operator--();$/;"	p	class:SHEdit::Iter	access:public	signature:()
SHEdit::Iter::operator <	uIter.h	/^      bool operator<(const Iter& itr);$/;"	p	class:SHEdit::Iter	access:public	signature:(const Iter& itr)
SHEdit::Iter::operator =	uIter.h	/^      Iter& operator=(const Iter& itr);$/;"	p	class:SHEdit::Iter	access:public	signature:(const Iter& itr)
SHEdit::Iter::operator ==	uIter.h	/^      bool operator==(const Iter& itr);$/;"	p	class:SHEdit::Iter	access:public	signature:(const Iter& itr)
SHEdit::Iter::operator >	uIter.h	/^      bool operator>(const Iter& itr);$/;"	p	class:SHEdit::Iter	access:public	signature:(const Iter& itr)
SHEdit::Iter::ptr	uIter.h	/^      wchar_t * ptr;                                                                                 \/*!< Direct pointer to current character *\/$/;"	m	class:SHEdit::Iter	access:protected
SHEdit::Iter::word	uIter.h	/^      Span * word;                                                                                   \/*!< Pointer to current Span in buffer's structure *\/$/;"	m	class:SHEdit::Iter	access:protected
SHEdit::Iter::~Iter	uIter.h	/^      ~Iter();$/;"	p	class:SHEdit::Iter	access:public	signature:()
SHEdit::Jump	uLanguageDefinition.h	/^  enum LangDefSpecType{Empty = 0x1, Nomatch = 0x2, Normal=0x4, Jump=0x8, WordTag=0x20, LineTag=0x40, Lookahead = 0x80};$/;"	e	enum:SHEdit::LangDefSpecType
SHEdit::LangDefJumpType	uLanguageDefinition.h	/^  enum LangDefJumpType{tJump, tPush, tMask};$/;"	g	namespace:SHEdit
SHEdit::LangDefSpecType	uLanguageDefinition.h	/^  enum LangDefSpecType{Empty = 0x1, Nomatch = 0x2, Normal=0x4, Jump=0x8, WordTag=0x20, LineTag=0x40, Lookahead = 0x80};$/;"	g	namespace:SHEdit
SHEdit::LanguageDefinition	uLanguageDefinition.h	/^  class LanguageDefinition$/;"	c	namespace:SHEdit
SHEdit::LanguageDefinition	uLanguageDefinition2.h	/^  class LanguageDefinition$/;"	c	namespace:SHEdit
SHEdit::LanguageDefinition::AddDupTree	uLanguageDefinition.h	/^      TreeNode * AddDupTree(TreeNode * tree, FontStyle * format);                                    \/*!< Duplicates the base of tree provided with the format provided. All pointers remain intact - one tree may have more than one bases. By making changes that are deeper than the duplicated TreeNode's member pointers, then you are making changes to both trees. *\/$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(TreeNode * tree, FontStyle * format)
SHEdit::LanguageDefinition::AddJump	uLanguageDefinition.h	/^      void AddJump(wchar_t * string, FontStyle * format, LangDefJumpType type, TreeNode * at, TreeNode * to, short jumpmask = 0, short newmask = 0, short gmask= 0); \/*!< Adds a custom jump from "at" tree to "to" tree. String is a space separated list.*\/$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(wchar_t * string, FontStyle * format, LangDefJumpType type, TreeNode * at, TreeNode * to, short jumpmask = 0, short newmask = 0, short gmask= 0)
SHEdit::LanguageDefinition::AddJumpFront	uLanguageDefinition.h	/^      void AddJumpFront(wchar_t * string, FontStyle * format, LangDefJumpType type, TreeNode * at, TreeNode * to, short jumpmask = 0, short newmask = 0, short gmask= 0); \/*!< Like AddJump but adds new jumps to the beginning of jump list.*\/$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(wchar_t * string, FontStyle * format, LangDefJumpType type, TreeNode * at, TreeNode * to, short jumpmask = 0, short newmask = 0, short gmask= 0)
SHEdit::LanguageDefinition::AddJumps	uLanguageDefinition.h	/^      void AddJumps(wchar_t * string, FontStyle * format, LangDefJumpType type, TreeNode * at, TreeNode * to, short jumpmask = 0, short newmask = 0, short newgmask= 0); \/*!< Just an abreviation. *\/$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(wchar_t * string, FontStyle * format, LangDefJumpType type, TreeNode * at, TreeNode * to, short jumpmask = 0, short newmask = 0, short newgmask= 0)
SHEdit::LanguageDefinition::AddJumpsFront	uLanguageDefinition.h	/^      void AddJumpsFront(wchar_t * string, FontStyle * format, LangDefJumpType type, TreeNode * at, TreeNode * to, short jumpmask = 0, short newmask = 0, short newgmask= 0); \/*!< Just an abreviation. *\/$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(wchar_t * string, FontStyle * format, LangDefJumpType type, TreeNode * at, TreeNode * to, short jumpmask = 0, short newmask = 0, short newgmask= 0)
SHEdit::LanguageDefinition::AddKeywords	uLanguageDefinition.h	/^      void AddKeywords(wchar_t * string, FontStyle * format, TreeNode * at = NULL);                  \/*!< Adds all words that are contained in string (as space-separated list) to the tree given as "at". If tree is not given, then the main root is used *\/$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(wchar_t * string, FontStyle * format, TreeNode * at = NULL)
SHEdit::LanguageDefinition::AddLine	uLanguageDefinition.h	/^      TreeNode * AddLine(wchar_t * string, FontStyle * format, TreeNode * at = NULL, TreeNode * to = NULL); \/*!< Adds a linetag item - as c commenting \/\/. Returns new tree that was created for the line's formatting. Is an abbreviation for double jump. *\/$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(wchar_t * string, FontStyle * format, TreeNode * at = NULL, TreeNode * to = NULL)
SHEdit::LanguageDefinition::AddLineStrong	uLanguageDefinition.h	/^      TreeNode * AddLineStrong(wchar_t * string, FontStyle * format, TreeNode * at = NULL, TreeNode * to = NULL); \/*!< as AddLine, but stores entire state of parser and at the end of line it restores it back. *\/$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(wchar_t * string, FontStyle * format, TreeNode * at = NULL, TreeNode * to = NULL)
SHEdit::LanguageDefinition::AddNewTree	uLanguageDefinition.h	/^      TreeNode * AddNewTree(FontStyle * format);                                                     \/*!< Just creates and returns an empty new tree with format as the default format *\/$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(FontStyle * format)
SHEdit::LanguageDefinition::AddNewTree	uLanguageDefinition.h	/^      TreeNode * AddNewTree(FontStyle * format, bool caseSensitive);                                 \/*!< Just creates and returns an empty new tree with format as the default format *\/$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(FontStyle * format, bool caseSensitive)
SHEdit::LanguageDefinition::AddNonTerm	uLanguageDefinition2.h	/^      void AddNonTerm(const std::wstring& name, FontStyle* fs, int id, int flags);$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(const std::wstring& name, FontStyle* fs, int id, int flags)
SHEdit::LanguageDefinition::AddPair	uLanguageDefinition.h	/^      TreeNode * AddPair(wchar_t * opening, wchar_t * closing, FontStyle * format, TreeNode * at = NULL, TreeNode * to = NULL); \/*!< Is just an abreviation for two jumps. Adds jump from "opening" tag at "at" tree to newly created tree and then corresponding jump back *\/$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(wchar_t * opening, wchar_t * closing, FontStyle * format, TreeNode * at = NULL, TreeNode * to = NULL)
SHEdit::LanguageDefinition::AddPop	uLanguageDefinition.h	/^      void AddPop(wchar_t * string, FontStyle * format, TreeNode * at, short popmask, short popcount = -2, short newgmask = 0);$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(wchar_t * string, FontStyle * format, TreeNode * at, short popmask, short popcount = -2, short newgmask = 0)
SHEdit::LanguageDefinition::AddPops	uLanguageDefinition.h	/^      void AddPops(wchar_t * string, FontStyle * format, TreeNode * at, short popmask, short popcount = -2, short newgmask = 0); \/*!< Just an abreviation. *\/$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(wchar_t * string, FontStyle * format, TreeNode * at, short popmask, short popcount = -2, short newgmask = 0)
SHEdit::LanguageDefinition::AddPush	uLanguageDefinition.h	/^      void AddPush(wchar_t * string, FontStyle * format, TreeNode * at, TreeNode * to, short pushmask, short newmask = 0, short newgmask = 0); \/*!< Adds pushes specified by string (as space separated list. *\/$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(wchar_t * string, FontStyle * format, TreeNode * at, TreeNode * to, short pushmask, short newmask = 0, short newgmask = 0)
SHEdit::LanguageDefinition::AddPushFront	uLanguageDefinition.h	/^      void AddPushFront(wchar_t * string, FontStyle * format, TreeNode * at, TreeNode * to, short pushmask, short newmask = 0, short newgmask = 0);$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(wchar_t * string, FontStyle * format, TreeNode * at, TreeNode * to, short pushmask, short newmask = 0, short newgmask = 0)
SHEdit::LanguageDefinition::AddPushPopPair	uLanguageDefinition.h	/^      TreeNode * AddPushPopPair(wchar_t * opening, wchar_t * closing, FontStyle * format, TreeNode * at, TreeNode * to, short mask); \/*!< Is just an abreviation for push that adds the mask and pop that is conditioned by the same mask.*\/$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(wchar_t * opening, wchar_t * closing, FontStyle * format, TreeNode * at, TreeNode * to, short mask)
SHEdit::LanguageDefinition::AddPushes	uLanguageDefinition.h	/^      void AddPushes(wchar_t * string, FontStyle * format, TreeNode * at, TreeNode * to, short pushmask, short newmask = 0, short newgmask = 0); \/*!< Just an abreviation. *\/$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(wchar_t * string, FontStyle * format, TreeNode * at, TreeNode * to, short pushmask, short newmask = 0, short newgmask = 0)
SHEdit::LanguageDefinition::AddPushesFront	uLanguageDefinition.h	/^      void AddPushesFront(wchar_t * string, FontStyle * format, TreeNode * at, TreeNode * to, short pushmask, short newmask = 0, short newgmask = 0); \/*!< Just an abreviation. *\/$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(wchar_t * string, FontStyle * format, TreeNode * at, TreeNode * to, short pushmask, short newmask = 0, short newgmask = 0)
SHEdit::LanguageDefinition::AddRule	uLanguageDefinition2.h	/^      void AddRule(const std::wstring& name, std::wstring rule);$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(const std::wstring& name, std::wstring rule)
SHEdit::LanguageDefinition::AddTerm	uLanguageDefinition2.h	/^      void AddTerm(const std::wstring& name,FontStyle*,const std::wstring& rgx, int id, int flags);$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(const std::wstring& name,FontStyle*,const std::wstring& rgx, int id, int flags)
SHEdit::LanguageDefinition::AddWord	uLanguageDefinition.h	/^      void AddWord(wchar_t * string, FontStyle * format, TreeNode * at = NULL);                      \/*!< Adds a wordtag item (i.e. for highlighting php variables as $test just by $) *\/$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(wchar_t * string, FontStyle * format, TreeNode * at = NULL)
SHEdit::LanguageDefinition::Auto	uLanguageDefinition2.h	/^      const static int Auto = -1;$/;"	m	class:SHEdit::LanguageDefinition	access:public
SHEdit::LanguageDefinition::Construct	uLanguageDefinition2.h	/^      void Construct(std::wstring& rule, std::vector<Node*>& endnodes);$/;"	p	class:SHEdit::LanguageDefinition	access:private	signature:(std::wstring& rule, std::vector<Node*>& endnodes)
SHEdit::LanguageDefinition::Finalize	uLanguageDefinition2.h	/^      void Finalize(); $/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:()
SHEdit::LanguageDefinition::FindOrCreateItem	uLanguageDefinition.h	/^      TreeNode* FindOrCreateItem(TreeNode * item, wchar_t c, TreeNode * at);$/;"	p	class:SHEdit::LanguageDefinition	access:private	signature:(TreeNode * item, wchar_t c, TreeNode * at)
SHEdit::LanguageDefinition::GetDefSC	uLanguageDefinition.h	/^      SearchIter GetDefSC(short id);$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(short id)
SHEdit::LanguageDefinition::GetToken	uLanguageDefinition2.h	/^      TokType GetToken(std::wstring& str, std::wstring& val);$/;"	p	class:SHEdit::LanguageDefinition	access:private	signature:(std::wstring& str, std::wstring& val)
SHEdit::LanguageDefinition::GetToken	uLanguageDefinition2.h	/^      TokType GetToken(std::wstring& str, std::wstring& val, bool eat);$/;"	p	class:SHEdit::LanguageDefinition	access:private	signature:(std::wstring& str, std::wstring& val, bool eat)
SHEdit::LanguageDefinition::GetTree	uLanguageDefinition.h	/^      TreeNode* GetTree();$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:()
SHEdit::LanguageDefinition::Go	uLanguageDefinition.h	/^      LangDefSpecType Go(SearchIter * item, wchar_t c, bool & lookahead);                            \/*!< Serves Parser for retrieving information about where to go further. Lookahead is set to true, if item was returned to empty and directly went to first unmatched character *\/$/;"	p	class:SHEdit::LanguageDefinition	access:private	signature:(SearchIter * item, wchar_t c, bool & lookahead)
SHEdit::LanguageDefinition::IsAl	uLanguageDefinition.h	/^      virtual bool IsAl(wchar_t c);$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(wchar_t c)
SHEdit::LanguageDefinition::IsAlNum	uLanguageDefinition.h	/^      virtual bool IsAlNum(wchar_t c);$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(wchar_t c)
SHEdit::LanguageDefinition::IsNum	uLanguageDefinition.h	/^      virtual bool IsNum(wchar_t c);$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(wchar_t c)
SHEdit::LanguageDefinition::IsWhite	uLanguageDefinition.h	/^      virtual bool IsWhite(wchar_t c);                                                               \/*!< not used anywhere in project if I am not mistaken *\/$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(wchar_t c)
SHEdit::LanguageDefinition::Jump	uLanguageDefinition.h	/^      struct Jump$/;"	s	class:SHEdit::LanguageDefinition	access:private
SHEdit::LanguageDefinition::Jump::Jump	uLanguageDefinition.h	/^        Jump();$/;"	p	struct:SHEdit::LanguageDefinition::Jump	access:public	signature:()
SHEdit::LanguageDefinition::Jump::Jump	uLanguageDefinition.h	/^        Jump(short _pushmask, short _newmask, short _newgmask, LangDefJumpType _type, TreeNode * _next, FontStyle * format);$/;"	p	struct:SHEdit::LanguageDefinition::Jump	access:public	signature:(short _pushmask, short _newmask, short _newgmask, LangDefJumpType _type, TreeNode * _next, FontStyle * format)
SHEdit::LanguageDefinition::Jump::format	uLanguageDefinition.h	/^        FontStyle * format;$/;"	m	struct:SHEdit::LanguageDefinition::Jump	access:public
SHEdit::LanguageDefinition::Jump::newgmask	uLanguageDefinition.h	/^        short newgmask;$/;"	m	struct:SHEdit::LanguageDefinition::Jump	access:public
SHEdit::LanguageDefinition::Jump::newmask	uLanguageDefinition.h	/^        short newmask;$/;"	m	struct:SHEdit::LanguageDefinition::Jump	access:public
SHEdit::LanguageDefinition::Jump::nextTree	uLanguageDefinition.h	/^        TreeNode * nextTree;$/;"	m	struct:SHEdit::LanguageDefinition::Jump	access:public
SHEdit::LanguageDefinition::Jump::pushmask	uLanguageDefinition.h	/^        short pushmask;$/;"	m	struct:SHEdit::LanguageDefinition::Jump	access:public
SHEdit::LanguageDefinition::Jump::type	uLanguageDefinition.h	/^        short type;$/;"	m	struct:SHEdit::LanguageDefinition::Jump	access:public
SHEdit::LanguageDefinition::LanguageDefinition	uLanguageDefinition.h	/^      LanguageDefinition();$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:()
SHEdit::LanguageDefinition::LanguageDefinition	uLanguageDefinition2.h	/^      LanguageDefinition(const std::locale& loc = std::locale());$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(const std::locale& loc = std::locale())
SHEdit::LanguageDefinition::NTerm	uLanguageDefinition2.h	/^      struct NTerm$/;"	s	class:SHEdit::LanguageDefinition	access:private
SHEdit::LanguageDefinition::NTerm::Cq	uLanguageDefinition2.h	/^        bool Cq(const NTerm& n){return ruleid == n.ruleid && gather == n.gather && call == n.call && fs == n.fs;};$/;"	f	struct:SHEdit::LanguageDefinition::NTerm	access:public	signature:(const NTerm& n)
SHEdit::LanguageDefinition::NTerm::Eq	uLanguageDefinition2.h	/^        bool Eq(const NTerm& n){return ruleid == n.ruleid;};$/;"	f	struct:SHEdit::LanguageDefinition::NTerm	access:public	signature:(const NTerm& n)
SHEdit::LanguageDefinition::NTerm::NTerm	uLanguageDefinition2.h	/^        NTerm(const std::wstring& n, FontStyle* f, int i, bool g, bool c);$/;"	p	struct:SHEdit::LanguageDefinition::NTerm	access:public	signature:(const std::wstring& n, FontStyle* f, int i, bool g, bool c)
SHEdit::LanguageDefinition::NTerm::call	uLanguageDefinition2.h	/^        bool call;$/;"	m	struct:SHEdit::LanguageDefinition::NTerm	access:public
SHEdit::LanguageDefinition::NTerm::fs	uLanguageDefinition2.h	/^        FontStyle* fs;$/;"	m	struct:SHEdit::LanguageDefinition::NTerm	access:public
SHEdit::LanguageDefinition::NTerm::gather	uLanguageDefinition2.h	/^        bool gather;$/;"	m	struct:SHEdit::LanguageDefinition::NTerm	access:public
SHEdit::LanguageDefinition::NTerm::name	uLanguageDefinition2.h	/^        std::wstring name;$/;"	m	struct:SHEdit::LanguageDefinition::NTerm	access:public
SHEdit::LanguageDefinition::NTerm::node	uLanguageDefinition2.h	/^        Node* node;$/;"	m	struct:SHEdit::LanguageDefinition::NTerm	access:public
SHEdit::LanguageDefinition::NTerm::ruleid	uLanguageDefinition2.h	/^        int ruleid;$/;"	m	struct:SHEdit::LanguageDefinition::NTerm	access:public
SHEdit::LanguageDefinition::NType	uLanguageDefinition2.h	/^      enum NType {ntTerm, ntNTerm, ntLambda, ntEnd, ntTailrec};$/;"	g	class:SHEdit::LanguageDefinition	access:private
SHEdit::LanguageDefinition::Node	uLanguageDefinition2.h	/^      struct Node$/;"	s	class:SHEdit::LanguageDefinition	access:private
SHEdit::LanguageDefinition::Node::Add	uLanguageDefinition2.h	/^        Node* Add(const Node& n); \/\/returns a pointer to a used node (either a new node, or an already existing done)$/;"	p	struct:SHEdit::LanguageDefinition::Node	access:public	signature:(const Node& n)
SHEdit::LanguageDefinition::Node::Cq	uLanguageDefinition2.h	/^        bool Cq(const Node& n); \/\/congruent; more power needed here  - we should check the rest of the tree too$/;"	p	struct:SHEdit::LanguageDefinition::Node	access:public	signature:(const Node& n)
SHEdit::LanguageDefinition::Node::Eq	uLanguageDefinition2.h	/^        bool Eq(const Node& n); \/\/equal (indistinguishable by perser)$/;"	p	struct:SHEdit::LanguageDefinition::Node	access:public	signature:(const Node& n)
SHEdit::LanguageDefinition::Node::ExpandLambda	uLanguageDefinition2.h	/^        void ExpandLambda(std::map<int, Node*>& index, Node* next);$/;"	p	struct:SHEdit::LanguageDefinition::Node	access:public	signature:(std::map<int, Node*>& index, Node* next)
SHEdit::LanguageDefinition::Node::Finalize	uLanguageDefinition2.h	/^        void Finalize(); $/;"	p	struct:SHEdit::LanguageDefinition::Node	access:public	signature:()
SHEdit::LanguageDefinition::Node::Node	uLanguageDefinition2.h	/^        Node() : type(ntLambda), r(), nextnodes(), lftidx(), recidx(){};$/;"	f	struct:SHEdit::LanguageDefinition::Node	access:public	signature:()
SHEdit::LanguageDefinition::Node::Node	uLanguageDefinition2.h	/^        Node(NTerm* t) : type(ntNTerm), r(t), nextnodes(), lftidx(), recidx(){};$/;"	f	struct:SHEdit::LanguageDefinition::Node	access:public	signature:(NTerm* t)
SHEdit::LanguageDefinition::Node::Node	uLanguageDefinition2.h	/^        Node(NType t) : type(t), r(), nextnodes(), lftidx(), recidx(){};$/;"	f	struct:SHEdit::LanguageDefinition::Node	access:public	signature:(NType t)
SHEdit::LanguageDefinition::Node::Node	uLanguageDefinition2.h	/^        Node(Term* t) : type(ntTerm), r(t), nextnodes(), lftidx(), recidx(){};$/;"	f	struct:SHEdit::LanguageDefinition::Node	access:public	signature:(Term* t)
SHEdit::LanguageDefinition::Node::lftidx	uLanguageDefinition2.h	/^        std::map<int, Node*> lftidx; \/\/leave index$/;"	m	struct:SHEdit::LanguageDefinition::Node	access:public
SHEdit::LanguageDefinition::Node::nextnodes	uLanguageDefinition2.h	/^        std::vector<Node*> nextnodes;$/;"	m	struct:SHEdit::LanguageDefinition::Node	access:public
SHEdit::LanguageDefinition::Node::operator ==	uLanguageDefinition2.h	/^        bool operator==(const Node& n);$/;"	p	struct:SHEdit::LanguageDefinition::Node	access:public	signature:(const Node& n)
SHEdit::LanguageDefinition::Node::r	uLanguageDefinition2.h	/^        Rec r;$/;"	m	struct:SHEdit::LanguageDefinition::Node	access:public
SHEdit::LanguageDefinition::Node::recidx	uLanguageDefinition2.h	/^        std::map<int, Node*> recidx; \/\/recursive index (for nonterminals)$/;"	m	struct:SHEdit::LanguageDefinition::Node	access:public
SHEdit::LanguageDefinition::Node::type	uLanguageDefinition2.h	/^        NType type;$/;"	m	struct:SHEdit::LanguageDefinition::Node	access:public
SHEdit::LanguageDefinition::PState	uLanguageDefinition2.h	/^      struct PState$/;"	s	class:SHEdit::LanguageDefinition	access:public
SHEdit::LanguageDefinition::PState::PState	uLanguageDefinition2.h	/^        PState() : st(){};$/;"	f	struct:SHEdit::LanguageDefinition::PState	access:public	signature:()
SHEdit::LanguageDefinition::PState::st	uLanguageDefinition2.h	/^        std::stack<StackItem> st;$/;"	m	struct:SHEdit::LanguageDefinition::PState	access:public
SHEdit::LanguageDefinition::Parse	uLanguageDefinition2.h	/^      void Parse(IT& from, const IT& to, PState&, bool& stylechanged, FontStyle*&fs);$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(IT& from, const IT& to, PState&, bool& stylechanged, FontStyle*&fs)
SHEdit::LanguageDefinition::ParseString	uLanguageDefinition2.h	/^      void ParseString(std::wstring& rule, std::vector<Node*>& endnodes);$/;"	p	class:SHEdit::LanguageDefinition	access:private	signature:(std::wstring& rule, std::vector<Node*>& endnodes)
SHEdit::LanguageDefinition::Pop	uLanguageDefinition.h	/^      struct Pop$/;"	s	class:SHEdit::LanguageDefinition	access:private
SHEdit::LanguageDefinition::Pop::Pop	uLanguageDefinition.h	/^        Pop();$/;"	p	struct:SHEdit::LanguageDefinition::Pop	access:public	signature:()
SHEdit::LanguageDefinition::Pop::Pop	uLanguageDefinition.h	/^        Pop(short _popmask, short _newgmask, short _popcount, FontStyle * format);$/;"	p	struct:SHEdit::LanguageDefinition::Pop	access:public	signature:(short _popmask, short _newgmask, short _popcount, FontStyle * format)
SHEdit::LanguageDefinition::Pop::format	uLanguageDefinition.h	/^        FontStyle * format;$/;"	m	struct:SHEdit::LanguageDefinition::Pop	access:public
SHEdit::LanguageDefinition::Pop::newgmask	uLanguageDefinition.h	/^        short newgmask;$/;"	m	struct:SHEdit::LanguageDefinition::Pop	access:public
SHEdit::LanguageDefinition::Pop::popcount	uLanguageDefinition.h	/^        short popcount;$/;"	m	struct:SHEdit::LanguageDefinition::Pop	access:public
SHEdit::LanguageDefinition::Pop::popmask	uLanguageDefinition.h	/^        short popmask;$/;"	m	struct:SHEdit::LanguageDefinition::Pop	access:public
SHEdit::LanguageDefinition::Rec	uLanguageDefinition2.h	/^      struct Rec$/;"	s	class:SHEdit::LanguageDefinition	access:private
SHEdit::LanguageDefinition::Rec::GetName	uLanguageDefinition2.h	/^        const std::wstring& GetName()const{return term? t->name : nt->name;};$/;"	f	struct:SHEdit::LanguageDefinition::Rec	access:public	signature:() const
SHEdit::LanguageDefinition::Rec::Rec	uLanguageDefinition2.h	/^        Rec() : t(NULL), nt(NULL), term(false){};$/;"	f	struct:SHEdit::LanguageDefinition::Rec	access:public	signature:()
SHEdit::LanguageDefinition::Rec::Rec	uLanguageDefinition2.h	/^        Rec(NTerm* t_) : nt(t_), t(NULL), term(false){};$/;"	f	struct:SHEdit::LanguageDefinition::Rec	access:public	signature:(NTerm* t_)
SHEdit::LanguageDefinition::Rec::Rec	uLanguageDefinition2.h	/^        Rec(Term* t_) : t(t_), nt(NULL), term(true){};$/;"	f	struct:SHEdit::LanguageDefinition::Rec	access:public	signature:(Term* t_)
SHEdit::LanguageDefinition::Rec::nt	uLanguageDefinition2.h	/^        NTerm* nt;$/;"	m	struct:SHEdit::LanguageDefinition::Rec	access:public
SHEdit::LanguageDefinition::Rec::operator <	uLanguageDefinition2.h	/^        bool operator<(const Rec& r)const{return GetName() < r.GetName();};$/;"	f	struct:SHEdit::LanguageDefinition::Rec	access:public	signature:(const Rec& r) const
SHEdit::LanguageDefinition::Rec::t	uLanguageDefinition2.h	/^        Term* t;$/;"	m	struct:SHEdit::LanguageDefinition::Rec	access:public
SHEdit::LanguageDefinition::Rec::term	uLanguageDefinition2.h	/^        bool term;$/;"	m	struct:SHEdit::LanguageDefinition::Rec	access:public
SHEdit::LanguageDefinition::SearchIter	uLanguageDefinition.h	/^      struct SearchIter$/;"	s	class:SHEdit::LanguageDefinition	access:public
SHEdit::LanguageDefinition::SearchIter::SearchIter	uLanguageDefinition.h	/^        SearchIter();$/;"	p	struct:SHEdit::LanguageDefinition::SearchIter	access:public	signature:()
SHEdit::LanguageDefinition::SearchIter::base	uLanguageDefinition.h	/^        TreeNode * base;$/;"	m	struct:SHEdit::LanguageDefinition::SearchIter	access:public
SHEdit::LanguageDefinition::SearchIter::current	uLanguageDefinition.h	/^        TreeNode * current;$/;"	m	struct:SHEdit::LanguageDefinition::SearchIter	access:public
SHEdit::LanguageDefinition::SearchIter::mask	uLanguageDefinition.h	/^        short mask;$/;"	m	struct:SHEdit::LanguageDefinition::SearchIter	access:public
SHEdit::LanguageDefinition::SearchIter::operator !=	uLanguageDefinition.h	/^        bool operator!=(const SearchIter& sit);$/;"	p	struct:SHEdit::LanguageDefinition::SearchIter	access:public	signature:(const SearchIter& sit)
SHEdit::LanguageDefinition::SearchIter::operator ==	uLanguageDefinition.h	/^        bool operator==(const SearchIter& sit);$/;"	p	struct:SHEdit::LanguageDefinition::SearchIter	access:public	signature:(const SearchIter& sit)
SHEdit::LanguageDefinition::SetAllowWhiteSkipping	uLanguageDefinition.h	/^      void SetAllowWhiteSkipping(bool allow);$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(bool allow)
SHEdit::LanguageDefinition::SetCaseSensitive	uLanguageDefinition.h	/^      void SetCaseSensitive(bool caseSensitive);$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(bool caseSensitive)
SHEdit::LanguageDefinition::SetDefaultColor	uLanguageDefinition.h	/^      void SetDefaultColor(TColor * defColor);$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(TColor * defColor)
SHEdit::LanguageDefinition::SetTreeCaseSensitive	uLanguageDefinition.h	/^      void SetTreeCaseSensitive(TreeNode * item, bool caseSensitive);$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(TreeNode * item, bool caseSensitive)
SHEdit::LanguageDefinition::StackItem	uLanguageDefinition2.h	/^      struct StackItem$/;"	s	class:SHEdit::LanguageDefinition	access:public
SHEdit::LanguageDefinition::StackItem::ptr	uLanguageDefinition2.h	/^        Node* ptr;$/;"	m	struct:SHEdit::LanguageDefinition::StackItem	access:public
SHEdit::LanguageDefinition::Term	uLanguageDefinition2.h	/^      struct Term$/;"	s	class:SHEdit::LanguageDefinition	access:private
SHEdit::LanguageDefinition::Term::Cq	uLanguageDefinition2.h	/^        bool Cq(const Term& n){return tokid == n.tokid && remember == n.remember && getstyle == n.getstyle && call == n.call && fs == n.fs;};$/;"	f	struct:SHEdit::LanguageDefinition::Term	access:public	signature:(const Term& n)
SHEdit::LanguageDefinition::Term::Eq	uLanguageDefinition2.h	/^        bool Eq(const Term& n){return tokid == n.tokid;};$/;"	f	struct:SHEdit::LanguageDefinition::Term	access:public	signature:(const Term& n)
SHEdit::LanguageDefinition::Term::Term	uLanguageDefinition2.h	/^        Term(const std::wstring& n, FontStyle* fs_, int i, bool g, bool c) : name(n), fs(fs_), tokid(i), getstyle(g), call(c) {} ;$/;"	f	struct:SHEdit::LanguageDefinition::Term	access:public	signature:(const std::wstring& n, FontStyle* fs_, int i, bool g, bool c)
SHEdit::LanguageDefinition::Term::call	uLanguageDefinition2.h	/^        bool call;$/;"	m	struct:SHEdit::LanguageDefinition::Term	access:public
SHEdit::LanguageDefinition::Term::fs	uLanguageDefinition2.h	/^        FontStyle* fs;$/;"	m	struct:SHEdit::LanguageDefinition::Term	access:public
SHEdit::LanguageDefinition::Term::gather	uLanguageDefinition2.h	/^        bool gather;$/;"	m	struct:SHEdit::LanguageDefinition::Term	access:public
SHEdit::LanguageDefinition::Term::getstyle	uLanguageDefinition2.h	/^        bool getstyle;$/;"	m	struct:SHEdit::LanguageDefinition::Term	access:public
SHEdit::LanguageDefinition::Term::name	uLanguageDefinition2.h	/^        std::wstring name;$/;"	m	struct:SHEdit::LanguageDefinition::Term	access:public
SHEdit::LanguageDefinition::Term::remember	uLanguageDefinition2.h	/^        bool remember;$/;"	m	struct:SHEdit::LanguageDefinition::Term	access:public
SHEdit::LanguageDefinition::Term::tokid	uLanguageDefinition2.h	/^        int tokid;$/;"	m	struct:SHEdit::LanguageDefinition::Term	access:public
SHEdit::LanguageDefinition::TokType	uLanguageDefinition2.h	/^      enum TokType {tS, tC, tE};$/;"	g	class:SHEdit::LanguageDefinition	access:private
SHEdit::LanguageDefinition::TreeNode	uLanguageDefinition.h	/^      struct TreeNode$/;"	s	class:SHEdit::LanguageDefinition	access:public
SHEdit::LanguageDefinition::TreeNode::AddJump	uLanguageDefinition.h	/^        void AddJump(short pushmask, short newmask, short newgmask, LangDefJumpType type, TreeNode * to, bool begin, FontStyle *format);$/;"	p	struct:SHEdit::LanguageDefinition::TreeNode	access:public	signature:(short pushmask, short newmask, short newgmask, LangDefJumpType type, TreeNode * to, bool begin, FontStyle *format)
SHEdit::LanguageDefinition::TreeNode::AddPop	uLanguageDefinition.h	/^        void AddPop(short popmask, short newmask, short popcount, bool begin, FontStyle *format);$/;"	p	struct:SHEdit::LanguageDefinition::TreeNode	access:public	signature:(short popmask, short newmask, short popcount, bool begin, FontStyle *format)
SHEdit::LanguageDefinition::TreeNode::Name	uLanguageDefinition.h	/^        wchar_t * Name;$/;"	m	struct:SHEdit::LanguageDefinition::TreeNode	access:public
SHEdit::LanguageDefinition::TreeNode::TreeNode	uLanguageDefinition.h	/^        TreeNode(TreeNode * tree, FontStyle * format);$/;"	p	struct:SHEdit::LanguageDefinition::TreeNode	access:public	signature:(TreeNode * tree, FontStyle * format)
SHEdit::LanguageDefinition::TreeNode::TreeNode	uLanguageDefinition.h	/^        TreeNode(wchar_t c, LangDefSpecType type, FontStyle * format, bool caseSensitive);$/;"	p	struct:SHEdit::LanguageDefinition::TreeNode	access:public	signature:(wchar_t c, LangDefSpecType type, FontStyle * format, bool caseSensitive)
SHEdit::LanguageDefinition::TreeNode::caseSensitive	uLanguageDefinition.h	/^        bool caseSensitive;$/;"	m	struct:SHEdit::LanguageDefinition::TreeNode	access:public
SHEdit::LanguageDefinition::TreeNode::format	uLanguageDefinition.h	/^        FontStyle * format;$/;"	m	struct:SHEdit::LanguageDefinition::TreeNode	access:public
SHEdit::LanguageDefinition::TreeNode::items	uLanguageDefinition.h	/^        std::list<TreeNode*> items;$/;"	m	struct:SHEdit::LanguageDefinition::TreeNode	access:public
SHEdit::LanguageDefinition::TreeNode::jumpcount	uLanguageDefinition.h	/^        short jumpcount;$/;"	m	struct:SHEdit::LanguageDefinition::TreeNode	access:public
SHEdit::LanguageDefinition::TreeNode::jumps	uLanguageDefinition.h	/^        Jump * jumps; \/\/an array$/;"	m	struct:SHEdit::LanguageDefinition::TreeNode	access:public
SHEdit::LanguageDefinition::TreeNode::map	uLanguageDefinition.h	/^        TreeNode * map[128];$/;"	m	struct:SHEdit::LanguageDefinition::TreeNode	access:public
SHEdit::LanguageDefinition::TreeNode::pops	uLanguageDefinition.h	/^        Pop * pops;$/;"	m	struct:SHEdit::LanguageDefinition::TreeNode	access:public
SHEdit::LanguageDefinition::TreeNode::recpopcount	uLanguageDefinition.h	/^        short recpopcount;$/;"	m	struct:SHEdit::LanguageDefinition::TreeNode	access:public
SHEdit::LanguageDefinition::TreeNode::thisItem	uLanguageDefinition.h	/^        wchar_t thisItem;$/;"	m	struct:SHEdit::LanguageDefinition::TreeNode	access:public
SHEdit::LanguageDefinition::TreeNode::type	uLanguageDefinition.h	/^        LangDefSpecType type;$/;"	m	struct:SHEdit::LanguageDefinition::TreeNode	access:public
SHEdit::LanguageDefinition::_AddJump	uLanguageDefinition.h	/^      void _AddJump(bool tobegin, wchar_t * string, FontStyle * format, LangDefJumpType type, TreeNode * at, TreeNode * to, short jumpmask, short newmask, short newgmask); \/*!< Adds a custom jump from "at" tree to "to" tree.*\/$/;"	p	class:SHEdit::LanguageDefinition	access:private	signature:(bool tobegin, wchar_t * string, FontStyle * format, LangDefJumpType type, TreeNode * at, TreeNode * to, short jumpmask, short newmask, short newgmask)
SHEdit::LanguageDefinition::_AddPush	uLanguageDefinition.h	/^      void _AddPush(bool tobegin, wchar_t * string, FontStyle * format, TreeNode * at, TreeNode * to, short pushmask, short newmask, short newgmask);$/;"	p	class:SHEdit::LanguageDefinition	access:private	signature:(bool tobegin, wchar_t * string, FontStyle * format, TreeNode * at, TreeNode * to, short pushmask, short newmask, short newgmask)
SHEdit::LanguageDefinition::allowWhiteSkipping	uLanguageDefinition.h	/^      bool allowWhiteSkipping;$/;"	m	class:SHEdit::LanguageDefinition	access:private
SHEdit::LanguageDefinition::caseSensitive	uLanguageDefinition.h	/^      bool caseSensitive;$/;"	m	class:SHEdit::LanguageDefinition	access:private
SHEdit::LanguageDefinition::defFormat	uLanguageDefinition.h	/^      FontStyle * defFormat;$/;"	m	class:SHEdit::LanguageDefinition	access:private
SHEdit::LanguageDefinition::entering	uLanguageDefinition2.h	/^      Node* entering;$/;"	m	class:SHEdit::LanguageDefinition	access:private
SHEdit::LanguageDefinition::flags	uLanguageDefinition2.h	/^      enum flags {tfCall = 1, tfGetStyle = 2, tfGather = 4, tfGlobal = 8, tfCaseSens = 16, tfEntering = 32};$/;"	g	class:SHEdit::LanguageDefinition	access:public
SHEdit::LanguageDefinition::global	uLanguageDefinition2.h	/^      Node* global;$/;"	m	class:SHEdit::LanguageDefinition	access:private
SHEdit::LanguageDefinition::ids	uLanguageDefinition2.h	/^      int ids;$/;"	m	class:SHEdit::LanguageDefinition	access:private
SHEdit::LanguageDefinition::index	uLanguageDefinition2.h	/^      std::map<std::wstring, Rec> index;$/;"	m	class:SHEdit::LanguageDefinition	access:private
SHEdit::LanguageDefinition::loc	uLanguageDefinition2.h	/^      std::locale loc;$/;"	m	class:SHEdit::LanguageDefinition	access:private
SHEdit::LanguageDefinition::nodes	uLanguageDefinition2.h	/^      std::set<Node*> nodes; \/\/temporary - for construction (and maybe for destruction?)$/;"	m	class:SHEdit::LanguageDefinition	access:private
SHEdit::LanguageDefinition::nonterms	uLanguageDefinition2.h	/^      std::vector<NTerm*> nonterms;$/;"	m	class:SHEdit::LanguageDefinition	access:private
SHEdit::LanguageDefinition::ntEnd	uLanguageDefinition2.h	/^      enum NType {ntTerm, ntNTerm, ntLambda, ntEnd, ntTailrec};$/;"	e	enum:SHEdit::LanguageDefinition::NType
SHEdit::LanguageDefinition::ntLambda	uLanguageDefinition2.h	/^      enum NType {ntTerm, ntNTerm, ntLambda, ntEnd, ntTailrec};$/;"	e	enum:SHEdit::LanguageDefinition::NType
SHEdit::LanguageDefinition::ntNTerm	uLanguageDefinition2.h	/^      enum NType {ntTerm, ntNTerm, ntLambda, ntEnd, ntTailrec};$/;"	e	enum:SHEdit::LanguageDefinition::NType
SHEdit::LanguageDefinition::ntTailrec	uLanguageDefinition2.h	/^      enum NType {ntTerm, ntNTerm, ntLambda, ntEnd, ntTailrec};$/;"	e	enum:SHEdit::LanguageDefinition::NType
SHEdit::LanguageDefinition::ntTerm	uLanguageDefinition2.h	/^      enum NType {ntTerm, ntNTerm, ntLambda, ntEnd, ntTailrec};$/;"	e	enum:SHEdit::LanguageDefinition::NType
SHEdit::LanguageDefinition::tC	uLanguageDefinition2.h	/^      enum TokType {tS, tC, tE};$/;"	e	enum:SHEdit::LanguageDefinition::TokType
SHEdit::LanguageDefinition::tE	uLanguageDefinition2.h	/^      enum TokType {tS, tC, tE};$/;"	e	enum:SHEdit::LanguageDefinition::TokType
SHEdit::LanguageDefinition::tS	uLanguageDefinition2.h	/^      enum TokType {tS, tC, tE};$/;"	e	enum:SHEdit::LanguageDefinition::TokType
SHEdit::LanguageDefinition::terms	uLanguageDefinition2.h	/^      std::vector<Term*> terms;$/;"	m	class:SHEdit::LanguageDefinition	access:private
SHEdit::LanguageDefinition::tfCall	uLanguageDefinition2.h	/^      enum flags {tfCall = 1, tfGetStyle = 2, tfGather = 4, tfGlobal = 8, tfCaseSens = 16, tfEntering = 32};$/;"	e	enum:SHEdit::LanguageDefinition::flags
SHEdit::LanguageDefinition::tfCaseSens	uLanguageDefinition2.h	/^      enum flags {tfCall = 1, tfGetStyle = 2, tfGather = 4, tfGlobal = 8, tfCaseSens = 16, tfEntering = 32};$/;"	e	enum:SHEdit::LanguageDefinition::flags
SHEdit::LanguageDefinition::tfEntering	uLanguageDefinition2.h	/^      enum flags {tfCall = 1, tfGetStyle = 2, tfGather = 4, tfGlobal = 8, tfCaseSens = 16, tfEntering = 32};$/;"	e	enum:SHEdit::LanguageDefinition::flags
SHEdit::LanguageDefinition::tfGather	uLanguageDefinition2.h	/^      enum flags {tfCall = 1, tfGetStyle = 2, tfGather = 4, tfGlobal = 8, tfCaseSens = 16, tfEntering = 32};$/;"	e	enum:SHEdit::LanguageDefinition::flags
SHEdit::LanguageDefinition::tfGetStyle	uLanguageDefinition2.h	/^      enum flags {tfCall = 1, tfGetStyle = 2, tfGather = 4, tfGlobal = 8, tfCaseSens = 16, tfEntering = 32};$/;"	e	enum:SHEdit::LanguageDefinition::flags
SHEdit::LanguageDefinition::tfGlobal	uLanguageDefinition2.h	/^      enum flags {tfCall = 1, tfGetStyle = 2, tfGather = 4, tfGlobal = 8, tfCaseSens = 16, tfEntering = 32};$/;"	e	enum:SHEdit::LanguageDefinition::flags
SHEdit::LanguageDefinition::tokenizer	uLanguageDefinition2.h	/^      WTokenizer tokenizer;$/;"	m	class:SHEdit::LanguageDefinition	access:private
SHEdit::LanguageDefinition::tree	uLanguageDefinition.h	/^      TreeNode * tree;$/;"	m	class:SHEdit::LanguageDefinition	access:private
SHEdit::LanguageDefinition::~LanguageDefinition	uLanguageDefinition.h	/^      ~LanguageDefinition();$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:()
SHEdit::LanguageDefinition::~LanguageDefinition	uLanguageDefinition2.h	/^      ~LanguageDefinition();$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:()
SHEdit::LanguageDefinitionSQL	uLanguageDefinitionSQL.h	/^  class LanguageDefinitionSQL : public LanguageDefinition$/;"	c	namespace:SHEdit	inherits:LanguageDefinition
SHEdit::LanguageDefinitionSQL::LanguageDefinitionSQL	uLanguageDefinitionSQL.h	/^    LanguageDefinitionSQL();$/;"	p	class:SHEdit::LanguageDefinitionSQL	access:public	signature:()
SHEdit::LanguageDefinitionSQL::background	uLanguageDefinitionSQL.h	/^    TColor background;$/;"	m	class:SHEdit::LanguageDefinitionSQL	access:private
SHEdit::LanguageDefinitionSQL::comment	uLanguageDefinitionSQL.h	/^    TColor comment;$/;"	m	class:SHEdit::LanguageDefinitionSQL	access:private
SHEdit::LanguageDefinitionSQL::commentback	uLanguageDefinitionSQL.h	/^    TColor commentback;$/;"	m	class:SHEdit::LanguageDefinitionSQL	access:private
SHEdit::LanguageDefinitionSQL::foreground	uLanguageDefinitionSQL.h	/^    TColor foreground;$/;"	m	class:SHEdit::LanguageDefinitionSQL	access:private
SHEdit::LanguageDefinitionSQL::number	uLanguageDefinitionSQL.h	/^    TColor number ;$/;"	m	class:SHEdit::LanguageDefinitionSQL	access:private
SHEdit::LanguageDefinitionSQL::reserved	uLanguageDefinitionSQL.h	/^    TColor reserved;$/;"	m	class:SHEdit::LanguageDefinitionSQL	access:private
SHEdit::LanguageDefinitionSQL::string	uLanguageDefinitionSQL.h	/^    TColor string ;$/;"	m	class:SHEdit::LanguageDefinitionSQL	access:private
SHEdit::LanguageDefinitionSQL::variable	uLanguageDefinitionSQL.h	/^    TColor variable;$/;"	m	class:SHEdit::LanguageDefinitionSQL	access:private
SHEdit::LanguageDefinitionWebLangs	uLanguageDefinitionWebLangs.h	/^  class LanguageDefinitionWebLangs : public LanguageDefinition$/;"	c	namespace:SHEdit	inherits:LanguageDefinition
SHEdit::LanguageDefinitionWebLangs::AddPops	uLanguageDefinitionWebLangs.h	/^      void AddPops(TreeNode * at);$/;"	p	class:SHEdit::LanguageDefinitionWebLangs	access:private	signature:(TreeNode * at)
SHEdit::LanguageDefinitionWebLangs::AddSafetyJumps	uLanguageDefinitionWebLangs.h	/^      void AddSafetyJumps();$/;"	p	class:SHEdit::LanguageDefinitionWebLangs	access:private	signature:()
SHEdit::LanguageDefinitionWebLangs::ConstructCss	uLanguageDefinitionWebLangs.h	/^      void ConstructCss(TreeNode * at,  TColor * bg, TColor * fg);$/;"	p	class:SHEdit::LanguageDefinitionWebLangs	access:private	signature:(TreeNode * at, TColor * bg, TColor * fg)
SHEdit::LanguageDefinitionWebLangs::ConstructHtml	uLanguageDefinitionWebLangs.h	/^      void ConstructHtml(TreeNode * at, TColor * bg, TColor * fg);$/;"	p	class:SHEdit::LanguageDefinitionWebLangs	access:private	signature:(TreeNode * at, TColor * bg, TColor * fg)
SHEdit::LanguageDefinitionWebLangs::ConstructJavascript	uLanguageDefinitionWebLangs.h	/^      void ConstructJavascript(TreeNode * at, TColor * bg, TColor * fg);$/;"	p	class:SHEdit::LanguageDefinitionWebLangs	access:private	signature:(TreeNode * at, TColor * bg, TColor * fg)
SHEdit::LanguageDefinitionWebLangs::ConstructPhp	uLanguageDefinitionWebLangs.h	/^      void ConstructPhp(TreeNode * at,  TColor * bg, TColor * fg);$/;"	p	class:SHEdit::LanguageDefinitionWebLangs	access:private	signature:(TreeNode * at, TColor * bg, TColor * fg)
SHEdit::LanguageDefinitionWebLangs::LanguageDefinitionWebLangs	uLanguageDefinitionWebLangs.h	/^      LanguageDefinitionWebLangs();$/;"	p	class:SHEdit::LanguageDefinitionWebLangs	access:public	signature:()
SHEdit::LanguageDefinitionWebLangs::cssAttr	uLanguageDefinitionWebLangs.h	/^      TColor cssAttr;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
SHEdit::LanguageDefinitionWebLangs::cssBG	uLanguageDefinitionWebLangs.h	/^      TColor cssBG;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
SHEdit::LanguageDefinitionWebLangs::cssEnterTree	uLanguageDefinitionWebLangs.h	/^      TreeNode * cssEnterTree;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
SHEdit::LanguageDefinitionWebLangs::cssFG	uLanguageDefinitionWebLangs.h	/^      TColor cssFG;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
SHEdit::LanguageDefinitionWebLangs::cssPropertyTree	uLanguageDefinitionWebLangs.h	/^      TreeNode * cssPropertyTree;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
SHEdit::LanguageDefinitionWebLangs::cssQuoteTree	uLanguageDefinitionWebLangs.h	/^      TreeNode * cssQuoteTree;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
SHEdit::LanguageDefinitionWebLangs::cssTree	uLanguageDefinitionWebLangs.h	/^      TreeNode * cssTree;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
SHEdit::LanguageDefinitionWebLangs::cssVal	uLanguageDefinitionWebLangs.h	/^      TColor cssVal;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
SHEdit::LanguageDefinitionWebLangs::cssValueTree	uLanguageDefinitionWebLangs.h	/^      TreeNode * cssValueTree;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
SHEdit::LanguageDefinitionWebLangs::htmlAttribs	uLanguageDefinitionWebLangs.h	/^      TColor htmlAttribs;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
SHEdit::LanguageDefinitionWebLangs::htmlBG	uLanguageDefinitionWebLangs.h	/^      TColor htmlBG;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
SHEdit::LanguageDefinitionWebLangs::htmlCommentTree	uLanguageDefinitionWebLangs.h	/^      TreeNode * htmlCommentTree;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
SHEdit::LanguageDefinitionWebLangs::htmlComments	uLanguageDefinitionWebLangs.h	/^      TColor htmlComments;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
SHEdit::LanguageDefinitionWebLangs::htmlFG	uLanguageDefinitionWebLangs.h	/^      TColor htmlFG;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
SHEdit::LanguageDefinitionWebLangs::htmlQuoteTree	uLanguageDefinitionWebLangs.h	/^      TreeNode * htmlQuoteTree;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
SHEdit::LanguageDefinitionWebLangs::htmlQuotes	uLanguageDefinitionWebLangs.h	/^      TColor htmlQuotes;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
SHEdit::LanguageDefinitionWebLangs::htmlTagTree	uLanguageDefinitionWebLangs.h	/^      TreeNode * htmlTagTree;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
SHEdit::LanguageDefinitionWebLangs::htmlTags	uLanguageDefinitionWebLangs.h	/^      TColor htmlTags;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
SHEdit::LanguageDefinitionWebLangs::htmlTree	uLanguageDefinitionWebLangs.h	/^      TreeNode * htmlTree;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
SHEdit::LanguageDefinitionWebLangs::jvBG	uLanguageDefinitionWebLangs.h	/^      TColor jvBG;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
SHEdit::LanguageDefinitionWebLangs::jvCommentTree	uLanguageDefinitionWebLangs.h	/^      TreeNode * jvCommentTree;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
SHEdit::LanguageDefinitionWebLangs::jvComments	uLanguageDefinitionWebLangs.h	/^      TColor jvComments;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
SHEdit::LanguageDefinitionWebLangs::jvEnterTree	uLanguageDefinitionWebLangs.h	/^      TreeNode * jvEnterTree;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
SHEdit::LanguageDefinitionWebLangs::jvFG	uLanguageDefinitionWebLangs.h	/^      TColor jvFG;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
SHEdit::LanguageDefinitionWebLangs::jvKeywords	uLanguageDefinitionWebLangs.h	/^      TColor jvKeywords;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
SHEdit::LanguageDefinitionWebLangs::jvLineCommentTree	uLanguageDefinitionWebLangs.h	/^      TreeNode * jvLineCommentTree;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
SHEdit::LanguageDefinitionWebLangs::jvQuoteTree	uLanguageDefinitionWebLangs.h	/^      TreeNode * jvQuoteTree;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
SHEdit::LanguageDefinitionWebLangs::jvQuotes	uLanguageDefinitionWebLangs.h	/^      TColor jvQuotes;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
SHEdit::LanguageDefinitionWebLangs::jvTree	uLanguageDefinitionWebLangs.h	/^      TreeNode * jvTree;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
SHEdit::LanguageDefinitionWebLangs::phpBG	uLanguageDefinitionWebLangs.h	/^      TColor phpBG;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
SHEdit::LanguageDefinitionWebLangs::phpCommentTree	uLanguageDefinitionWebLangs.h	/^      TreeNode * phpCommentTree;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
SHEdit::LanguageDefinitionWebLangs::phpComments	uLanguageDefinitionWebLangs.h	/^      TColor phpComments;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
SHEdit::LanguageDefinitionWebLangs::phpFG	uLanguageDefinitionWebLangs.h	/^      TColor phpFG;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
SHEdit::LanguageDefinitionWebLangs::phpHtmlEnterTree	uLanguageDefinitionWebLangs.h	/^      TreeNode * phpHtmlEnterTree;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
SHEdit::LanguageDefinitionWebLangs::phpKeywords	uLanguageDefinitionWebLangs.h	/^      TColor phpKeywords;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
SHEdit::LanguageDefinitionWebLangs::phpLineCommentTree	uLanguageDefinitionWebLangs.h	/^      TreeNode * phpLineCommentTree;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
SHEdit::LanguageDefinitionWebLangs::phpQuoteTree	uLanguageDefinitionWebLangs.h	/^      TreeNode * phpQuoteTree;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
SHEdit::LanguageDefinitionWebLangs::phpQuotes	uLanguageDefinitionWebLangs.h	/^      TColor phpQuotes;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
SHEdit::LanguageDefinitionWebLangs::phpQuotesBack	uLanguageDefinitionWebLangs.h	/^      TColor phpQuotesBack;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
SHEdit::LanguageDefinitionWebLangs::phpReserved	uLanguageDefinitionWebLangs.h	/^      TColor phpReserved;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
SHEdit::LanguageDefinitionWebLangs::phpTree	uLanguageDefinitionWebLangs.h	/^      TreeNode * phpTree;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
SHEdit::LanguageDefinitionWebLangs::phpVariable	uLanguageDefinitionWebLangs.h	/^      TColor phpVariable;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
SHEdit::LineTag	uLanguageDefinition.h	/^  enum LangDefSpecType{Empty = 0x1, Nomatch = 0x2, Normal=0x4, Jump=0x8, WordTag=0x20, LineTag=0x40, Lookahead = 0x80};$/;"	e	enum:SHEdit::LangDefSpecType
SHEdit::Lookahead	uLanguageDefinition.h	/^  enum LangDefSpecType{Empty = 0x1, Nomatch = 0x2, Normal=0x4, Jump=0x8, WordTag=0x20, LineTag=0x40, Lookahead = 0x80};$/;"	e	enum:SHEdit::LangDefSpecType
SHEdit::Mark	uMark.h	/^  class Mark$/;"	c	namespace:SHEdit
SHEdit::Mark::Mark	uMark.h	/^      Mark(Format * format, bool begin, short pos);$/;"	p	class:SHEdit::Mark	access:public	signature:(Format * format, bool begin, short pos)
SHEdit::Mark::begin	uMark.h	/^      bool begin;$/;"	m	class:SHEdit::Mark	access:public
SHEdit::Mark::format	uMark.h	/^      Format * format;$/;"	m	class:SHEdit::Mark	access:public
SHEdit::Mark::pos	uMark.h	/^      short pos;$/;"	m	class:SHEdit::Mark	access:public
SHEdit::NSpan	uSpan.h	/^  struct NSpan : Span$/;"	s	namespace:SHEdit	inherits:Span
SHEdit::NSpan::NSpan	uSpan.h	/^    NSpan();$/;"	p	struct:SHEdit::NSpan	access:public	signature:()
SHEdit::NSpan::NSpan	uSpan.h	/^    NSpan(Iter * After);$/;"	p	struct:SHEdit::NSpan	access:public	signature:(Iter * After)
SHEdit::NSpan::NSpan	uSpan.h	/^    NSpan(Span* afterword, NSpan* afterline);$/;"	p	struct:SHEdit::NSpan	access:public	signature:(Span* afterword, NSpan* afterline)
SHEdit::NSpan::nextline	uSpan.h	/^    NSpan * nextline;$/;"	m	struct:SHEdit::NSpan	access:public
SHEdit::NSpan::parserState	uSpan.h	/^    Parser::ParserState parserState;$/;"	m	struct:SHEdit::NSpan	access:public
SHEdit::NSpan::prevline	uSpan.h	/^    NSpan * prevline;$/;"	m	struct:SHEdit::NSpan	access:public
SHEdit::NSpan::~NSpan	uSpan.h	/^    ~NSpan();$/;"	p	struct:SHEdit::NSpan	access:public	signature:()
SHEdit::Nomatch	uLanguageDefinition.h	/^  enum LangDefSpecType{Empty = 0x1, Nomatch = 0x2, Normal=0x4, Jump=0x8, WordTag=0x20, LineTag=0x40, Lookahead = 0x80};$/;"	e	enum:SHEdit::LangDefSpecType
SHEdit::Normal	uLanguageDefinition.h	/^  enum LangDefSpecType{Empty = 0x1, Nomatch = 0x2, Normal=0x4, Jump=0x8, WordTag=0x20, LineTag=0x40, Lookahead = 0x80};$/;"	e	enum:SHEdit::LangDefSpecType
SHEdit::Parser	uParser.h	/^  class Parser$/;"	c	namespace:SHEdit
SHEdit::Parser::AddChar	uParser.h	/^      void AddChar(Iter * itr, int & pos);$/;"	p	class:SHEdit::Parser	access:private	signature:(Iter * itr, int & pos)
SHEdit::Parser::CanGoFurther	uParser.h	/^      bool CanGoFurther(LanguageDefinition::SearchIter sit, Iter * itr, bool inword, bool checkbefore = false, bool recursive = false);$/;"	p	class:SHEdit::Parser	access:private	signature:(LanguageDefinition::SearchIter sit, Iter * itr, bool inword, bool checkbefore = false, bool recursive = false)
SHEdit::Parser::CheckMarkup	uParser.h	/^      inline void CheckMarkup(Iter * itr, bool paint);$/;"	p	class:SHEdit::Parser	access:private	signature:(Iter * itr, bool paint)
SHEdit::Parser::Draw	uParser.h	/^      void __fastcall Draw();$/;"	p	class:SHEdit::Parser	access:private	signature:()
SHEdit::Parser::DumpStackState	uParser.h	/^      void DumpStackState();$/;"	p	class:SHEdit::Parser	access:private	signature:()
SHEdit::Parser::Execute	uParser.h	/^      bool __fastcall Execute(bool paint = true);$/;"	p	class:SHEdit::Parser	access:public	signature:(bool paint = true)
SHEdit::Parser::Flush	uParser.h	/^      void Flush();$/;"	p	class:SHEdit::Parser	access:private	signature:()
SHEdit::Parser::FlushAll	uParser.h	/^      void FlushAll();$/;"	p	class:SHEdit::Parser	access:private	signature:()
SHEdit::Parser::GetLangDef	uParser.h	/^      LanguageDefinition* GetLangDef();$/;"	p	class:SHEdit::Parser	access:public	signature:()
SHEdit::Parser::InvalidateAll	uParser.h	/^      void InvalidateAll();$/;"	p	class:SHEdit::Parser	access:public	signature:()
SHEdit::Parser::OnIdle	uParser.h	/^      void __fastcall OnIdle(TObject * Sender, bool& Done);$/;"	p	class:SHEdit::Parser	access:public	signature:(TObject * Sender, bool& Done)
SHEdit::Parser::ParseFromLine	uParser.h	/^      void ParseFromLine(NSpan * line, int linenum, int prior);$/;"	p	class:SHEdit::Parser	access:public	signature:(NSpan * line, int linenum, int prior)
SHEdit::Parser::ParseFromToLine	uParser.h	/^      void ParseFromToLine(NSpan * line, int linenum, int count, int prior);$/;"	p	class:SHEdit::Parser	access:public	signature:(NSpan * line, int linenum, int count, int prior)
SHEdit::Parser::ParseLine	uParser.h	/^      void ParseLine(Iter * itr, LanguageDefinition::SearchIter * searchiter, bool paint);$/;"	p	class:SHEdit::Parser	access:private	signature:(Iter * itr, LanguageDefinition::SearchIter * searchiter, bool paint)
SHEdit::Parser::ParseTask	uParser.h	/^      struct ParseTask$/;"	s	class:SHEdit::Parser	access:public
SHEdit::Parser::ParseTask::ParseTask	uParser.h	/^        ParseTask();$/;"	p	struct:SHEdit::Parser::ParseTask	access:public	signature:()
SHEdit::Parser::ParseTask::ParseTask	uParser.h	/^        ParseTask(NSpan * line, int linenum);$/;"	p	struct:SHEdit::Parser::ParseTask	access:public	signature:(NSpan * line, int linenum)
SHEdit::Parser::ParseTask::line	uParser.h	/^        NSpan * line;$/;"	m	struct:SHEdit::Parser::ParseTask	access:public
SHEdit::Parser::ParseTask::linenum	uParser.h	/^        int linenum;$/;"	m	struct:SHEdit::Parser::ParseTask	access:public
SHEdit::Parser::ParseTask::operator <	uParser.h	/^        bool operator<(const ParseTask & pt)const;$/;"	p	struct:SHEdit::Parser::ParseTask	access:public	signature:(const ParseTask & pt) const
SHEdit::Parser::ParseTask::operator ==	uParser.h	/^        bool operator==(const ParseTask & pt)const;$/;"	p	struct:SHEdit::Parser::ParseTask	access:public	signature:(const ParseTask & pt) const
SHEdit::Parser::Parser	uParser.h	/^      __fastcall Parser(TSHEdit * parent, Drawer * drawer);$/;"	p	class:SHEdit::Parser	access:public	signature:(TSHEdit * parent, Drawer * drawer)
SHEdit::Parser::ParserState	uParser.h	/^      struct ParserState$/;"	s	class:SHEdit::Parser	access:public
SHEdit::Parser::ParserState::InitBanks	uParser.h	/^        void InitBanks(int count);$/;"	p	struct:SHEdit::Parser::ParserState	access:public	signature:(int count)
SHEdit::Parser::ParserState::ParserState	uParser.h	/^        ParserState();$/;"	p	struct:SHEdit::Parser::ParserState	access:public	signature:()
SHEdit::Parser::ParserState::globalMask	uParser.h	/^        short globalMask;$/;"	m	struct:SHEdit::Parser::ParserState	access:public
SHEdit::Parser::ParserState::markupStack	uParser.h	/^        Stack<Format*> markupStack;$/;"	m	struct:SHEdit::Parser::ParserState	access:public
SHEdit::Parser::ParserState::operator !=	uParser.h	/^        bool operator!=(const ParserState& state);$/;"	p	struct:SHEdit::Parser::ParserState	access:public	signature:(const ParserState& state)
SHEdit::Parser::ParserState::operator =	uParser.h	/^        ParserState& operator=(const ParserState& p);$/;"	p	struct:SHEdit::Parser::ParserState	access:public	signature:(const ParserState& p)
SHEdit::Parser::ParserState::operator ==	uParser.h	/^        bool operator==(const ParserState& state);$/;"	p	struct:SHEdit::Parser::ParserState	access:public	signature:(const ParserState& state)
SHEdit::Parser::ParserState::parseid	uParser.h	/^        short parseid;$/;"	m	struct:SHEdit::Parser::ParserState	access:public
SHEdit::Parser::ParserState::searchStateStack	uParser.h	/^        Stack<LanguageDefinition::SearchIter> searchStateStack;$/;"	m	struct:SHEdit::Parser::ParserState	access:public
SHEdit::Parser::ParserState::~ParserState	uParser.h	/^        ~ParserState();$/;"	p	struct:SHEdit::Parser::ParserState	access:public	signature:()
SHEdit::Parser::PerformJumpPush	uParser.h	/^      void PerformJumpPush(LanguageDefinition::SearchIter *& sit);$/;"	p	class:SHEdit::Parser	access:private	signature:(LanguageDefinition::SearchIter *& sit)
SHEdit::Parser::PerformPop	uParser.h	/^      bool PerformPop(LanguageDefinition::SearchIter *& sit);$/;"	p	class:SHEdit::Parser	access:private	signature:(LanguageDefinition::SearchIter *& sit)
SHEdit::Parser::ReconstructMarkup	uParser.h	/^      void ReconstructMarkup();                                                                      \/*!< Reconstructs ActMarkup (that holds positionless markup). Does not update actMarkupCombined. *\/$/;"	p	class:SHEdit::Parser	access:private	signature:()
SHEdit::Parser::SendEof	uParser.h	/^      void SendEof();$/;"	p	class:SHEdit::Parser	access:private	signature:()
SHEdit::Parser::SetLangDef	uParser.h	/^      void SetLangDef(LanguageDefinition * langdef);$/;"	p	class:SHEdit::Parser	access:public	signature:(LanguageDefinition * langdef)
SHEdit::Parser::Write	uParser.h	/^      void Write(AnsiString message);$/;"	p	class:SHEdit::Parser	access:private	signature:(AnsiString message)
SHEdit::Parser::actFormat	uParser.h	/^      FontStyle actFormat;$/;"	m	class:SHEdit::Parser	access:private
SHEdit::Parser::actIMarkup	uParser.h	/^      FontStyle actIMarkup;$/;"	m	class:SHEdit::Parser	access:private
SHEdit::Parser::actMarkup	uParser.h	/^      FontStyle actMarkup;$/;"	m	class:SHEdit::Parser	access:private
SHEdit::Parser::actMarkupCombined	uParser.h	/^      FontStyle actMarkupCombined;$/;"	m	class:SHEdit::Parser	access:private
SHEdit::Parser::actText	uParser.h	/^      String actText;$/;"	m	class:SHEdit::Parser	access:private
SHEdit::Parser::currentparseid	uParser.h	/^      short currentparseid;$/;"	m	class:SHEdit::Parser	access:private
SHEdit::Parser::dbgLogging	uParser.h	/^      bool dbgLogging;$/;"	m	class:SHEdit::Parser	access:public
SHEdit::Parser::dbgscb	uParser.h	/^      int dbgscb;$/;"	m	class:SHEdit::Parser	access:private
SHEdit::Parser::drawer	uParser.h	/^      Drawer * drawer;$/;"	m	class:SHEdit::Parser	access:private
SHEdit::Parser::inword	uParser.h	/^      bool inword;$/;"	m	class:SHEdit::Parser	access:private
SHEdit::Parser::langdef	uParser.h	/^      LanguageDefinition * langdef;$/;"	m	class:SHEdit::Parser	access:private
SHEdit::Parser::linenum	uParser.h	/^      short linenum;$/;"	m	class:SHEdit::Parser	access:private
SHEdit::Parser::newline	uParser.h	/^      bool newline;$/;"	m	class:SHEdit::Parser	access:private
SHEdit::Parser::oldidle	uParser.h	/^      TIdleEvent oldidle;$/;"	m	class:SHEdit::Parser	access:private
SHEdit::Parser::onidleset	uParser.h	/^      bool onidleset;$/;"	m	class:SHEdit::Parser	access:private
SHEdit::Parser::parent	uParser.h	/^      TSHEdit * parent;$/;"	m	class:SHEdit::Parser	access:private
SHEdit::Parser::recurse	uParser.h	/^      int recurse;$/;"	m	class:SHEdit::Parser	access:private
SHEdit::Parser::state	uParser.h	/^      ParserState state;$/;"	m	class:SHEdit::Parser	access:private
SHEdit::Parser::tasklist	uParser.h	/^      std::list<ParseTask> tasklist;$/;"	m	class:SHEdit::Parser	access:private
SHEdit::Parser::tasklistprior	uParser.h	/^      std::list<ParseTask> tasklistprior;$/;"	m	class:SHEdit::Parser	access:private
SHEdit::Parser::upperbound	uParser.h	/^      int upperbound;$/;"	m	class:SHEdit::Parser	access:private
SHEdit::Parser::~Parser	uParser.h	/^      virtual __fastcall ~Parser();$/;"	p	class:SHEdit::Parser	access:public	signature:()
SHEdit::ProcessKeyCall	cSHEdit.cpp	/^LRESULT CALLBACK SHEdit::ProcessKeyCall(int code, WPARAM wParam, LPARAM lParam)$/;"	f	class:SHEdit	signature:(int code, WPARAM wParam, LPARAM lParam)
SHEdit::ProcessKeyCall	cSHEdit.h	/^  LRESULT CALLBACK ProcessKeyCall(int code, WPARAM wParam, LPARAM lParam);$/;"	p	namespace:SHEdit	signature:(int code, WPARAM wParam, LPARAM lParam)
SHEdit::Range	uSpan.h	/^  struct Range$/;"	s	namespace:SHEdit
SHEdit::Range::Free	uSpan.h	/^    void Free(); \/\/destructor shall not destroy data it holds, but free shoul$/;"	p	struct:SHEdit::Range	access:public	signature:()
SHEdit::Range::Range	uSpan.h	/^    Range(Span * first, Span * last, bool empty, NSpan * firstLine, NSpan * lastLine, bool lineempty, int linecount);$/;"	p	struct:SHEdit::Range	access:public	signature:(Span * first, Span * last, bool empty, NSpan * firstLine, NSpan * lastLine, bool lineempty, int linecount)
SHEdit::Range::empty	uSpan.h	/^    bool empty;$/;"	m	struct:SHEdit::Range	access:public
SHEdit::Range::first	uSpan.h	/^    Span* first;$/;"	m	struct:SHEdit::Range	access:public
SHEdit::Range::firstLine	uSpan.h	/^    NSpan* firstLine;$/;"	m	struct:SHEdit::Range	access:public
SHEdit::Range::last	uSpan.h	/^    Span* last;$/;"	m	struct:SHEdit::Range	access:public
SHEdit::Range::lastLine	uSpan.h	/^    NSpan* lastLine;$/;"	m	struct:SHEdit::Range	access:public
SHEdit::Range::linecount	uSpan.h	/^    int linecount;$/;"	m	struct:SHEdit::Range	access:public
SHEdit::Range::lineempty	uSpan.h	/^    bool lineempty;$/;"	m	struct:SHEdit::Range	access:public
SHEdit::Range::~Range	uSpan.h	/^    ~Range();$/;"	p	struct:SHEdit::Range	access:public	signature:()
SHEdit::Span	uSpan.h	/^  struct Span$/;"	s	namespace:SHEdit
SHEdit::Span::Span	uSpan.h	/^    Span();$/;"	p	struct:SHEdit::Span	access:public	signature:()
SHEdit::Span::Span	uSpan.h	/^    Span(Iter * After);$/;"	p	struct:SHEdit::Span	access:public	signature:(Iter * After)
SHEdit::Span::Span	uSpan.h	/^    Span(Span * afterword);$/;"	p	struct:SHEdit::Span	access:public	signature:(Span * afterword)
SHEdit::Span::Span	uSpan.h	/^    Span(Span * prev, Span * next, wchar_t* string, short length);$/;"	p	struct:SHEdit::Span	access:public	signature:(Span * prev, Span * next, wchar_t* string, short length)
SHEdit::Span::length	uSpan.h	/^    short length;$/;"	m	struct:SHEdit::Span	access:public
SHEdit::Span::marks	uSpan.h	/^    Stack<Mark> marks;$/;"	m	struct:SHEdit::Span	access:public
SHEdit::Span::next	uSpan.h	/^    Span* next;$/;"	m	struct:SHEdit::Span	access:public
SHEdit::Span::prev	uSpan.h	/^    Span* prev;$/;"	m	struct:SHEdit::Span	access:public
SHEdit::Span::string	uSpan.h	/^    wchar_t* string;$/;"	m	struct:SHEdit::Span	access:public
SHEdit::Span::~Span	uSpan.h	/^    ~Span();$/;"	p	struct:SHEdit::Span	access:public	signature:()
SHEdit::TKeyEvent	cSHEdit.h	/^  typedef void __fastcall (__closure *TKeyEvent)(System::TObject* Sender, System::Word &Key, Classes::TShiftState Shift);$/;"	t	namespace:SHEdit
SHEdit::TKeyPressEvent	cSHEdit.h	/^  typedef void __fastcall (__closure *TKeyPressEvent)(System::TObject* Sender, System::WideChar &Key);$/;"	t	namespace:SHEdit
SHEdit::TMessage	cSHEdit.h	/^  typedef void __fastcall (__closure *TMessage)(System::TObject* Sender);$/;"	t	namespace:SHEdit
SHEdit::TMouseEvent	cSHEdit.h	/^  typedef void __fastcall (__closure *TMouseEvent)(System::TObject* Sender, TMouseButton Button, Classes::TShiftState Shift, int X, int Y);$/;"	t	namespace:SHEdit
SHEdit::TSHEdit	cSHEdit.h	/^  class PACKAGE TSHEdit : public TCustomControl$/;"	c	namespace:SHEdit	inherits:TCustomControl
SHEdit::TSHEdit::Action	cSHEdit.h	/^      void Action(String name, bool end = true);$/;"	p	class:SHEdit::TSHEdit	access:private	signature:(String name, bool end = true)
SHEdit::TSHEdit::AddLine	cSHEdit.h	/^      void AddLine(const String& string, Format * format = NULL);$/;"	p	class:SHEdit::TSHEdit	access:public	signature:(const String& string, Format * format = NULL)
SHEdit::TSHEdit::AddLines	cSHEdit.h	/^      void AddLines(const String& string, Format * format = NULL);$/;"	p	class:SHEdit::TSHEdit	access:public	signature:(const String& string, Format * format = NULL)
SHEdit::TSHEdit::AdjustLine	cSHEdit.h	/^      void AdjustLine(bool paint, bool fromtop = true);$/;"	p	class:SHEdit::TSHEdit	access:public	signature:(bool paint, bool fromtop = true)
SHEdit::TSHEdit::Align	cSHEdit.h	/^      __property TAlign Align = {read=FAlign, write=SetAlign, default=0};$/;"	m	class:SHEdit::TSHEdit	access:public
SHEdit::TSHEdit::CheckIntegrity	cSHEdit.h	/^      void CheckIntegrity();$/;"	p	class:SHEdit::TSHEdit	access:public	signature:()
SHEdit::TSHEdit::CheckIterIntegrity	cSHEdit.h	/^      void CheckIterIntegrity(Iter * itr);$/;"	p	class:SHEdit::TSHEdit	access:public	signature:(Iter * itr)
SHEdit::TSHEdit::Clear	cSHEdit.h	/^      void Clear();$/;"	p	class:SHEdit::TSHEdit	access:public	signature:()
SHEdit::TSHEdit::Copy	cSHEdit.h	/^      void Copy();$/;"	p	class:SHEdit::TSHEdit	access:public	signature:()
SHEdit::TSHEdit::DeleteSel	cSHEdit.h	/^      void DeleteSel(bool allowsync = true, Iter * start = NULL, Iter * end = NULL);                 \/*!< Handles all deletion tasks (except load file). If start or end are NULL, then the deletion is performed on the selection*\/$/;"	p	class:SHEdit::TSHEdit	access:protected	signature:(bool allowsync = true, Iter * start = NULL, Iter * end = NULL)
SHEdit::TSHEdit::Escape	cSHEdit.h	/^      String Escape(String str);    \/\/debug as well$/;"	p	class:SHEdit::TSHEdit	access:public	signature:(String str)
SHEdit::TSHEdit::FOnChange	cSHEdit.h	/^      TMessage FOnChange;$/;"	m	class:SHEdit::TSHEdit	access:protected
SHEdit::TSHEdit::FOnClick	cSHEdit.h	/^      TMessage FOnClick;$/;"	m	class:SHEdit::TSHEdit	access:protected
SHEdit::TSHEdit::FOnEnter	cSHEdit.h	/^      TMessage FOnEnter;$/;"	m	class:SHEdit::TSHEdit	access:protected
SHEdit::TSHEdit::FOnExit	cSHEdit.h	/^      TMessage FOnExit;$/;"	m	class:SHEdit::TSHEdit	access:protected
SHEdit::TSHEdit::FOnKeyDown	cSHEdit.h	/^      TKeyEvent FOnKeyDown;$/;"	m	class:SHEdit::TSHEdit	access:protected
SHEdit::TSHEdit::FOnKeyPress	cSHEdit.h	/^      TKeyPressEvent FOnKeyPress;$/;"	m	class:SHEdit::TSHEdit	access:protected
SHEdit::TSHEdit::FOnKeyUp	cSHEdit.h	/^      TKeyEvent FOnKeyUp;$/;"	m	class:SHEdit::TSHEdit	access:protected
SHEdit::TSHEdit::FOnMouseUp	cSHEdit.h	/^      TMouseEvent FOnMouseUp;$/;"	m	class:SHEdit::TSHEdit	access:protected
SHEdit::TSHEdit::FontSize	cSHEdit.h	/^      __property int FontSize = {read=GetFontsize, write=SetFontsize, default=DEFONTSIZE};$/;"	m	class:SHEdit::TSHEdit	access:public
SHEdit::TSHEdit::GetActLine	cSHEdit.h	/^      int __fastcall GetActLine();                                                                   \/*!< returns line number of cursor (absolute position in buffer)*\/$/;"	p	class:SHEdit::TSHEdit	access:public	signature:()
SHEdit::TSHEdit::GetCursor	cSHEdit.h	/^      CIter GetCursor();                                                                             \/*!< CIter returns a copy of the cursor (or selection start) Iter wrapped in a CIter instance. The CIter always behaves as a valid Iterator, and takes care of making changes to the canvas.*\/$/;"	p	class:SHEdit::TSHEdit	access:public	signature:()
SHEdit::TSHEdit::GetCursorBegin	cSHEdit.h	/^      CIter GetCursorBegin();                                                                        \/*!< CIter returns a copy of the cursor (or selection start) Iter wrapped in a CIter instance. The CIter always behaves as a valid Iterator, and takes care of making changes to the canvas.*\/$/;"	p	class:SHEdit::TSHEdit	access:public	signature:()
SHEdit::TSHEdit::GetCursorCaretX	cSHEdit.h	/^      int GetCursorCaretX();$/;"	p	class:SHEdit::TSHEdit	access:public	signature:()
SHEdit::TSHEdit::GetCursorCaretY	cSHEdit.h	/^      int GetCursorCaretY();$/;"	p	class:SHEdit::TSHEdit	access:public	signature:()
SHEdit::TSHEdit::GetCursorEnd	cSHEdit.h	/^      CIter GetCursorEnd();                                                                          \/*!< CIter returns a copy of the cursor (or selection end) Iter wrapped in a CIter instance. The CIter always behaves as a valid Iterator, and takes care of making changes to the canvas.*\/$/;"	p	class:SHEdit::TSHEdit	access:public	signature:()
SHEdit::TSHEdit::GetCursorIter	cSHEdit.h	/^      Iter * GetCursorIter();                                                                        \/*!< If part of text is selected, returns pointer to the beginning of selection (or cursor, if nothing is selected). Pointer points to the component's private iterator - do not modify it unless you know what you are doing. *\/$/;"	p	class:SHEdit::TSHEdit	access:public	signature:()
SHEdit::TSHEdit::GetCursorIterEnd	cSHEdit.h	/^      Iter * GetCursorIterEnd();                                                                     \/*!< If part of text is selected, returns pointer to the end of selection (or NULL, if nothing is selected). Pointer points to the component's private iterator - do not modify it unless you know what you are doing. *\/$/;"	p	class:SHEdit::TSHEdit	access:public	signature:()
SHEdit::TSHEdit::GetCursorX	cSHEdit.h	/^      int GetCursorX();$/;"	p	class:SHEdit::TSHEdit	access:public	signature:()
SHEdit::TSHEdit::GetCursorY	cSHEdit.h	/^      int GetCursorY();$/;"	p	class:SHEdit::TSHEdit	access:public	signature:()
SHEdit::TSHEdit::GetFontsize	cSHEdit.h	/^      int __fastcall GetFontsize();$/;"	p	class:SHEdit::TSHEdit	access:public	signature:()
SHEdit::TSHEdit::GetKeepHistory	cSHEdit.h	/^      bool __fastcall GetKeepHistory();$/;"	p	class:SHEdit::TSHEdit	access:public	signature:()
SHEdit::TSHEdit::GetLanguageDefinition	cSHEdit.h	/^      LanguageDefinition* __fastcall GetLanguageDefinition();$/;"	p	class:SHEdit::TSHEdit	access:public	signature:()
SHEdit::TSHEdit::GetLine	cSHEdit.h	/^      String GetLine(Iter* itr);$/;"	p	class:SHEdit::TSHEdit	access:public	signature:(Iter* itr)
SHEdit::TSHEdit::GetLine	cSHEdit.h	/^      String GetLine(int index);$/;"	p	class:SHEdit::TSHEdit	access:public	signature:(int index)
SHEdit::TSHEdit::GetLineByNum	cSHEdit.h	/^      Iter __fastcall GetLineByNum(int num);                                                         \/*!< returns iterator of line numth visible line*\/$/;"	p	class:SHEdit::TSHEdit	access:protected	signature:(int num)
SHEdit::TSHEdit::GetLineByNum	cSHEdit.h	/^      Iter __fastcall GetLineByNum(int num, bool allowEnd);                                          \/*!< returns iterator of line numth visible line*\/$/;"	p	class:SHEdit::TSHEdit	access:protected	signature:(int num, bool allowEnd)
SHEdit::TSHEdit::GetLineCount	cSHEdit.h	/^      int __fastcall GetLineCount();$/;"	p	class:SHEdit::TSHEdit	access:public	signature:()
SHEdit::TSHEdit::GetLineHeight	cSHEdit.h	/^      int __fastcall GetLineHeight();$/;"	p	class:SHEdit::TSHEdit	access:public	signature:()
SHEdit::TSHEdit::GetLineNum	cSHEdit.h	/^      int __fastcall GetLineNum(NSpan * line);                                                       \/*!< Returns line number relative to the first visible line. Relic of a positionless handling*\/$/;"	p	class:SHEdit::TSHEdit	access:protected	signature:(NSpan * line)
SHEdit::TSHEdit::GetLinenumsEnabled	cSHEdit.h	/^      bool __fastcall GetLinenumsEnabled();$/;"	p	class:SHEdit::TSHEdit	access:public	signature:()
SHEdit::TSHEdit::GetRange	cSHEdit.h	/^      String GetRange(Iter * begin, Iter * end);$/;"	p	class:SHEdit::TSHEdit	access:public	signature:(Iter * begin, Iter * end)
SHEdit::TSHEdit::GetScrollStep	cSHEdit.h	/^      int GetScrollStep();$/;"	p	class:SHEdit::TSHEdit	access:private	signature:()
SHEdit::TSHEdit::GetSelLen	cSHEdit.h	/^      int __fastcall GetSelLen();$/;"	p	class:SHEdit::TSHEdit	access:protected	signature:()
SHEdit::TSHEdit::GetSelText	cSHEdit.h	/^      String __fastcall GetSelText();$/;"	p	class:SHEdit::TSHEdit	access:protected	signature:()
SHEdit::TSHEdit::GetText	cSHEdit.h	/^      String __fastcall GetText();$/;"	p	class:SHEdit::TSHEdit	access:protected	signature:()
SHEdit::TSHEdit::GetVisLineCount	cSHEdit.h	/^      int __fastcall GetVisLineCount();$/;"	p	class:SHEdit::TSHEdit	access:public	signature:()
SHEdit::TSHEdit::HBar	cSHEdit.h	/^      TScrollBar * HBar;$/;"	m	class:SHEdit::TSHEdit	access:private
SHEdit::TSHEdit::Insert	cSHEdit.h	/^      void Insert(const wchar_t * text, Iter * itr = NULL);                                          \/*!< Handles all insertions.*\/$/;"	p	class:SHEdit::TSHEdit	access:protected	signature:(const wchar_t * text, Iter * itr = NULL)
SHEdit::TSHEdit::IsLineFirstVisible	cSHEdit.h	/^      bool __fastcall IsLineFirstVisible(NSpan * line);$/;"	p	class:SHEdit::TSHEdit	access:protected	signature:(NSpan * line)
SHEdit::TSHEdit::ItrToXY	cSHEdit.h	/^      void ItrToXY(Iter * itr, int& x, int& y);$/;"	p	class:SHEdit::TSHEdit	access:public	signature:(Iter * itr, int& x, int& y)
SHEdit::TSHEdit::KBHook	cSHEdit.h	/^      HHOOK KBHook;                                                                                  \/*!< Serves for intercepting of keyboard events, that are not by default passed to components*\/$/;"	m	class:SHEdit::TSHEdit	access:private
SHEdit::TSHEdit::KeepHistory	cSHEdit.h	/^      __property bool KeepHistory = {read=GetKeepHistory, write=SetKeepHistory, default=true};$/;"	m	class:SHEdit::TSHEdit	access:public
SHEdit::TSHEdit::KeyDownHandler	cSHEdit.h	/^      void __fastcall KeyDownHandler(System::TObject * Sender, System::Word &Key, Classes::TShiftState Shift)     ;$/;"	p	class:SHEdit::TSHEdit	access:protected	signature:(System::TObject * Sender, System::Word &Key, Classes::TShiftState Shift)
SHEdit::TSHEdit::KeyPressHandler	cSHEdit.h	/^      void __fastcall KeyPressHandler(System::TObject * Sender,System::WideChar &Key)     ;$/;"	p	class:SHEdit::TSHEdit	access:protected	signature:(System::TObject * Sender,System::WideChar &Key)
SHEdit::TSHEdit::KeyUpHandler	cSHEdit.h	/^      void __fastcall KeyUpHandler(System::TObject * Sender,System::Word &Key, Classes::TShiftState Shift)         ;$/;"	p	class:SHEdit::TSHEdit	access:protected	signature:(System::TObject * Sender,System::Word &Key, Classes::TShiftState Shift)
SHEdit::TSHEdit::LineNums	cSHEdit.h	/^      __property bool LineNums = {read=GetLinenumsEnabled,write=SetLinenumsEnabled, default=true};$/;"	m	class:SHEdit::TSHEdit	access:public
SHEdit::TSHEdit::LoadFile	cSHEdit.h	/^      void LoadFile(const wchar_t * filename);$/;"	p	class:SHEdit::TSHEdit	access:public	signature:(const wchar_t * filename)
SHEdit::TSHEdit::Log	cSHEdit.h	/^      void __fastcall Log(String str);$/;"	p	class:SHEdit::TSHEdit	access:public	signature:(String str)
SHEdit::TSHEdit::MarkAll	cSHEdit.h	/^      void MarkAll(const String& text, bool caseSensitive = false, bool wholeWord = false);$/;"	p	class:SHEdit::TSHEdit	access:public	signature:(const String& text, bool caseSensitive = false, bool wholeWord = false)
SHEdit::TSHEdit::MouseDown	cSHEdit.h	/^      DYNAMIC void __fastcall MouseDown(TMouseButton Button, Classes::TShiftState Shift, int X, int Y);$/;"	p	class:SHEdit::TSHEdit	access:protected	signature:(TMouseButton Button, Classes::TShiftState Shift, int X, int Y)
SHEdit::TSHEdit::MouseMove	cSHEdit.h	/^      DYNAMIC void __fastcall MouseMove(Classes::TShiftState Shift, int X, int Y);$/;"	p	class:SHEdit::TSHEdit	access:protected	signature:(Classes::TShiftState Shift, int X, int Y)
SHEdit::TSHEdit::MouseUp	cSHEdit.h	/^      DYNAMIC void __fastcall MouseUp(TMouseButton Button, Classes::TShiftState Shift, int X, int Y);$/;"	p	class:SHEdit::TSHEdit	access:protected	signature:(TMouseButton Button, Classes::TShiftState Shift, int X, int Y)
SHEdit::TSHEdit::OnChange	cSHEdit.h	/^      __property TMessage OnChange = {read=FOnChange, write=FOnChange, default=NULL};$/;"	m	class:SHEdit::TSHEdit	access:public
SHEdit::TSHEdit::OnClick	cSHEdit.h	/^      __property TMessage OnClick = {read=FOnClick, write=FOnClick, default=NULL};$/;"	m	class:SHEdit::TSHEdit	access:public
SHEdit::TSHEdit::OnEnter	cSHEdit.h	/^      __property TMessage OnEnter = {read=FOnEnter, write=FOnEnter, default=NULL};$/;"	m	class:SHEdit::TSHEdit	access:public
SHEdit::TSHEdit::OnEnterHandler	cSHEdit.h	/^      void __fastcall OnEnterHandler(TObject * Sender);$/;"	p	class:SHEdit::TSHEdit	access:private	signature:(TObject * Sender)
SHEdit::TSHEdit::OnExit	cSHEdit.h	/^      __property TMessage OnExit = {read=FOnExit, write=FOnExit, default=NULL};$/;"	m	class:SHEdit::TSHEdit	access:public
SHEdit::TSHEdit::OnHScroll	cSHEdit.h	/^      void __fastcall OnHScroll(TObject *Sender, TScrollCode ScrollCode, int &ScrollPos);$/;"	p	class:SHEdit::TSHEdit	access:private	signature:(TObject *Sender, TScrollCode ScrollCode, int &ScrollPos)
SHEdit::TSHEdit::OnKeyDown	cSHEdit.h	/^      __property TKeyEvent OnKeyDown = {read=FOnKeyDown, write=FOnKeyDown, default=NULL};$/;"	m	class:SHEdit::TSHEdit	access:public
SHEdit::TSHEdit::OnKeyPress	cSHEdit.h	/^      __property TKeyPressEvent OnKeyPress = {read=FOnKeyPress, write=FOnKeyPress, default=NULL};$/;"	m	class:SHEdit::TSHEdit	access:public
SHEdit::TSHEdit::OnKeyUp	cSHEdit.h	/^      __property TKeyEvent OnKeyUp = {read=FOnKeyUp, write=FOnKeyUp, default=NULL};$/;"	m	class:SHEdit::TSHEdit	access:public
SHEdit::TSHEdit::OnMouseUp	cSHEdit.h	/^      __property TMouseEvent OnMouseUp = {read=FOnMouseUp, write=FOnMouseUp, default=NULL};$/;"	m	class:SHEdit::TSHEdit	access:public
SHEdit::TSHEdit::OnResizeCallback	cSHEdit.h	/^      void __fastcall OnResizeCallback(TObject* Sender);$/;"	p	class:SHEdit::TSHEdit	access:private	signature:(TObject* Sender)
SHEdit::TSHEdit::OnTimer	cSHEdit.h	/^      void __fastcall OnTimer(TObject * Sender);                                                     \/*!< ensures cursor blinking :) *\/$/;"	p	class:SHEdit::TSHEdit	access:private	signature:(TObject * Sender)
SHEdit::TSHEdit::OnVScroll	cSHEdit.h	/^      void __fastcall OnVScroll(TObject *Sender, TScrollCode ScrollCode, int &ScrollPos);$/;"	p	class:SHEdit::TSHEdit	access:private	signature:(TObject *Sender, TScrollCode ScrollCode, int &ScrollPos)
SHEdit::TSHEdit::Paint	cSHEdit.h	/^      virtual void __fastcall Paint();$/;"	p	class:SHEdit::TSHEdit	access:protected	signature:()
SHEdit::TSHEdit::PaintWindow	cSHEdit.h	/^      virtual void __fastcall PaintWindow(HDC DC);$/;"	p	class:SHEdit::TSHEdit	access:protected	signature:(HDC DC)
SHEdit::TSHEdit::ParseScreenBetween	cSHEdit.h	/^      void ParseScreenBetween(Iter * it1, Iter * it2);                                               \/*!< Pushes visible lines between it1 and it2 to parser. Takes care of right order of iters, and of trimming the. *\/$/;"	p	class:SHEdit::TSHEdit	access:protected	signature:(Iter * it1, Iter * it2)
SHEdit::TSHEdit::Paste	cSHEdit.h	/^      void Paste();$/;"	p	class:SHEdit::TSHEdit	access:public	signature:()
SHEdit::TSHEdit::PositionDescription	cSHEdit.h	/^      String PositionDescription();$/;"	p	class:SHEdit::TSHEdit	access:public	signature:()
SHEdit::TSHEdit::ProcessChange	cSHEdit.h	/^      void ProcessChange(int linesMovedFrom, int linesMoved, NSpan * changed);                       \/*!< Handles painting of most actions that need just partial movement of some data - line insertions and deletions, scrolling, etc.*\/$/;"	p	class:SHEdit::TSHEdit	access:protected	signature:(int linesMovedFrom, int linesMoved, NSpan * changed)
SHEdit::TSHEdit::ProcessKey	cSHEdit.h	/^      virtual LRESULT CALLBACK ProcessKey(int code, WPARAM wParam, LPARAM lParam);                   \/*!< intercepts key messages that would not be otherwise handed to the component.*\/$/;"	p	class:SHEdit::TSHEdit	access:public	signature:(int code, WPARAM wParam, LPARAM lParam)
SHEdit::TSHEdit::ProcessMouseClear	cSHEdit.h	/^      void ProcessMouseClear(bool redraw, bool deletecursord, bool execredraw = true);               \/*!< clears selection *\/$/;"	p	class:SHEdit::TSHEdit	access:private	signature:(bool redraw, bool deletecursord, bool execredraw = true)
SHEdit::TSHEdit::ProcessMouseMove	cSHEdit.h	/^      void ProcessMouseMove(int& x, int& y);                                                         \/*!< processes mouse drag info (called from mouse move and mouse up handlers). *\/$/;"	p	class:SHEdit::TSHEdit	access:private	signature:(int& x, int& y)
SHEdit::TSHEdit::ProcessNewSelection	cSHEdit.h	/^      void ProcessNewSelection(bool execdraw = true, bool draw = true);$/;"	p	class:SHEdit::TSHEdit	access:protected	signature:(bool execdraw = true, bool draw = true)
SHEdit::TSHEdit::ReadOnly	cSHEdit.h	/^      __property bool ReadOnly= {read=readonly,write=readonly, default=false};$/;"	m	class:SHEdit::TSHEdit	access:public
SHEdit::TSHEdit::RepaintWindow	cSHEdit.h	/^      virtual void __fastcall RepaintWindow(bool force = true);$/;"	p	class:SHEdit::TSHEdit	access:public	signature:(bool force = true)
SHEdit::TSHEdit::SaveFile	cSHEdit.h	/^      void SaveFile(const wchar_t * filename);$/;"	p	class:SHEdit::TSHEdit	access:public	signature:(const wchar_t * filename)
SHEdit::TSHEdit::Scroll	cSHEdit.h	/^      void Scroll(int by);$/;"	p	class:SHEdit::TSHEdit	access:private	signature:(int by)
SHEdit::TSHEdit::SelLen	cSHEdit.h	/^      __property int SelLen = {read=GetSelLen, write=SetSelLen};$/;"	m	class:SHEdit::TSHEdit	access:public
SHEdit::TSHEdit::SelText	cSHEdit.h	/^      __property String SelText = {read=GetSelText, write=SetSelText};$/;"	m	class:SHEdit::TSHEdit	access:public
SHEdit::TSHEdit::SelectAll	cSHEdit.h	/^      void SelectAll();$/;"	p	class:SHEdit::TSHEdit	access:public	signature:()
SHEdit::TSHEdit::SetFontsize	cSHEdit.h	/^      void __fastcall SetFontsize(int size);$/;"	p	class:SHEdit::TSHEdit	access:public	signature:(int size)
SHEdit::TSHEdit::SetKeepHistory	cSHEdit.h	/^      void __fastcall SetKeepHistory(bool keep);$/;"	p	class:SHEdit::TSHEdit	access:public	signature:(bool keep)
SHEdit::TSHEdit::SetLanguageDefinition	cSHEdit.h	/^      void __fastcall SetLanguageDefinition(LanguageDefinition * def);$/;"	p	class:SHEdit::TSHEdit	access:public	signature:(LanguageDefinition * def)
SHEdit::TSHEdit::SetLinenumsEnabled	cSHEdit.h	/^      void __fastcall SetLinenumsEnabled(bool enabled);                                              \/*!< sets whether line numbers are being drawn. Needs manual triggering of repaintwindow*\/$/;"	p	class:SHEdit::TSHEdit	access:public	signature:(bool enabled)
SHEdit::TSHEdit::SetSelLen	cSHEdit.h	/^      void __fastcall SetSelLen(int SelLen);$/;"	p	class:SHEdit::TSHEdit	access:protected	signature:(int SelLen)
SHEdit::TSHEdit::SetSelText	cSHEdit.h	/^      void __fastcall SetSelText(String SelText);$/;"	p	class:SHEdit::TSHEdit	access:protected	signature:(String SelText)
SHEdit::TSHEdit::SetSelection	cSHEdit.h	/^      void SetSelection(Iter * first, Iter *  second);$/;"	p	class:SHEdit::TSHEdit	access:public	signature:(Iter * first, Iter * second)
SHEdit::TSHEdit::SetText	cSHEdit.h	/^      void __fastcall SetText(String);$/;"	p	class:SHEdit::TSHEdit	access:protected	signature:(String)
SHEdit::TSHEdit::TSHEdit	cSHEdit.h	/^      __fastcall TSHEdit(TComponent* Owner);$/;"	p	class:SHEdit::TSHEdit	access:public	signature:(TComponent* Owner)
SHEdit::TSHEdit::TabOrder	cSHEdit.h	/^      __property TTabOrder TabOrder = {read=GetTabOrder, write=SetTabOrder, default=-1};$/;"	m	class:SHEdit::TSHEdit	access:public
SHEdit::TSHEdit::Text	cSHEdit.h	/^      __property String Text = {read=GetText, write=SetText};$/;"	m	class:SHEdit::TSHEdit	access:public
SHEdit::TSHEdit::UnMarkMarked	cSHEdit.h	/^      void UnMarkMarked();$/;"	p	class:SHEdit::TSHEdit	access:public	signature:()
SHEdit::TSHEdit::UndoCheck	cSHEdit.h	/^      void UndoCheck();$/;"	p	class:SHEdit::TSHEdit	access:public	signature:()
SHEdit::TSHEdit::UndoRedo	cSHEdit.h	/^      void UndoRedo(bool redo); \/*!< Internal implementation moved from the keydown handlers. Not sure atm whether usable from outside of the handler.     *\/$/;"	p	class:SHEdit::TSHEdit	access:private	signature:(bool redo)
SHEdit::TSHEdit::UpdateCursor	cSHEdit.h	/^      void UpdateCursor(bool paint);                                                                 \/*!< Recalculates position of itrCursor, and posts results to the drawer. If paint is set to true, it also asks drawer to redraw window.*\/$/;"	p	class:SHEdit::TSHEdit	access:private	signature:(bool paint)
SHEdit::TSHEdit::UpdateHBar	cSHEdit.h	/^      void UpdateHBar();$/;"	p	class:SHEdit::TSHEdit	access:private	signature:()
SHEdit::TSHEdit::UpdateVBar	cSHEdit.h	/^      void UpdateVBar();$/;"	p	class:SHEdit::TSHEdit	access:private	signature:()
SHEdit::TSHEdit::VBar	cSHEdit.h	/^      TScrollBar * VBar;$/;"	m	class:SHEdit::TSHEdit	access:private
SHEdit::TSHEdit::Visible	cSHEdit.h	/^      bool Visible(Iter * itr);$/;"	p	class:SHEdit::TSHEdit	access:protected	signature:(Iter * itr)
SHEdit::TSHEdit::WndProc	cSHEdit.h	/^      virtual void __fastcall WndProc(Messages::TMessage &Message);                                  \/*!< self-explaining, note that some keyboard events are handled by separate callback *\/$/;"	p	class:SHEdit::TSHEdit	access:protected	signature:(Messages::TMessage &Message)
SHEdit::TSHEdit::Write	cSHEdit.h	/^      void Write(String message, bool endl = true);$/;"	p	class:SHEdit::TSHEdit	access:public	signature:(String message, bool endl = true)
SHEdit::TSHEdit::XYtoItr	cSHEdit.h	/^      Iter XYtoItr(int& x, int& y);                                                                  \/*!< Converts coordinates to coresponding iterator. *\/$/;"	p	class:SHEdit::TSHEdit	access:private	signature:(int& x, int& y)
SHEdit::TSHEdit::begin	cSHEdit.h	/^      CIter begin();$/;"	p	class:SHEdit::TSHEdit	access:public	signature:()
SHEdit::TSHEdit::buffer	cSHEdit.h	/^      Buffer * buffer;                                                                               \/*!< *\/$/;"	m	class:SHEdit::TSHEdit	access:private
SHEdit::TSHEdit::clipboard	cSHEdit.h	/^      TClipboard * clipboard;$/;"	m	class:SHEdit::TSHEdit	access:protected
SHEdit::TSHEdit::cursorLeftOffset	cSHEdit.h	/^      int cursorLeftOffset;                                                                          \/*!< Column of the cursor, taking into account tabulators. This does NOT equal iterator position.*\/$/;"	m	class:SHEdit::TSHEdit	access:private
SHEdit::TSHEdit::cx	cSHEdit.h	/^      int cx, cy;                                                                                    \/*!< Cursor position*\/$/;"	m	class:SHEdit::TSHEdit	access:private
SHEdit::TSHEdit::cy	cSHEdit.h	/^      int cx, cy;                                                                                    \/*!< Cursor position*\/$/;"	m	class:SHEdit::TSHEdit	access:private
SHEdit::TSHEdit::dbgIter	cSHEdit.h	/^      void __fastcall dbgIter();$/;"	p	class:SHEdit::TSHEdit	access:public	signature:()
SHEdit::TSHEdit::dbgLog	cSHEdit.h	/^      TMemo * dbgLog;$/;"	m	class:SHEdit::TSHEdit	access:public
SHEdit::TSHEdit::drawer	cSHEdit.h	/^      Drawer * drawer;$/;"	m	class:SHEdit::TSHEdit	access:private
SHEdit::TSHEdit::dx	cSHEdit.h	/^      int dx, dy;                                                                                    \/*!< Position of mouse down.*\/$/;"	m	class:SHEdit::TSHEdit	access:private
SHEdit::TSHEdit::dy	cSHEdit.h	/^      int dx, dy;                                                                                    \/*!< Position of mouse down.*\/$/;"	m	class:SHEdit::TSHEdit	access:private
SHEdit::TSHEdit::end	cSHEdit.h	/^      CIter end();$/;"	p	class:SHEdit::TSHEdit	access:public	signature:()
SHEdit::TSHEdit::fallbackLangDef	cSHEdit.h	/^      LanguageDefinition * fallbackLangDef;$/;"	m	class:SHEdit::TSHEdit	access:private
SHEdit::TSHEdit::itrCursor	cSHEdit.h	/^      Iter itrCursor;                                                                                \/*!< Points to actually edited position. If there is mouse drag occuring, then itrCursor is always position where drag started, To get begenning of selected area, use GetCursor() function*\/$/;"	m	class:SHEdit::TSHEdit	access:private
SHEdit::TSHEdit::itrCursorSecond	cSHEdit.h	/^      Iter itrCursorSecond;                                                                          \/*!< Serves for mouse dragging - always is the iterator that is dragged along*\/$/;"	m	class:SHEdit::TSHEdit	access:private
SHEdit::TSHEdit::itrLine	cSHEdit.h	/^      Iter itrLine;                                                                                  \/*!< Iterator that points to the first line of window*\/$/;"	m	class:SHEdit::TSHEdit	access:private
SHEdit::TSHEdit::maxScrollStep	cSHEdit.h	/^      int maxScrollStep;$/;"	m	class:SHEdit::TSHEdit	access:private
SHEdit::TSHEdit::mouseDoubleClickFlag	cSHEdit.h	/^      bool mouseDoubleClickFlag;$/;"	m	class:SHEdit::TSHEdit	access:private
SHEdit::TSHEdit::mouseDown	cSHEdit.h	/^      bool mouseDown;$/;"	m	class:SHEdit::TSHEdit	access:private
SHEdit::TSHEdit::mouseSelect	cSHEdit.h	/^      bool mouseSelect;                                                                              \/*!< Whether component is in text-selection (=mouse drag) mode.*\/$/;"	m	class:SHEdit::TSHEdit	access:private
SHEdit::TSHEdit::msgLock	cSHEdit.h	/^      bool msgLock;$/;"	m	class:SHEdit::TSHEdit	access:private
SHEdit::TSHEdit::mx	cSHEdit.h	/^      int mx, my;                                                                                    \/*!< Position of itrCursorSecond*\/$/;"	m	class:SHEdit::TSHEdit	access:private
SHEdit::TSHEdit::my	cSHEdit.h	/^      int mx, my;                                                                                    \/*!< Position of itrCursorSecond*\/$/;"	m	class:SHEdit::TSHEdit	access:private
SHEdit::TSHEdit::parser	cSHEdit.h	/^      Parser * parser;$/;"	m	class:SHEdit::TSHEdit	access:private
SHEdit::TSHEdit::readonly	cSHEdit.h	/^      bool readonly;$/;"	m	class:SHEdit::TSHEdit	access:private
SHEdit::TSHEdit::recmsg	cSHEdit.h	/^      bool recmsg;                                                                                   \/*!< Originally to handle re-entrancy of processmessages, but quite obsolete by now.*\/$/;"	m	class:SHEdit::TSHEdit	access:private
SHEdit::TSHEdit::scrolldelta	cSHEdit.h	/^      int scrolldelta;                                                                               \/*!< used by ms to treat smooth-scroll wheels...*\/$/;"	m	class:SHEdit::TSHEdit	access:private
SHEdit::TSHEdit::scrolldeltafontsize	cSHEdit.h	/^      int scrolldeltafontsize;                                                                       \/*!< used by ms to treat smooth-scroll wheels...*\/$/;"	m	class:SHEdit::TSHEdit	access:private
SHEdit::TSHEdit::searchColor	cSHEdit.h	/^      TColor searchColor;$/;"	m	class:SHEdit::TSHEdit	access:private
SHEdit::TSHEdit::searchFormat	cSHEdit.h	/^      Format * searchFormat;$/;"	m	class:SHEdit::TSHEdit	access:private
SHEdit::TSHEdit::selColor	cSHEdit.h	/^      TColor selColor;$/;"	m	class:SHEdit::TSHEdit	access:private
SHEdit::TSHEdit::selFColor	cSHEdit.h	/^      TColor selFColor;$/;"	m	class:SHEdit::TSHEdit	access:private
SHEdit::TSHEdit::selectionFormat	cSHEdit.h	/^      Format * selectionFormat;$/;"	m	class:SHEdit::TSHEdit	access:private
SHEdit::TSHEdit::timer	cSHEdit.h	/^      TTimer * timer;$/;"	m	class:SHEdit::TSHEdit	access:private
SHEdit::TSHEdit::~TSHEdit	cSHEdit.h	/^      __fastcall ~TSHEdit();$/;"	p	class:SHEdit::TSHEdit	access:public	signature:()
SHEdit::UndoTask	uSpan.h	/^  struct UndoTask$/;"	s	namespace:SHEdit
SHEdit::UndoTask::UndoTask	uSpan.h	/^    UndoTask(Action * action, Range * range);$/;"	p	struct:SHEdit::UndoTask	access:public	signature:(Action * action, Range * range)
SHEdit::UndoTask::action	uSpan.h	/^    Action * action;$/;"	m	struct:SHEdit::UndoTask	access:public
SHEdit::UndoTask::range	uSpan.h	/^    Range * range;$/;"	m	struct:SHEdit::UndoTask	access:public
SHEdit::UndoTask::~UndoTask	uSpan.h	/^    ~UndoTask();$/;"	p	struct:SHEdit::UndoTask	access:public	signature:()
SHEdit::WordTag	uLanguageDefinition.h	/^  enum LangDefSpecType{Empty = 0x1, Nomatch = 0x2, Normal=0x4, Jump=0x8, WordTag=0x20, LineTag=0x40, Lookahead = 0x80};$/;"	e	enum:SHEdit::LangDefSpecType
SHEdit::tJump	uLanguageDefinition.h	/^  enum LangDefJumpType{tJump, tPush, tMask};$/;"	e	enum:SHEdit::LangDefJumpType
SHEdit::tMask	uLanguageDefinition.h	/^  enum LangDefJumpType{tJump, tPush, tMask};$/;"	e	enum:SHEdit::LangDefJumpType
SHEdit::tPush	uLanguageDefinition.h	/^  enum LangDefJumpType{tJump, tPush, tMask};$/;"	e	enum:SHEdit::LangDefJumpType
SaveFile	cSHEdit.cpp	/^void TSHEdit::SaveFile(const wchar_t * filename)$/;"	f	class:TSHEdit	signature:(const wchar_t * filename)
SaveFile	cSHEdit.h	/^      void SaveFile(const wchar_t * filename);$/;"	p	class:SHEdit::TSHEdit	access:public	signature:(const wchar_t * filename)
Scroll	cSHEdit.cpp	/^void TSHEdit::Scroll(int by)$/;"	f	class:TSHEdit	signature:(int by)
Scroll	cSHEdit.h	/^      void Scroll(int by);$/;"	p	class:SHEdit::TSHEdit	access:private	signature:(int by)
SearchBar	fSearchBar.cpp	/^TSearchBar *SearchBar;$/;"	v
SearchIter	uLanguageDefinition.cpp	/^  LanguageDefinition::SearchIter::SearchIter()$/;"	f	class:LanguageDefinition::SearchIter	signature:()
SearchIter	uLanguageDefinition.h	/^        SearchIter();$/;"	p	struct:SHEdit::LanguageDefinition::SearchIter	access:public	signature:()
SearchIter	uLanguageDefinition.h	/^      struct SearchIter$/;"	s	class:SHEdit::LanguageDefinition	access:public
SelLen	cSHEdit.h	/^      __property int SelLen = {read=GetSelLen, write=SetSelLen};$/;"	m	class:SHEdit::TSHEdit	access:public
SelText	cSHEdit.h	/^      __property String SelText = {read=GetSelText, write=SetSelText};$/;"	m	class:SHEdit::TSHEdit	access:public
SelectAll	cSHEdit.cpp	/^void TSHEdit::SelectAll()$/;"	f	class:TSHEdit	signature:()
SelectAll	cSHEdit.h	/^      void SelectAll();$/;"	p	class:SHEdit::TSHEdit	access:public	signature:()
SendEof	uParser.cpp	/^void Parser::SendEof()$/;"	f	class:Parser	signature:()
SendEof	uParser.h	/^      void SendEof();$/;"	p	class:SHEdit::Parser	access:private	signature:()
SetAllowWhiteSkipping	uLanguageDefinition.cpp	/^void LanguageDefinition::SetAllowWhiteSkipping(bool allow)$/;"	f	class:LanguageDefinition	signature:(bool allow)
SetAllowWhiteSkipping	uLanguageDefinition.h	/^      void SetAllowWhiteSkipping(bool allow);$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(bool allow)
SetCaseSensitive	uLanguageDefinition.cpp	/^void LanguageDefinition::SetCaseSensitive(bool casesensitive)$/;"	f	class:LanguageDefinition	signature:(bool casesensitive)
SetCaseSensitive	uLanguageDefinition.h	/^      void SetCaseSensitive(bool caseSensitive);$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(bool caseSensitive)
SetDefaultColor	uLanguageDefinition.cpp	/^void LanguageDefinition::SetDefaultColor(TColor * defColor)$/;"	f	class:LanguageDefinition	signature:(TColor * defColor)
SetDefaultColor	uLanguageDefinition.h	/^      void SetDefaultColor(TColor * defColor);$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(TColor * defColor)
SetFontsize	cSHEdit.cpp	/^void __fastcall TSHEdit::SetFontsize(int size)$/;"	f	class:TSHEdit	signature:(int size)
SetFontsize	cSHEdit.h	/^      void __fastcall SetFontsize(int size);$/;"	p	class:SHEdit::TSHEdit	access:public	signature:(int size)
SetFontsize	uDrawer.cpp	/^void __fastcall Drawer::SetFontsize(int size)$/;"	f	class:Drawer	signature:(int size)
SetFontsize	uDrawer.h	/^      void __fastcall SetFontsize(int size);$/;"	p	class:SHEdit::Drawer	access:public	signature:(int size)
SetKeepHistory	cSHEdit.cpp	/^void _fastcall TSHEdit::SetKeepHistory(bool keep)$/;"	f	class:TSHEdit	signature:(bool keep)
SetKeepHistory	cSHEdit.h	/^      void __fastcall SetKeepHistory(bool keep);$/;"	p	class:SHEdit::TSHEdit	access:public	signature:(bool keep)
SetLangDef	uParser.cpp	/^void Parser::SetLangDef(LanguageDefinition * langdef)$/;"	f	class:Parser	signature:(LanguageDefinition * langdef)
SetLangDef	uParser.h	/^      void SetLangDef(LanguageDefinition * langdef);$/;"	p	class:SHEdit::Parser	access:public	signature:(LanguageDefinition * langdef)
SetLanguageDefinition	cSHEdit.cpp	/^void __fastcall TSHEdit::SetLanguageDefinition(LanguageDefinition * def)$/;"	f	class:TSHEdit	signature:(LanguageDefinition * def)
SetLanguageDefinition	cSHEdit.h	/^      void __fastcall SetLanguageDefinition(LanguageDefinition * def);$/;"	p	class:SHEdit::TSHEdit	access:public	signature:(LanguageDefinition * def)
SetLinenumsEnabled	cSHEdit.cpp	/^void __fastcall TSHEdit::SetLinenumsEnabled(bool enabled)$/;"	f	class:TSHEdit	signature:(bool enabled)
SetLinenumsEnabled	cSHEdit.h	/^      void __fastcall SetLinenumsEnabled(bool enabled);                                              \/*!< sets whether line numbers are being drawn. Needs manual triggering of repaintwindow*\/$/;"	p	class:SHEdit::TSHEdit	access:public	signature:(bool enabled)
SetLinenumsEnabled	uDrawer.cpp	/^void __fastcall Drawer::SetLinenumsEnabled(bool enable)$/;"	f	class:Drawer	signature:(bool enable)
SetLinenumsEnabled	uDrawer.h	/^      void __fastcall SetLinenumsEnabled(bool enable);$/;"	p	class:SHEdit::Drawer	access:public	signature:(bool enable)
SetSelLen	cSHEdit.cpp	/^void __fastcall TSHEdit::SetSelLen(int SelLen)$/;"	f	class:TSHEdit	signature:(int SelLen)
SetSelLen	cSHEdit.h	/^      void __fastcall SetSelLen(int SelLen);$/;"	p	class:SHEdit::TSHEdit	access:protected	signature:(int SelLen)
SetSelText	cSHEdit.cpp	/^void __fastcall TSHEdit::SetSelText(String SelText)$/;"	f	class:TSHEdit	signature:(String SelText)
SetSelText	cSHEdit.h	/^      void __fastcall SetSelText(String SelText);$/;"	p	class:SHEdit::TSHEdit	access:protected	signature:(String SelText)
SetSelection	cSHEdit.cpp	/^void TSHEdit::SetSelection(Iter * first, Iter * second)$/;"	f	class:TSHEdit	signature:(Iter * first, Iter * second)
SetSelection	cSHEdit.h	/^      void SetSelection(Iter * first, Iter *  second);$/;"	p	class:SHEdit::TSHEdit	access:public	signature:(Iter * first, Iter * second)
SetText	cSHEdit.cpp	/^void __fastcall TSHEdit::SetText(String str)$/;"	f	class:TSHEdit	signature:(String str)
SetText	cSHEdit.h	/^      void __fastcall SetText(String);$/;"	p	class:SHEdit::TSHEdit	access:protected	signature:(String)
SetTreeCaseSensitive	uLanguageDefinition.cpp	/^void LanguageDefinition::SetTreeCaseSensitive(TreeNode * item, bool casesensitive)$/;"	f	class:LanguageDefinition	signature:(TreeNode * item, bool casesensitive)
SetTreeCaseSensitive	uLanguageDefinition.h	/^      void SetTreeCaseSensitive(TreeNode * item, bool caseSensitive);$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:(TreeNode * item, bool caseSensitive)
SimpleLoadFile	uBuffer.cpp	/^void Buffer::SimpleLoadFile(const wchar_t * filename)$/;"	f	class:Buffer	signature:(const wchar_t * filename)
SimpleLoadFile	uBuffer.h	/^      void SimpleLoadFile(const wchar_t * filename);$/;"	p	class:SHEdit::Buffer	access:public	signature:(const wchar_t * filename)
SimpleSaveFile	uBuffer.cpp	/^void Buffer::SimpleSaveFile(const wchar_t * filename)$/;"	f	class:Buffer	signature:(const wchar_t * filename)
SimpleSaveFile	uBuffer.h	/^      void SimpleSaveFile(const wchar_t * filename);$/;"	p	class:SHEdit::Buffer	access:public	signature:(const wchar_t * filename)
Software	LICENSE	/^and\/or sell copies of the Software, and to permit persons to whom the$/;"	v
Span	uSpan.cpp	/^  Span::Span()$/;"	f	class:Span	signature:()
Span	uSpan.cpp	/^  Span::Span(Iter * After)$/;"	f	class:Span	signature:(Iter * After)
Span	uSpan.cpp	/^  Span::Span(Span * afterword)$/;"	f	class:Span	signature:(Span * afterword)
Span	uSpan.cpp	/^  Span::Span(Span * prev, Span * next, wchar_t * string, short length)$/;"	f	class:Span	signature:(Span * prev, Span * next, wchar_t * string, short length)
Span	uSpan.h	/^    Span();$/;"	p	struct:SHEdit::Span	access:public	signature:()
Span	uSpan.h	/^    Span(Iter * After);$/;"	p	struct:SHEdit::Span	access:public	signature:(Iter * After)
Span	uSpan.h	/^    Span(Span * afterword);$/;"	p	struct:SHEdit::Span	access:public	signature:(Span * afterword)
Span	uSpan.h	/^    Span(Span * prev, Span * next, wchar_t* string, short length);$/;"	p	struct:SHEdit::Span	access:public	signature:(Span * prev, Span * next, wchar_t* string, short length)
Span	uSpan.h	/^  struct Span$/;"	s	namespace:SHEdit
Span::Span	uSpan.cpp	/^  Span::Span()$/;"	f	class:Span	signature:()
Span::Span	uSpan.cpp	/^  Span::Span(Iter * After)$/;"	f	class:Span	signature:(Iter * After)
Span::Span	uSpan.cpp	/^  Span::Span(Span * afterword)$/;"	f	class:Span	signature:(Span * afterword)
Span::Span	uSpan.cpp	/^  Span::Span(Span * prev, Span * next, wchar_t * string, short length)$/;"	f	class:Span	signature:(Span * prev, Span * next, wchar_t * string, short length)
Span::~Span	uSpan.cpp	/^Span::~Span()$/;"	f	class:Span	signature:()
Stack	uStack.h	/^    Stack();$/;"	p	class:Stack	access:public	signature:()
Stack	uStack.h	/^Stack<T_data>::Stack()$/;"	f	class:Stack	signature:()
Stack	uStack.h	/^template <class T_data> class Stack$/;"	c
Stack::Contains	uStack.h	/^    bool Contains(T_data d);$/;"	p	class:Stack	access:public	signature:(T_data d)
Stack::Contains	uStack.h	/^bool Stack<T_data>::Contains(T_data d)$/;"	f	class:Stack	signature:(T_data d)
Stack::Erase	uStack.h	/^    void Erase();$/;"	p	class:Stack	access:public	signature:()
Stack::Erase	uStack.h	/^    void Erase(iterator itr);$/;"	p	class:Stack	access:public	signature:(iterator itr)
Stack::Erase	uStack.h	/^void Stack<T_data>::Erase()$/;"	f	class:Stack	signature:()
Stack::Erase	uStack.h	/^void Stack<T_data>::Erase(iterator it)$/;"	f	class:Stack	signature:(iterator it)
Stack::Node	uStack.h	/^    struct Node$/;"	s	class:Stack	access:public
Stack::Node::Node	uStack.h	/^      Node(T_data _data) : data(_data) { };$/;"	f	struct:Stack::Node	access:public	signature:(T_data _data)
Stack::Node::Remove	uStack.h	/^      Node* Remove();                                                                                \/*!< Returns pointer to the next node, for easier removal of elements while iterating through. Any item of Stack can be removed directly from outside of stack by this. Removed node is directly deleted. *\/$/;"	p	struct:Stack::Node	access:public	signature:()
Stack::Node::Remove	uStack.h	/^typename Stack<T_data>::Node* Stack<T_data>::Node::Remove()$/;"	f	class:Stack::Node	signature:()
Stack::Node::data	uStack.h	/^      T_data data;$/;"	m	struct:Stack::Node	access:public
Stack::Node::next	uStack.h	/^      Node * next;$/;"	m	struct:Stack::Node	access:public
Stack::Node::prev	uStack.h	/^      Node ** prev;$/;"	m	struct:Stack::Node	access:public
Stack::Pop	uStack.h	/^    void Pop();$/;"	p	class:Stack	access:public	signature:()
Stack::Pop	uStack.h	/^void Stack<T_data>::Pop()$/;"	f	class:Stack	signature:()
Stack::Push	uStack.h	/^    Node* Push(const T_data& d);$/;"	p	class:Stack	access:public	signature:(const T_data& d)
Stack::Push	uStack.h	/^typename Stack<T_data>::Node* Stack<T_data>::Push(const T_data& d)$/;"	f	class:Stack	signature:(const T_data& d)
Stack::Remove	uStack.h	/^    void Remove(T_data d);$/;"	p	class:Stack	access:public	signature:(T_data d)
Stack::Remove	uStack.h	/^void Stack<T_data>::Remove(T_data d)$/;"	f	class:Stack	signature:(T_data d)
Stack::Stack	uStack.h	/^    Stack();$/;"	p	class:Stack	access:public	signature:()
Stack::Stack	uStack.h	/^Stack<T_data>::Stack()$/;"	f	class:Stack	signature:()
Stack::begin	uStack.h	/^    iterator begin(){return iterator(top);}$/;"	f	class:Stack	access:public	signature:()
Stack::end	uStack.h	/^    iterator end(){return iterator(NULL);}$/;"	f	class:Stack	access:public	signature:()
Stack::iterator	uStack.h	/^    struct iterator$/;"	s	class:Stack	access:public
Stack::iterator::iterator	uStack.h	/^      iterator(Node * p) : ptr(p) {};$/;"	f	struct:Stack::iterator	access:public	signature:(Node * p)
Stack::iterator::operator !=	uStack.h	/^      bool& operator!=(const iterator& i){return !(*this == i);}$/;"	f	struct:Stack::iterator	access:public	signature:(const iterator& i)
Stack::iterator::operator *	uStack.h	/^      T_data& operator*() {return ptr->data};$/;"	f	struct:Stack::iterator	access:public	signature:()
Stack::iterator::operator ++	uStack.h	/^      iterator& operator++(){if(ptr != NULL) ptr = ptr->next; return *this}$/;"	f	struct:Stack::iterator	access:public	signature:()
Stack::iterator::operator ->	uStack.h	/^      T_data* operator->() {return &ptr->data};$/;"	f	struct:Stack::iterator	access:public	signature:()
Stack::iterator::operator ==	uStack.h	/^      bool& operator==(const iterator& i){return i.ptr == ptr;}$/;"	f	struct:Stack::iterator	access:public	signature:(const iterator& i)
Stack::iterator::ptr	uStack.h	/^      Node * ptr;$/;"	m	struct:Stack::iterator	access:public
Stack::operator =	uStack.h	/^    Stack<T_data>& operator=(const Stack<T_data>& stack);$/;"	p	class:Stack	access:public	signature:(const Stack<T_data>& stack)
Stack::operator =	uStack.h	/^Stack<T_data>& Stack<T_data>::operator=(const Stack<T_data>& stack)$/;"	f	class:Stack	signature:(const Stack<T_data>& stack)
Stack::operator ==	uStack.h	/^    bool operator==(const Stack<T_data>& stack);$/;"	p	class:Stack	access:public	signature:(const Stack<T_data>& stack)
Stack::operator ==	uStack.h	/^bool Stack<T_data>::operator==(const Stack<T_data>& stack)$/;"	f	class:Stack	signature:(const Stack<T_data>& stack)
Stack::top	uStack.h	/^    Node * top;$/;"	m	class:Stack	typeref:struct:Stack::iterator	access:public
Stack::~Stack	uStack.h	/^    ~Stack();$/;"	p	class:Stack	access:public	signature:()
Stack::~Stack	uStack.h	/^Stack<T_data>::~Stack()$/;"	f	class:Stack	signature:()
StackItem	uLanguageDefinition2.h	/^      struct StackItem$/;"	s	class:SHEdit::LanguageDefinition	access:public
StressTest	uDrawer.cpp	/^void Drawer::StressTest()$/;"	f	class:Drawer	signature:()
StressTest	uDrawer.h	/^      void StressTest();$/;"	p	class:SHEdit::Drawer	access:private	signature:()
TAB_WIDTH	config.h	19;"	d
TKeyEvent	cSHEdit.h	/^  typedef void __fastcall (__closure *TKeyEvent)(System::TObject* Sender, System::Word &Key, Classes::TShiftState Shift);$/;"	t	namespace:SHEdit
TKeyPressEvent	cSHEdit.h	/^  typedef void __fastcall (__closure *TKeyPressEvent)(System::TObject* Sender, System::WideChar &Key);$/;"	t	namespace:SHEdit
TMessage	cSHEdit.h	/^  typedef void __fastcall (__closure *TMessage)(System::TObject* Sender);$/;"	t	namespace:SHEdit
TMouseEvent	cSHEdit.h	/^  typedef void __fastcall (__closure *TMouseEvent)(System::TObject* Sender, TMouseButton Button, Classes::TShiftState Shift, int X, int Y);$/;"	t	namespace:SHEdit
TO	uDrawer.cpp	129;"	d	file:
TSHEdit	cSHEdit.cpp	/^  __fastcall TSHEdit::TSHEdit(TComponent* Owner)$/;"	f	class:TSHEdit	signature:(TComponent* Owner)
TSHEdit	cSHEdit.h	/^      __fastcall TSHEdit(TComponent* Owner);$/;"	p	class:SHEdit::TSHEdit	access:public	signature:(TComponent* Owner)
TSHEdit	cSHEdit.h	/^  class PACKAGE TSHEdit : public TCustomControl$/;"	c	namespace:SHEdit	inherits:TCustomControl
TSHEdit::Action	cSHEdit.cpp	/^void TSHEdit::Action(String msg, bool end)$/;"	f	class:TSHEdit	signature:(String msg, bool end)
TSHEdit::AddLine	cSHEdit.cpp	/^void TSHEdit::AddLine(const String& string, SHEdit::Format * format)$/;"	f	class:TSHEdit	signature:(const String& string, SHEdit::Format * format)
TSHEdit::AddLines	cSHEdit.cpp	/^void TSHEdit::AddLines(const String& string, SHEdit::Format * format)$/;"	f	class:TSHEdit	signature:(const String& string, SHEdit::Format * format)
TSHEdit::AdjustLine	cSHEdit.cpp	/^void TSHEdit::AdjustLine(bool paint, bool fromtop)$/;"	f	class:TSHEdit	signature:(bool paint, bool fromtop)
TSHEdit::CheckIntegrity	cSHEdit.cpp	/^void TSHEdit::CheckIntegrity()$/;"	f	class:TSHEdit	signature:()
TSHEdit::CheckIterIntegrity	cSHEdit.cpp	/^void TSHEdit::CheckIterIntegrity(Iter * itr)$/;"	f	class:TSHEdit	signature:(Iter * itr)
TSHEdit::Clear	cSHEdit.cpp	/^void TSHEdit::Clear()$/;"	f	class:TSHEdit	signature:()
TSHEdit::Copy	cSHEdit.cpp	/^void TSHEdit::Copy()$/;"	f	class:TSHEdit	signature:()
TSHEdit::DeleteSel	cSHEdit.cpp	/^void TSHEdit::DeleteSel(bool allowsync, Iter * start, Iter * end)$/;"	f	class:TSHEdit	signature:(bool allowsync, Iter * start, Iter * end)
TSHEdit::Escape	cSHEdit.cpp	/^String TSHEdit::Escape(String str)$/;"	f	class:TSHEdit	signature:(String str)
TSHEdit::GetActLine	cSHEdit.cpp	/^int __fastcall TSHEdit::GetActLine()$/;"	f	class:TSHEdit	signature:()
TSHEdit::GetCursor	cSHEdit.cpp	/^CIter TSHEdit::GetCursor()$/;"	f	class:TSHEdit	signature:()
TSHEdit::GetCursorBegin	cSHEdit.cpp	/^CIter TSHEdit::GetCursorBegin()$/;"	f	class:TSHEdit	signature:()
TSHEdit::GetCursorCaretX	cSHEdit.cpp	/^int TSHEdit::GetCursorCaretX()$/;"	f	class:TSHEdit	signature:()
TSHEdit::GetCursorCaretY	cSHEdit.cpp	/^int TSHEdit::GetCursorCaretY()$/;"	f	class:TSHEdit	signature:()
TSHEdit::GetCursorEnd	cSHEdit.cpp	/^CIter TSHEdit::GetCursorEnd()$/;"	f	class:TSHEdit	signature:()
TSHEdit::GetCursorIter	cSHEdit.cpp	/^Iter * TSHEdit::GetCursorIter()$/;"	f	class:TSHEdit	signature:()
TSHEdit::GetCursorIterEnd	cSHEdit.cpp	/^Iter * TSHEdit::GetCursorIterEnd()$/;"	f	class:TSHEdit	signature:()
TSHEdit::GetCursorX	cSHEdit.cpp	/^int TSHEdit::GetCursorX()$/;"	f	class:TSHEdit	signature:()
TSHEdit::GetCursorY	cSHEdit.cpp	/^int TSHEdit::GetCursorY()$/;"	f	class:TSHEdit	signature:()
TSHEdit::GetFontsize	cSHEdit.cpp	/^int __fastcall TSHEdit::GetFontsize()$/;"	f	class:TSHEdit	signature:()
TSHEdit::GetKeepHistory	cSHEdit.cpp	/^bool _fastcall TSHEdit::GetKeepHistory()$/;"	f	class:TSHEdit	signature:()
TSHEdit::GetLanguageDefinition	cSHEdit.cpp	/^LanguageDefinition* __fastcall TSHEdit::GetLanguageDefinition()$/;"	f	class:TSHEdit	signature:()
TSHEdit::GetLine	cSHEdit.cpp	/^String TSHEdit::GetLine(Iter* itr)$/;"	f	class:TSHEdit	signature:(Iter* itr)
TSHEdit::GetLine	cSHEdit.cpp	/^String TSHEdit::GetLine(int index)$/;"	f	class:TSHEdit	signature:(int index)
TSHEdit::GetLineByNum	cSHEdit.cpp	/^Iter __fastcall TSHEdit::GetLineByNum(int no)$/;"	f	class:TSHEdit	signature:(int no)
TSHEdit::GetLineByNum	cSHEdit.cpp	/^Iter __fastcall TSHEdit::GetLineByNum(int no, bool allowEnd)$/;"	f	class:TSHEdit	signature:(int no, bool allowEnd)
TSHEdit::GetLineCount	cSHEdit.cpp	/^int __fastcall TSHEdit::GetLineCount()$/;"	f	class:TSHEdit	signature:()
TSHEdit::GetLineHeight	cSHEdit.cpp	/^int __fastcall TSHEdit::GetLineHeight()$/;"	f	class:TSHEdit	signature:()
TSHEdit::GetLineNum	cSHEdit.cpp	/^int __fastcall TSHEdit::GetLineNum(NSpan * line)$/;"	f	class:TSHEdit	signature:(NSpan * line)
TSHEdit::GetLinenumsEnabled	cSHEdit.cpp	/^bool __fastcall TSHEdit::GetLinenumsEnabled()$/;"	f	class:TSHEdit	signature:()
TSHEdit::GetRange	cSHEdit.cpp	/^String TSHEdit::GetRange(Iter * begin, Iter * end)$/;"	f	class:TSHEdit	signature:(Iter * begin, Iter * end)
TSHEdit::GetScrollStep	cSHEdit.cpp	/^int TSHEdit::GetScrollStep()$/;"	f	class:TSHEdit	signature:()
TSHEdit::GetSelLen	cSHEdit.cpp	/^int __fastcall TSHEdit::GetSelLen()$/;"	f	class:TSHEdit	signature:()
TSHEdit::GetSelText	cSHEdit.cpp	/^String __fastcall TSHEdit::GetSelText()$/;"	f	class:TSHEdit	signature:()
TSHEdit::GetText	cSHEdit.cpp	/^String __fastcall TSHEdit::GetText()$/;"	f	class:TSHEdit	signature:()
TSHEdit::GetVisLineCount	cSHEdit.cpp	/^int __fastcall TSHEdit::GetVisLineCount()$/;"	f	class:TSHEdit	signature:()
TSHEdit::Insert	cSHEdit.cpp	/^void TSHEdit::Insert(const wchar_t * text, Iter * itr)$/;"	f	class:TSHEdit	signature:(const wchar_t * text, Iter * itr)
TSHEdit::IsLineFirstVisible	cSHEdit.cpp	/^bool __fastcall TSHEdit::IsLineFirstVisible(NSpan * line)$/;"	f	class:TSHEdit	signature:(NSpan * line)
TSHEdit::ItrToXY	cSHEdit.cpp	/^void TSHEdit::ItrToXY(Iter * itr, int& x, int& y)$/;"	f	class:TSHEdit	signature:(Iter * itr, int& x, int& y)
TSHEdit::KeyDownHandler	cSHEdit.cpp	/^void __fastcall TSHEdit::KeyDownHandler(System::TObject * Sender,System::Word &Key, Classes::TShiftState Shift)$/;"	f	class:TSHEdit	signature:(System::TObject * Sender,System::Word &Key, Classes::TShiftState Shift)
TSHEdit::KeyPressHandler	cSHEdit.cpp	/^void __fastcall TSHEdit::KeyPressHandler(System::TObject * Sender, System::WideChar &Key)$/;"	f	class:TSHEdit	signature:(System::TObject * Sender, System::WideChar &Key)
TSHEdit::KeyUpHandler	cSHEdit.cpp	/^void __fastcall TSHEdit::KeyUpHandler(System::TObject * Sender,System::Word &Key, Classes::TShiftState Shift)$/;"	f	class:TSHEdit	signature:(System::TObject * Sender,System::Word &Key, Classes::TShiftState Shift)
TSHEdit::LoadFile	cSHEdit.cpp	/^void TSHEdit::LoadFile(const wchar_t * filename)$/;"	f	class:TSHEdit	signature:(const wchar_t * filename)
TSHEdit::Log	cSHEdit.cpp	/^void __fastcall TSHEdit::Log(String str)$/;"	f	class:TSHEdit	signature:(String str)
TSHEdit::MarkAll	cSHEdit.cpp	/^void TSHEdit::MarkAll(const String& text, bool caseSensitive, bool wholeWord)$/;"	f	class:TSHEdit	signature:(const String& text, bool caseSensitive, bool wholeWord)
TSHEdit::MouseDown	cSHEdit.cpp	/^void __fastcall TSHEdit::MouseDown(TMouseButton Button, Classes::TShiftState Shift, int X, int Y)$/;"	f	class:TSHEdit	signature:(TMouseButton Button, Classes::TShiftState Shift, int X, int Y)
TSHEdit::MouseMove	cSHEdit.cpp	/^void __fastcall TSHEdit::MouseMove(Classes::TShiftState Shift, int X, int Y)$/;"	f	class:TSHEdit	signature:(Classes::TShiftState Shift, int X, int Y)
TSHEdit::MouseUp	cSHEdit.cpp	/^void __fastcall TSHEdit::MouseUp(TMouseButton Button, Classes::TShiftState Shift, int X, int Y)$/;"	f	class:TSHEdit	signature:(TMouseButton Button, Classes::TShiftState Shift, int X, int Y)
TSHEdit::OnEnterHandler	cSHEdit.cpp	/^void __fastcall TSHEdit::OnEnterHandler(TObject * Sender)$/;"	f	class:TSHEdit	signature:(TObject * Sender)
TSHEdit::OnHScroll	cSHEdit.cpp	/^void __fastcall TSHEdit::OnHScroll(TObject *Sender, TScrollCode ScrollCode, int &ScrollPos)$/;"	f	class:TSHEdit	signature:(TObject *Sender, TScrollCode ScrollCode, int &ScrollPos)
TSHEdit::OnResizeCallback	cSHEdit.cpp	/^void __fastcall TSHEdit::OnResizeCallback(TObject * Sender)$/;"	f	class:TSHEdit	signature:(TObject * Sender)
TSHEdit::OnTimer	cSHEdit.cpp	/^void __fastcall TSHEdit::OnTimer(TObject * Sender)$/;"	f	class:TSHEdit	signature:(TObject * Sender)
TSHEdit::OnVScroll	cSHEdit.cpp	/^void __fastcall TSHEdit::OnVScroll(TObject *Sender, TScrollCode ScrollCode, int &ScrollPos)$/;"	f	class:TSHEdit	signature:(TObject *Sender, TScrollCode ScrollCode, int &ScrollPos)
TSHEdit::Paint	cSHEdit.cpp	/^void __fastcall TSHEdit::Paint()$/;"	f	class:TSHEdit	signature:()
TSHEdit::PaintWindow	cSHEdit.cpp	/^void __fastcall TSHEdit::PaintWindow(HDC DC)$/;"	f	class:TSHEdit	signature:(HDC DC)
TSHEdit::ParseScreenBetween	cSHEdit.cpp	/^void TSHEdit::ParseScreenBetween(Iter * it1, Iter * it2)$/;"	f	class:TSHEdit	signature:(Iter * it1, Iter * it2)
TSHEdit::Paste	cSHEdit.cpp	/^void TSHEdit::Paste()$/;"	f	class:TSHEdit	signature:()
TSHEdit::PositionDescription	cSHEdit.cpp	/^String TSHEdit::PositionDescription()$/;"	f	class:TSHEdit	signature:()
TSHEdit::ProcessChange	cSHEdit.cpp	/^void TSHEdit::ProcessChange(int linesMovedFrom, int linesMoved, NSpan * changed)$/;"	f	class:TSHEdit	signature:(int linesMovedFrom, int linesMoved, NSpan * changed)
TSHEdit::ProcessKey	cSHEdit.cpp	/^LRESULT CALLBACK TSHEdit::ProcessKey(int code, WPARAM wParam, LPARAM lParam)$/;"	f	class:TSHEdit	signature:(int code, WPARAM wParam, LPARAM lParam)
TSHEdit::ProcessMouseClear	cSHEdit.cpp	/^void TSHEdit::ProcessMouseClear(bool redraw, bool deleteiter, bool execredraw)$/;"	f	class:TSHEdit	signature:(bool redraw, bool deleteiter, bool execredraw)
TSHEdit::ProcessMouseMove	cSHEdit.cpp	/^void TSHEdit::ProcessMouseMove(int &x, int &y)$/;"	f	class:TSHEdit	signature:(int &x, int &y)
TSHEdit::ProcessNewSelection	cSHEdit.cpp	/^void TSHEdit::ProcessNewSelection(bool execredraw, bool draw)$/;"	f	class:TSHEdit	signature:(bool execredraw, bool draw)
TSHEdit::RepaintWindow	cSHEdit.cpp	/^void __fastcall TSHEdit::RepaintWindow(bool force)$/;"	f	class:TSHEdit	signature:(bool force)
TSHEdit::SaveFile	cSHEdit.cpp	/^void TSHEdit::SaveFile(const wchar_t * filename)$/;"	f	class:TSHEdit	signature:(const wchar_t * filename)
TSHEdit::Scroll	cSHEdit.cpp	/^void TSHEdit::Scroll(int by)$/;"	f	class:TSHEdit	signature:(int by)
TSHEdit::SelectAll	cSHEdit.cpp	/^void TSHEdit::SelectAll()$/;"	f	class:TSHEdit	signature:()
TSHEdit::SetFontsize	cSHEdit.cpp	/^void __fastcall TSHEdit::SetFontsize(int size)$/;"	f	class:TSHEdit	signature:(int size)
TSHEdit::SetKeepHistory	cSHEdit.cpp	/^void _fastcall TSHEdit::SetKeepHistory(bool keep)$/;"	f	class:TSHEdit	signature:(bool keep)
TSHEdit::SetLanguageDefinition	cSHEdit.cpp	/^void __fastcall TSHEdit::SetLanguageDefinition(LanguageDefinition * def)$/;"	f	class:TSHEdit	signature:(LanguageDefinition * def)
TSHEdit::SetLinenumsEnabled	cSHEdit.cpp	/^void __fastcall TSHEdit::SetLinenumsEnabled(bool enabled)$/;"	f	class:TSHEdit	signature:(bool enabled)
TSHEdit::SetSelLen	cSHEdit.cpp	/^void __fastcall TSHEdit::SetSelLen(int SelLen)$/;"	f	class:TSHEdit	signature:(int SelLen)
TSHEdit::SetSelText	cSHEdit.cpp	/^void __fastcall TSHEdit::SetSelText(String SelText)$/;"	f	class:TSHEdit	signature:(String SelText)
TSHEdit::SetSelection	cSHEdit.cpp	/^void TSHEdit::SetSelection(Iter * first, Iter * second)$/;"	f	class:TSHEdit	signature:(Iter * first, Iter * second)
TSHEdit::SetText	cSHEdit.cpp	/^void __fastcall TSHEdit::SetText(String str)$/;"	f	class:TSHEdit	signature:(String str)
TSHEdit::TSHEdit	cSHEdit.cpp	/^  __fastcall TSHEdit::TSHEdit(TComponent* Owner)$/;"	f	class:TSHEdit	signature:(TComponent* Owner)
TSHEdit::UnMarkMarked	cSHEdit.cpp	/^void TSHEdit::UnMarkMarked()$/;"	f	class:TSHEdit	signature:()
TSHEdit::UndoCheck	cSHEdit.cpp	/^void TSHEdit::UndoCheck()$/;"	f	class:TSHEdit	signature:()
TSHEdit::UndoRedo	cSHEdit.cpp	/^void TSHEdit::UndoRedo(bool redo)$/;"	f	class:TSHEdit	signature:(bool redo)
TSHEdit::UpdateCursor	cSHEdit.cpp	/^void TSHEdit::UpdateCursor(bool paint)$/;"	f	class:TSHEdit	signature:(bool paint)
TSHEdit::UpdateHBar	cSHEdit.cpp	/^void TSHEdit::UpdateHBar()$/;"	f	class:TSHEdit	signature:()
TSHEdit::UpdateVBar	cSHEdit.cpp	/^void TSHEdit::UpdateVBar()$/;"	f	class:TSHEdit	signature:()
TSHEdit::Visible	cSHEdit.cpp	/^bool TSHEdit::Visible(Iter * itr)$/;"	f	class:TSHEdit	signature:(Iter * itr)
TSHEdit::WndProc	cSHEdit.cpp	/^void __fastcall TSHEdit::WndProc(Messages::TMessage &Message)$/;"	f	class:TSHEdit	signature:(Messages::TMessage &Message)
TSHEdit::Write	cSHEdit.cpp	/^void TSHEdit::Write(String message, bool end)$/;"	f	class:TSHEdit	signature:(String message, bool end)
TSHEdit::XYtoItr	cSHEdit.cpp	/^Iter TSHEdit::XYtoItr(int& x, int& y)$/;"	f	class:TSHEdit	signature:(int& x, int& y)
TSHEdit::begin	cSHEdit.cpp	/^CIter TSHEdit::begin()$/;"	f	class:TSHEdit	signature:()
TSHEdit::dbgIter	cSHEdit.cpp	/^void __fastcall TSHEdit::dbgIter()$/;"	f	class:TSHEdit	signature:()
TSHEdit::end	cSHEdit.cpp	/^CIter TSHEdit::end()$/;"	f	class:TSHEdit	signature:()
TSHEdit::~TSHEdit	cSHEdit.cpp	/^__fastcall TSHEdit::~TSHEdit()$/;"	f	class:TSHEdit	signature:()
TSHEditFocused	cSHEdit.cpp	/^TSHEdit * TSHEditFocused; \/\/callback musi jit na statickou metodu...$/;"	v
TSearchBar	fSearchBar.cpp	/^  __fastcall TSearchBar::TSearchBar(TComponent* Owner)$/;"	f	class:TSearchBar	signature:(TComponent* Owner)
TSearchBar	fSearchBar.h	/^  __fastcall TSearchBar(TComponent* Owner);$/;"	p	class:TSearchBar	access:public	signature:(TComponent* Owner)
TSearchBar	fSearchBar.h	/^class TSearchBar : public TForm$/;"	c	inherits:TForm
TSearchBar::Button1	fSearchBar.h	/^  TButton *Button1;$/;"	m	class:TSearchBar	access:private
TSearchBar::Button1Click	fSearchBar.cpp	/^void __fastcall TSearchBar::Button1Click(TObject *Sender)$/;"	f	class:TSearchBar	signature:(TObject *Sender)
TSearchBar::Button1Click	fSearchBar.h	/^  void __fastcall Button1Click(TObject *Sender);$/;"	p	class:TSearchBar	access:private	signature:(TObject *Sender)
TSearchBar::Button2	fSearchBar.h	/^  TButton *Button2;$/;"	m	class:TSearchBar	access:private
TSearchBar::Button2Click	fSearchBar.cpp	/^void __fastcall TSearchBar::Button2Click(TObject *Sender)$/;"	f	class:TSearchBar	signature:(TObject *Sender)
TSearchBar::Button2Click	fSearchBar.h	/^  void __fastcall Button2Click(TObject *Sender);$/;"	p	class:TSearchBar	access:private	signature:(TObject *Sender)
TSearchBar::CheckBox1	fSearchBar.h	/^  TCheckBox *CheckBox1;$/;"	m	class:TSearchBar	access:private
TSearchBar::Edit1	fSearchBar.h	/^  TEdit *Edit1;$/;"	m	class:TSearchBar	access:private
TSearchBar::Edit1KeyPress	fSearchBar.cpp	/^void __fastcall TSearchBar::Edit1KeyPress(TObject *Sender, wchar_t &Key)$/;"	f	class:TSearchBar	signature:(TObject *Sender, wchar_t &Key)
TSearchBar::Edit1KeyPress	fSearchBar.h	/^  void __fastcall Edit1KeyPress(TObject *Sender, wchar_t &Key);$/;"	p	class:TSearchBar	access:private	signature:(TObject *Sender, wchar_t &Key)
TSearchBar::Label1	fSearchBar.h	/^  TLabel *Label1;$/;"	m	class:TSearchBar	access:private
TSearchBar::TSearchBar	fSearchBar.cpp	/^  __fastcall TSearchBar::TSearchBar(TComponent* Owner)$/;"	f	class:TSearchBar	signature:(TComponent* Owner)
TSearchBar::TSearchBar	fSearchBar.h	/^  __fastcall TSearchBar(TComponent* Owner);$/;"	p	class:TSearchBar	access:public	signature:(TComponent* Owner)
TSearchBar::cases	fSearchBar.h	/^  bool cases;$/;"	m	class:TSearchBar	access:public
TSearchBar::forward	fSearchBar.h	/^  bool forward;$/;"	m	class:TSearchBar	access:public
TSearchBar::success	fSearchBar.h	/^  bool success;$/;"	m	class:TSearchBar	access:public
TSearchBar::text	fSearchBar.h	/^  String text;$/;"	m	class:TSearchBar	access:public
TabOrder	cSHEdit.h	/^      __property TTabOrder TabOrder = {read=GetTabOrder, write=SetTabOrder, default=-1};$/;"	m	class:SHEdit::TSHEdit	access:public
Term	uLanguageDefinition2.h	/^        Term(const std::wstring& n, FontStyle* fs_, int i, bool g, bool c) : name(n), fs(fs_), tokid(i), getstyle(g), call(c) {} ;$/;"	f	struct:SHEdit::LanguageDefinition::Term	access:public	signature:(const std::wstring& n, FontStyle* fs_, int i, bool g, bool c)
Term	uLanguageDefinition2.h	/^      struct Term$/;"	s	class:SHEdit::LanguageDefinition	access:private
TestParser	tags	/^TestParser	uLangDef2Test.cpp	\/^    TestParser(): LanguageDefinition(){};$\/;"	f	class:TestParser	access:public	signature:()$/;"	f	signature:()
TestParser	uLangDef2Test.cpp	/^    TestParser(): LanguageDefinition(){};$/;"	f	class:TestParser	access:public	signature:()
TestParser	uLangDef2Test.cpp	/^class TestParser : public LanguageDefinition$/;"	c	file:	inherits:LanguageDefinition
TestParser::TestParser	uLangDef2Test.cpp	/^    TestParser(): LanguageDefinition(){};$/;"	f	class:TestParser	access:public	signature:()
Text	cSHEdit.h	/^      __property String Text = {read=GetText, write=SetText};$/;"	m	class:SHEdit::TSHEdit	access:public
TokType	uLanguageDefinition2.h	/^      enum TokType {tS, tC, tE};$/;"	g	class:SHEdit::LanguageDefinition	access:private
TreeNode	uLanguageDefinition.cpp	/^LanguageDefinition::TreeNode::TreeNode(TreeNode * tree, SHEdit::FontStyle * format)$/;"	f	class:LanguageDefinition::TreeNode	signature:(TreeNode * tree, SHEdit::FontStyle * format)
TreeNode	uLanguageDefinition.cpp	/^LanguageDefinition::TreeNode::TreeNode(wchar_t c, LangDefSpecType type, SHEdit::FontStyle * format, bool caseSensitive)$/;"	f	class:LanguageDefinition::TreeNode	signature:(wchar_t c, LangDefSpecType type, SHEdit::FontStyle * format, bool caseSensitive)
TreeNode	uLanguageDefinition.h	/^        TreeNode(TreeNode * tree, FontStyle * format);$/;"	p	struct:SHEdit::LanguageDefinition::TreeNode	access:public	signature:(TreeNode * tree, FontStyle * format)
TreeNode	uLanguageDefinition.h	/^        TreeNode(wchar_t c, LangDefSpecType type, FontStyle * format, bool caseSensitive);$/;"	p	struct:SHEdit::LanguageDefinition::TreeNode	access:public	signature:(wchar_t c, LangDefSpecType type, FontStyle * format, bool caseSensitive)
TreeNode	uLanguageDefinition.h	/^      struct TreeNode$/;"	s	class:SHEdit::LanguageDefinition	access:public
UnMarkMarked	cSHEdit.cpp	/^void TSHEdit::UnMarkMarked()$/;"	f	class:TSHEdit	signature:()
UnMarkMarked	cSHEdit.h	/^      void UnMarkMarked();$/;"	p	class:SHEdit::TSHEdit	access:public	signature:()
Undo	uBuffer.cpp	/^Iter * Buffer::Undo(Iter *& begin)$/;"	f	class:Buffer	signature:(Iter *& begin)
Undo	uBuffer.h	/^      Iter * Undo(Iter *& begin);$/;"	p	class:SHEdit::Buffer	access:public	signature:(Iter *& begin)
UndoCheck	cSHEdit.cpp	/^void TSHEdit::UndoCheck()$/;"	f	class:TSHEdit	signature:()
UndoCheck	cSHEdit.h	/^      void UndoCheck();$/;"	p	class:SHEdit::TSHEdit	access:public	signature:()
UndoPush	uBuffer.cpp	/^void Buffer::UndoPush(UndoTask * event)$/;"	f	class:Buffer	signature:(UndoTask * event)
UndoPush	uBuffer.h	/^      void UndoPush(UndoTask * event);$/;"	p	class:SHEdit::Buffer	access:private	signature:(UndoTask * event)
UndoRedo	cSHEdit.cpp	/^void TSHEdit::UndoRedo(bool redo)$/;"	f	class:TSHEdit	signature:(bool redo)
UndoRedo	cSHEdit.h	/^      void UndoRedo(bool redo); \/*!< Internal implementation moved from the keydown handlers. Not sure atm whether usable from outside of the handler.     *\/$/;"	p	class:SHEdit::TSHEdit	access:private	signature:(bool redo)
UndoRedo	uBuffer.cpp	/^Iter * Buffer::UndoRedo(std::stack<UndoTask*> * stackUndo, std::stack<UndoTask*> * stackRedo, Iter *& begin)$/;"	f	class:Buffer	signature:(std::stack<UndoTask*> * stackUndo, std::stack<UndoTask*> * stackRedo, Iter *& begin)
UndoRedo	uBuffer.h	/^      Iter * UndoRedo(std::stack<UndoTask*> * stackUndo, std::stack<UndoTask*> * stackRedo, Iter *& begin);$/;"	p	class:SHEdit::Buffer	access:private	signature:(std::stack<UndoTask*> * stackUndo, std::stack<UndoTask*> * stackRedo, Iter *& begin)
UndoTask	uSpan.cpp	/^UndoTask::UndoTask(Action * action, Range * range)$/;"	f	class:UndoTask	signature:(Action * action, Range * range)
UndoTask	uSpan.h	/^    UndoTask(Action * action, Range * range);$/;"	p	struct:SHEdit::UndoTask	access:public	signature:(Action * action, Range * range)
UndoTask	uSpan.h	/^  struct UndoTask$/;"	s	namespace:SHEdit
UndoTask::UndoTask	uSpan.cpp	/^UndoTask::UndoTask(Action * action, Range * range)$/;"	f	class:UndoTask	signature:(Action * action, Range * range)
UndoTask::~UndoTask	uSpan.cpp	/^UndoTask::~UndoTask()$/;"	f	class:UndoTask	signature:()
UnregisterF	uBuffer.cpp	/^void Buffer::UnregisterF(SHEdit::Format * f)$/;"	f	class:Buffer	signature:(SHEdit::Format * f)
UnregisterF	uBuffer.h	/^      void UnregisterF(Format * form);$/;"	p	class:SHEdit::Buffer	access:public	signature:(Format * form)
UnregisterIM	uBuffer.cpp	/^void Buffer::UnregisterIM(IMark * itr)$/;"	f	class:Buffer	signature:(IMark * itr)
UnregisterIM	uBuffer.h	/^      void UnregisterIM(IMark * itr);$/;"	p	class:SHEdit::Buffer	access:public	signature:(IMark * itr)
UnregisterIP	uBuffer.cpp	/^void Buffer::UnregisterIP(IPos * itr)$/;"	f	class:Buffer	signature:(IPos * itr)
UnregisterIP	uBuffer.h	/^      void UnregisterIP(IPos * itr);$/;"	p	class:SHEdit::Buffer	access:public	signature:(IPos * itr)
Update	uCursor.cpp	/^void CIter::Update()$/;"	f	class:CIter	signature:()
Update	uCursor.h	/^                void Update();$/;"	p	class:SHEdit::CIter	access:private	signature:()
Update	uIPos.cpp	/^void IPos::Update()$/;"	f	class:IPos	signature:()
Update	uIPos.h	/^      virtual void Update();                                                                         \/*!< Is called when structure of underlying buffer changed, to allow descendants to update their links to the physical structure. *\/$/;"	p	class:SHEdit::IPos	access:public	signature:()
Update	uIter.cpp	/^void Iter::Update()$/;"	f	class:Iter	signature:()
Update	uIter.h	/^      virtual void Update();                                                                         \/*!< Is called when structure of underlying buffer changed, to allow descendants to update their links to the physical structure. *\/$/;"	p	class:SHEdit::Iter	access:protected	signature:()
UpdateCursor	cSHEdit.cpp	/^void TSHEdit::UpdateCursor(bool paint)$/;"	f	class:TSHEdit	signature:(bool paint)
UpdateCursor	cSHEdit.h	/^      void UpdateCursor(bool paint);                                                                 \/*!< Recalculates position of itrCursor, and posts results to the drawer. If paint is set to true, it also asks drawer to redraw window.*\/$/;"	p	class:SHEdit::TSHEdit	access:private	signature:(bool paint)
UpdateCursor	uDrawer.cpp	/^void __fastcall Drawer::UpdateCursor(int x, int y)$/;"	f	class:Drawer	signature:(int x, int y)
UpdateCursor	uDrawer.h	/^      void __fastcall UpdateCursor(int x, int y);$/;"	p	class:SHEdit::Drawer	access:private	signature:(int x, int y)
UpdateHBar	cSHEdit.cpp	/^void TSHEdit::UpdateHBar()$/;"	f	class:TSHEdit	signature:()
UpdateHBar	cSHEdit.h	/^      void UpdateHBar();$/;"	p	class:SHEdit::TSHEdit	access:private	signature:()
UpdateHBar	uDrawer.cpp	/^void __fastcall Drawer::UpdateHBar()$/;"	f	class:Drawer	signature:()
UpdateHBar	uDrawer.h	/^      void __fastcall UpdateHBar();$/;"	p	class:SHEdit::Drawer	access:private	signature:()
UpdateLinenumWidth	uDrawer.cpp	/^bool __fastcall Drawer::UpdateLinenumWidth(int count)$/;"	f	class:Drawer	signature:(int count)
UpdateLinenumWidth	uDrawer.h	/^      bool __fastcall UpdateLinenumWidth(int count);$/;"	p	class:SHEdit::Drawer	access:public	signature:(int count)
UpdateNextImark	uIter.cpp	/^void Iter::UpdateNextImark()$/;"	f	class:Iter	signature:()
UpdateNextImark	uIter.h	/^      void UpdateNextImark();                                                                        \/*!< See the Iter class info for explanation *\/$/;"	p	class:SHEdit::Iter	access:protected	signature:()
UpdatePos	uIPos.cpp	/^void IPos::UpdatePos()$/;"	f	class:IPos	signature:()
UpdatePos	uIPos.h	/^      virtual void UpdatePos();                                                                      \/*!< Basically same as Update(), but handles repositioning *\/$/;"	p	class:SHEdit::IPos	access:public	signature:()
UpdatePos	uIter.cpp	/^void Iter::UpdatePos()$/;"	f	class:Iter	signature:()
UpdatePos	uIter.h	/^      virtual void UpdatePos();                                                                      \/*!< Basically same as Update(), but handles repositioning *\/$/;"	p	class:SHEdit::Iter	access:protected	signature:()
UpdateVBar	cSHEdit.cpp	/^void TSHEdit::UpdateVBar()$/;"	f	class:TSHEdit	signature:()
UpdateVBar	cSHEdit.h	/^      void UpdateVBar();$/;"	p	class:SHEdit::TSHEdit	access:private	signature:()
VBar	cSHEdit.h	/^      TScrollBar * VBar;$/;"	m	class:SHEdit::TSHEdit	access:private
Valid	uCursor.cpp	/^      \/*AUTOGENERATED*\/ bool  CIter::Valid ()   { Init();  return  this->itr.Valid ();} $/;"	f	class:CIter	signature:()
Valid	uCursor.h	/^      \/*AUTOGENERATED*\/ bool  CIter::Valid ()   ; $/;"	p	class:SHEdit::CIter::CIter	access:public	signature:()
Valid	uIPos.cpp	/^bool IPos::Valid()$/;"	f	class:IPos	signature:()
Valid	uIPos.h	/^      bool Valid();$/;"	p	class:SHEdit::IPos	access:public	signature:()
Valid	uIter.cpp	/^bool Iter::Valid()$/;"	f	class:Iter	signature:()
Valid	uIter.h	/^      bool Valid() \/*AUTOGEN_PASS*\/;$/;"	p	class:SHEdit::Iter	access:public	signature:()
ValidCtrCheck	cSHEdit.cpp	/^static inline void ValidCtrCheck(TSHEdit *)$/;"	f	file:	signature:(TSHEdit *)
Visible	cSHEdit.cpp	/^bool TSHEdit::Visible(Iter * itr)$/;"	f	class:TSHEdit	signature:(Iter * itr)
Visible	cSHEdit.h	/^      bool Visible(Iter * itr);$/;"	p	class:SHEdit::TSHEdit	access:protected	signature:(Iter * itr)
WndProc	cSHEdit.cpp	/^void __fastcall TSHEdit::WndProc(Messages::TMessage &Message)$/;"	f	class:TSHEdit	signature:(Messages::TMessage &Message)
WndProc	cSHEdit.h	/^      virtual void __fastcall WndProc(Messages::TMessage &Message);                                  \/*!< self-explaining, note that some keyboard events are handled by separate callback *\/$/;"	p	class:SHEdit::TSHEdit	access:protected	signature:(Messages::TMessage &Message)
WordTag	uLanguageDefinition.h	/^  enum LangDefSpecType{Empty = 0x1, Nomatch = 0x2, Normal=0x4, Jump=0x8, WordTag=0x20, LineTag=0x40, Lookahead = 0x80};$/;"	e	enum:SHEdit::LangDefSpecType
Write	cSHEdit.cpp	/^void TSHEdit::Write(String message, bool end)$/;"	f	class:TSHEdit	signature:(String message, bool end)
Write	cSHEdit.h	/^      void Write(String message, bool endl = true);$/;"	p	class:SHEdit::TSHEdit	access:public	signature:(String message, bool endl = true)
Write	uBuffer.cpp	/^void Buffer::Write(AnsiString message)$/;"	f	class:Buffer	signature:(AnsiString message)
Write	uBuffer.h	/^      void Write(AnsiString message);$/;"	p	class:SHEdit::Buffer	access:private	signature:(AnsiString message)
Write	uDrawer.cpp	/^void Drawer::Write(String message)$/;"	f	class:Drawer	signature:(String message)
Write	uDrawer.h	/^      void Write(String message);$/;"	p	class:SHEdit::Drawer	access:private	signature:(String message)
Write	uParser.cpp	/^void Parser::Write(AnsiString message)$/;"	f	class:Parser	signature:(AnsiString message)
Write	uParser.h	/^      void Write(AnsiString message);$/;"	p	class:SHEdit::Parser	access:private	signature:(AnsiString message)
XYtoItr	cSHEdit.cpp	/^Iter TSHEdit::XYtoItr(int& x, int& y)$/;"	f	class:TSHEdit	signature:(int& x, int& y)
XYtoItr	cSHEdit.h	/^      Iter XYtoItr(int& x, int& y);                                                                  \/*!< Converts coordinates to coresponding iterator. *\/$/;"	p	class:SHEdit::TSHEdit	access:private	signature:(int& x, int& y)
X_OFF	config.h	39;"	d
Y_OFF	config.h	38;"	d
_AddJump	uLanguageDefinition.cpp	/^void LanguageDefinition::_AddJump(bool begin, wchar_t * string, FontStyle * format, LangDefJumpType type, TreeNode * at, TreeNode * to, short jumpmask, short newmask, short gmask)$/;"	f	class:LanguageDefinition	signature:(bool begin, wchar_t * string, FontStyle * format, LangDefJumpType type, TreeNode * at, TreeNode * to, short jumpmask, short newmask, short gmask)
_AddJump	uLanguageDefinition.h	/^      void _AddJump(bool tobegin, wchar_t * string, FontStyle * format, LangDefJumpType type, TreeNode * at, TreeNode * to, short jumpmask, short newmask, short newgmask); \/*!< Adds a custom jump from "at" tree to "to" tree.*\/$/;"	p	class:SHEdit::LanguageDefinition	access:private	signature:(bool tobegin, wchar_t * string, FontStyle * format, LangDefJumpType type, TreeNode * at, TreeNode * to, short jumpmask, short newmask, short newgmask)
_AddPush	uLanguageDefinition.cpp	/^void LanguageDefinition::_AddPush(bool begin, wchar_t * string, FontStyle * format, TreeNode * at, TreeNode * to, short pushmask, short newmask, short gmask)$/;"	f	class:LanguageDefinition	signature:(bool begin, wchar_t * string, FontStyle * format, TreeNode * at, TreeNode * to, short pushmask, short newmask, short gmask)
_AddPush	uLanguageDefinition.h	/^      void _AddPush(bool tobegin, wchar_t * string, FontStyle * format, TreeNode * at, TreeNode * to, short pushmask, short newmask, short newgmask);$/;"	p	class:SHEdit::LanguageDefinition	access:private	signature:(bool tobegin, wchar_t * string, FontStyle * format, TreeNode * at, TreeNode * to, short pushmask, short newmask, short newgmask)
_DEBUG_REPAINT	config.h	11;"	d
_Delete	uBuffer.cpp	/^void Buffer::_Delete(NSpan * word)$/;"	f	class:Buffer	signature:(NSpan * word)
_Delete	uBuffer.cpp	/^void Buffer::_Delete(Span * word)$/;"	f	class:Buffer	signature:(Span * word)
_Delete	uBuffer.h	/^      void _Delete(NSpan * word);$/;"	p	class:SHEdit::Buffer	access:private	signature:(NSpan * word)
_Delete	uBuffer.h	/^      void _Delete(Span * word);$/;"	p	class:SHEdit::Buffer	access:private	signature:(Span * word)
_DeleteAt	uBuffer.cpp	/^Range * Buffer::_DeleteAt(Iter * From, Iter * To, bool writeundo, bool forcenew)$/;"	f	class:Buffer	signature:(Iter * From, Iter * To, bool writeundo, bool forcenew)
_DeleteAt	uBuffer.h	/^      Range * _DeleteAt(Iter * From, Iter * To, bool writeundo, bool forcenew);$/;"	p	class:SHEdit::Buffer	access:private	signature:(Iter * From, Iter * To, bool writeundo, bool forcenew)
_Insert	uBuffer.cpp	/^void Buffer::_Insert(NSpan * word)$/;"	f	class:Buffer	signature:(NSpan * word)
_Insert	uBuffer.cpp	/^void Buffer::_Insert(Span * word)$/;"	f	class:Buffer	signature:(Span * word)
_Insert	uBuffer.h	/^      void _Insert(NSpan * word);$/;"	p	class:SHEdit::Buffer	access:private	signature:(NSpan * word)
_Insert	uBuffer.h	/^      void _Insert(Span * word);$/;"	p	class:SHEdit::Buffer	access:private	signature:(Span * word)
_InsertAt	uBuffer.cpp	/^Range * Buffer::_InsertAt(NSpan * line, Span * word, int pos, const wchar_t * string, bool writeundo, bool forcenew)   \/\/OK$/;"	f	class:Buffer	signature:(NSpan * line, Span * word, int pos, const wchar_t * string, bool writeundo, bool forcenew)
_InsertAt	uBuffer.h	/^      Range * _InsertAt(NSpan * line, Span * word, int pos, const wchar_t * string, bool writeundo, bool forcenew);$/;"	p	class:SHEdit::Buffer	access:private	signature:(NSpan * line, Span * word, int pos, const wchar_t * string, bool writeundo, bool forcenew)
_ParseWord	uBuffer.cpp	/^wchar_t* Buffer::_ParseWord(const wchar_t *& ptr, const wchar_t * ptrend)             \/\/OK$/;"	f	class:Buffer	signature:(const wchar_t *& ptr, const wchar_t * ptrend)
_ParseWord	uBuffer.h	/^      wchar_t * _ParseWord(const wchar_t *& ptr, const wchar_t * ptrend);$/;"	p	class:SHEdit::Buffer	access:private	signature:(const wchar_t *& ptr, const wchar_t * ptrend)
_SplitAt	uBuffer.cpp	/^Span* Buffer::_SplitAt(Iter * At)$/;"	f	class:Buffer	signature:(Iter * At)
_SplitAt	uBuffer.h	/^      Span* _SplitAt(Iter * At);$/;"	p	class:SHEdit::Buffer	access:private	signature:(Iter * At)
_SplitBegin	uBuffer.cpp	/^Span* Buffer::_SplitBegin(Iter * At)$/;"	f	class:Buffer	signature:(Iter * At)
_SplitBegin	uBuffer.h	/^      Span* _SplitBegin(Iter * At);$/;"	p	class:SHEdit::Buffer	access:private	signature:(Iter * At)
_SplitEnd	uBuffer.cpp	/^Span* Buffer::_SplitEnd(Iter * At)$/;"	f	class:Buffer	signature:(Iter * At)
_SplitEnd	uBuffer.h	/^      Span* _SplitEnd(Iter * At);$/;"	p	class:SHEdit::Buffer	access:private	signature:(Iter * At)
actFormat	uParser.h	/^      FontStyle actFormat;$/;"	m	class:SHEdit::Parser	access:private
actIMarkup	uParser.h	/^      FontStyle actIMarkup;$/;"	m	class:SHEdit::Parser	access:private
actMarkup	uParser.h	/^      FontStyle actMarkup;$/;"	m	class:SHEdit::Parser	access:private
actMarkupCombined	uParser.h	/^      FontStyle actMarkupCombined;$/;"	m	class:SHEdit::Parser	access:private
actText	uParser.h	/^      String actText;$/;"	m	class:SHEdit::Parser	access:private
action	uSpan.h	/^    Action * action;$/;"	m	struct:SHEdit::UndoTask	access:public
allowWhiteSkipping	uLanguageDefinition.h	/^      bool allowWhiteSkipping;$/;"	m	class:SHEdit::LanguageDefinition	access:private
approach	DOCUMENTATION	/^The data are stored in the buffer in a two-level linked list, which maintains a continuous text stream on one level, and a newline list on the other one. Almost entire data structure is designed "lineary" - without binary tree indexes, mainly because of relatively high time complexity of keeping the binary tree up-to-date (at least that was the original idea) - that means, main approach, that amortizes time complexity to be constant (considering the size of buffer) (except for line movements) is to have an iterator that points to the current position of application's view, without having access to information about the rest of the data (there is implemented just a linear positioning system, which keeps a track of the current line number and offset, and which keeps all the iterators valid and having the correct positioning info). Above the buffer is the component (the actual TSHEdit class), whose job is to process all user input, to let the buffer insert and remove text, to handle undo and redo funcionality, and to manage the painting of the screen. When updating the screen, the component repaints just those parts of the screen that are no longer valid (by lines - always an entire line is reparsed\/repainted). Lines which need to be repainted or reparsed are handed over to the Parser whose job is to parse the lines and to send those that are in visible part of the screen further to drawer which draws them. The Parser works "asynchronously" - can reparse every time just what it needs to reparse while maintaining the context through an entire buffer.$/;"	v
background	uFormat.h	/^      TColor * background;$/;"	m	class:SHEdit::FontStyle	access:public
background	uLanguageDefinitionSQL.h	/^    TColor background;$/;"	m	class:SHEdit::LanguageDefinitionSQL	access:private
base	uLanguageDefinition.h	/^        TreeNode * base;$/;"	m	struct:SHEdit::LanguageDefinition::SearchIter	access:public
begin	cSHEdit.cpp	/^CIter TSHEdit::begin()$/;"	f	class:TSHEdit	signature:()
begin	cSHEdit.h	/^      CIter begin();$/;"	p	class:SHEdit::TSHEdit	access:public	signature:()
begin	uBuffer.cpp	/^Iter Buffer::begin()$/;"	f	class:Buffer	signature:()
begin	uBuffer.h	/^      Iter begin();$/;"	p	class:SHEdit::Buffer	access:public	signature:()
begin	uMark.h	/^      bool begin;$/;"	m	class:SHEdit::IMark	access:public
begin	uMark.h	/^      bool begin;$/;"	m	class:SHEdit::Mark	access:public
begin	uStack.h	/^    iterator begin(){return iterator(top);}$/;"	f	class:Stack	access:public	signature:()
bitmap	uDrawer.h	/^      Graphics::TBitmap * bitmap;$/;"	m	class:SHEdit::Drawer	access:private
buffer	cSHEdit.h	/^      Buffer * buffer;                                                                               \/*!< *\/$/;"	m	class:SHEdit::TSHEdit	access:private
buffer	uIPos.h	/^      Buffer * buffer;                                                                               \/*!< A pointer to buffer that owns data pointed to by IPos instance. If buffer is null, then IPos or Iter respectively works in a "position less mode", and in that case does not guarantee to remain valid*\/$/;"	m	class:SHEdit::IPos	access:public
cSHEditH	cSHEdit.h	4;"	d
call	uLanguageDefinition2.h	/^        bool call;$/;"	m	struct:SHEdit::LanguageDefinition::NTerm	access:public
call	uLanguageDefinition2.h	/^        bool call;$/;"	m	struct:SHEdit::LanguageDefinition::Term	access:public
canvas	uDrawer.h	/^      TCanvas * canvas;$/;"	m	class:SHEdit::Drawer	access:private
caseSensitive	uLanguageDefinition.h	/^        bool caseSensitive;$/;"	m	struct:SHEdit::LanguageDefinition::TreeNode	access:public
caseSensitive	uLanguageDefinition.h	/^      bool caseSensitive;$/;"	m	class:SHEdit::LanguageDefinition	access:private
cases	fSearchBar.h	/^  bool cases;$/;"	m	class:TSearchBar	access:public
charge	LICENSE	/^Permission is hereby granted, free of charge, to any person obtaining a$/;"	v
clipboard	cSHEdit.h	/^      TClipboard * clipboard;$/;"	m	class:SHEdit::TSHEdit	access:protected
comment	uLanguageDefinitionSQL.h	/^    TColor comment;$/;"	m	class:SHEdit::LanguageDefinitionSQL	access:private
commentback	uLanguageDefinitionSQL.h	/^    TColor commentback;$/;"	m	class:SHEdit::LanguageDefinitionSQL	access:private
compare	uIPos.h	/^      struct compare$/;"	s	class:SHEdit::IPos	access:public
component	uCursor.h	/^              TSHEdit * component;$/;"	m	class:SHEdit::CIter	access:private
con	uDrawer.h	/^      bool con;   \/\/cursorOn$/;"	m	class:SHEdit::Drawer	access:private
copy	LICENSE	/^the rights to use, copy, modify, merge, publish, distribute, sublicense,$/;"	v
cssAttr	uLanguageDefinitionWebLangs.h	/^      TColor cssAttr;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
cssBG	uLanguageDefinitionWebLangs.h	/^      TColor cssBG;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
cssEnterTree	uLanguageDefinitionWebLangs.h	/^      TreeNode * cssEnterTree;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
cssFG	uLanguageDefinitionWebLangs.h	/^      TColor cssFG;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
cssPropertyTree	uLanguageDefinitionWebLangs.h	/^      TreeNode * cssPropertyTree;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
cssQuoteTree	uLanguageDefinitionWebLangs.h	/^      TreeNode * cssQuoteTree;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
cssTree	uLanguageDefinitionWebLangs.h	/^      TreeNode * cssTree;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
cssVal	uLanguageDefinitionWebLangs.h	/^      TColor cssVal;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
cssValueTree	uLanguageDefinitionWebLangs.h	/^      TreeNode * cssValueTree;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
current	uLanguageDefinition.h	/^        TreeNode * current;$/;"	m	struct:SHEdit::LanguageDefinition::SearchIter	access:public
currentparseid	uParser.h	/^      short currentparseid;$/;"	m	class:SHEdit::Parser	access:private
cursorBGcolor	uDrawer.h	/^      TColor cursorBGcolor;$/;"	m	class:SHEdit::Drawer	access:private
cursorLeftOffset	cSHEdit.h	/^      int cursorLeftOffset;                                                                          \/*!< Column of the cursor, taking into account tabulators. This does NOT equal iterator position.*\/$/;"	m	class:SHEdit::TSHEdit	access:private
cx	cSHEdit.h	/^      int cx, cy;                                                                                    \/*!< Cursor position*\/$/;"	m	class:SHEdit::TSHEdit	access:private
cx	uDrawer.h	/^      int cx, cy;$/;"	m	class:SHEdit::Drawer	access:private
cy	cSHEdit.h	/^      int cx, cy;                                                                                    \/*!< Cursor position*\/$/;"	m	class:SHEdit::TSHEdit	access:private
cy	uDrawer.h	/^      int cx, cy;$/;"	m	class:SHEdit::Drawer	access:private
data	uBuffer.h	/^      Range* data;$/;"	m	class:SHEdit::Buffer	access:private
data	uStack.h	/^      T_data data;$/;"	m	struct:Stack::Node	access:public
dbgIter	cSHEdit.cpp	/^void __fastcall TSHEdit::dbgIter()$/;"	f	class:TSHEdit	signature:()
dbgIter	cSHEdit.h	/^      void __fastcall dbgIter();$/;"	p	class:SHEdit::TSHEdit	access:public	signature:()
dbgLog	cSHEdit.h	/^      TMemo * dbgLog;$/;"	m	class:SHEdit::TSHEdit	access:public
dbgLogging	uParser.h	/^      bool dbgLogging;$/;"	m	class:SHEdit::Parser	access:public
dbgscb	uParser.h	/^      int dbgscb;$/;"	m	class:SHEdit::Parser	access:private
debugcount	uDrawer.h	/^      int debugcount;$/;"	m	class:SHEdit::Drawer	access:private
debugtasks	uDrawer.h	/^      int debugtasks;$/;"	m	class:SHEdit::Drawer	access:private
defFormat	uLanguageDefinition.h	/^      FontStyle * defFormat;$/;"	m	class:SHEdit::LanguageDefinition	access:private
deletion	uSpan.h	/^    enum ActionType{deletion, insertion};$/;"	e	enum:SHEdit::Action::ActionType
distribute	LICENSE	/^the rights to use, copy, modify, merge, publish, distribute, sublicense,$/;"	v
drawcanvas	uDrawer.h	/^      TCanvas * drawcanvas;$/;"	m	class:SHEdit::Drawer	access:private
drawer	cSHEdit.h	/^      Drawer * drawer;$/;"	m	class:SHEdit::TSHEdit	access:private
drawer	uParser.h	/^      Drawer * drawer;$/;"	m	class:SHEdit::Parser	access:private
dx	cSHEdit.h	/^      int dx, dy;                                                                                    \/*!< Position of mouse down.*\/$/;"	m	class:SHEdit::TSHEdit	access:private
dy	cSHEdit.h	/^      int dx, dy;                                                                                    \/*!< Position of mouse down.*\/$/;"	m	class:SHEdit::TSHEdit	access:private
empty	uSpan.h	/^    bool empty;$/;"	m	struct:SHEdit::Range	access:public
end	cSHEdit.cpp	/^CIter TSHEdit::end()$/;"	f	class:TSHEdit	signature:()
end	cSHEdit.h	/^      CIter end();$/;"	p	class:SHEdit::TSHEdit	access:public	signature:()
end	uBuffer.cpp	/^Iter Buffer::end()$/;"	f	class:Buffer	signature:()
end	uBuffer.h	/^      Iter end();$/;"	p	class:SHEdit::Buffer	access:public	signature:()
end	uStack.h	/^    iterator end(){return iterator(NULL);}$/;"	f	class:Stack	access:public	signature:()
entering	uLanguageDefinition2.h	/^      Node* entering;$/;"	m	class:SHEdit::LanguageDefinition	access:private
fSearchBarH	fSearchBar.h	4;"	d
fallbackLangDef	cSHEdit.h	/^      LanguageDefinition * fallbackLangDef;$/;"	m	class:SHEdit::TSHEdit	access:private
first	uBuffer.cpp	/^Iter Buffer::first()   \/\/technically shows wrong location - just if we NEED to maintain a link to fist link no matter what gets inserted$/;"	f	class:Buffer	signature:()
first	uBuffer.h	/^      Iter first();$/;"	p	class:SHEdit::Buffer	access:public	signature:()
first	uSpan.h	/^    Span* first;$/;"	m	struct:SHEdit::Range	access:public
firstLine	uSpan.h	/^    NSpan* firstLine;$/;"	m	struct:SHEdit::Range	access:public
flags	uLanguageDefinition2.h	/^      enum flags {tfCall = 1, tfGetStyle = 2, tfGather = 4, tfGlobal = 8, tfCaseSens = 16, tfEntering = 32};$/;"	g	class:SHEdit::LanguageDefinition	access:public
fontsize	uDrawer.h	/^      int fontsize;$/;"	m	class:SHEdit::Drawer	access:private
foreground	uFormat.h	/^      TColor * foreground;$/;"	m	class:SHEdit::FontStyle	access:public
foreground	uLanguageDefinitionSQL.h	/^    TColor foreground;$/;"	m	class:SHEdit::LanguageDefinitionSQL	access:private
format	tags	/^!_TAG_FILE_FORMAT	2	\/extended format; --format=1 will not append ;" to lines\/$/;"	v
format	uLanguageDefinition.h	/^        FontStyle * format;$/;"	m	struct:SHEdit::LanguageDefinition::Jump	access:public
format	uLanguageDefinition.h	/^        FontStyle * format;$/;"	m	struct:SHEdit::LanguageDefinition::Pop	access:public
format	uLanguageDefinition.h	/^        FontStyle * format;$/;"	m	struct:SHEdit::LanguageDefinition::TreeNode	access:public
format	uMark.h	/^      Format * format;$/;"	m	class:SHEdit::IMark	access:public
format	uMark.h	/^      Format * format;$/;"	m	class:SHEdit::Mark	access:public
forward	fSearchBar.h	/^  bool forward;$/;"	m	class:TSearchBar	access:public
fromlinenum	uSpan.h	/^    int fromlinenum;$/;"	m	struct:SHEdit::Action	access:public
frompos	uSpan.h	/^    int frompos;$/;"	m	struct:SHEdit::Action	access:public
fs	uLanguageDefinition2.h	/^        FontStyle* fs;$/;"	m	struct:SHEdit::LanguageDefinition::NTerm	access:public
fs	uLanguageDefinition2.h	/^        FontStyle* fs;$/;"	m	struct:SHEdit::LanguageDefinition::Term	access:public
gather	uLanguageDefinition2.h	/^        bool gather;$/;"	m	struct:SHEdit::LanguageDefinition::NTerm	access:public
gather	uLanguageDefinition2.h	/^        bool gather;$/;"	m	struct:SHEdit::LanguageDefinition::Term	access:public
getstyle	uLanguageDefinition2.h	/^        bool getstyle;$/;"	m	struct:SHEdit::LanguageDefinition::Term	access:public
global	uLanguageDefinition2.h	/^      Node* global;$/;"	m	class:SHEdit::LanguageDefinition	access:private
globalMask	uParser.h	/^        short globalMask;$/;"	m	struct:SHEdit::Parser::ParserState	access:public
htmlAttribs	uLanguageDefinitionWebLangs.h	/^      TColor htmlAttribs;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
htmlBG	uLanguageDefinitionWebLangs.h	/^      TColor htmlBG;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
htmlCommentTree	uLanguageDefinitionWebLangs.h	/^      TreeNode * htmlCommentTree;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
htmlComments	uLanguageDefinitionWebLangs.h	/^      TColor htmlComments;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
htmlFG	uLanguageDefinitionWebLangs.h	/^      TColor htmlFG;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
htmlQuoteTree	uLanguageDefinitionWebLangs.h	/^      TreeNode * htmlQuoteTree;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
htmlQuotes	uLanguageDefinitionWebLangs.h	/^      TColor htmlQuotes;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
htmlTagTree	uLanguageDefinitionWebLangs.h	/^      TreeNode * htmlTagTree;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
htmlTags	uLanguageDefinitionWebLangs.h	/^      TColor htmlTags;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
htmlTree	uLanguageDefinitionWebLangs.h	/^      TreeNode * htmlTree;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
ids	uLanguageDefinition2.h	/^      int ids;$/;"	m	class:SHEdit::LanguageDefinition	access:private
imarks	uFormat.h	/^      std::set<IPos*, IMark::compare> imarks; \/\/Actually stores IMark pointers casted to pos for comparison$/;"	m	class:SHEdit::Format	access:private
index	uLanguageDefinition2.h	/^      std::map<std::wstring, Rec> index;$/;"	m	class:SHEdit::LanguageDefinition	access:private
insertion	uSpan.h	/^    enum ActionType{deletion, insertion};$/;"	e	enum:SHEdit::Action::ActionType
inword	uParser.h	/^      bool inword;$/;"	m	class:SHEdit::Parser	access:private
iptIter	uIPos.h	/^      enum IPType{iptPos, iptIter, iptMark};$/;"	e	enum:SHEdit::IPos::IPType
iptMark	uIPos.h	/^      enum IPType{iptPos, iptIter, iptMark};$/;"	e	enum:SHEdit::IPos::IPType
iptPos	uIPos.h	/^      enum IPType{iptPos, iptIter, iptMark};$/;"	e	enum:SHEdit::IPos::IPType
items	uLanguageDefinition.h	/^        std::list<TreeNode*> items;$/;"	m	struct:SHEdit::LanguageDefinition::TreeNode	access:public
iterator	uStack.h	/^      iterator(Node * p) : ptr(p) {};$/;"	f	struct:Stack::iterator	access:public	signature:(Node * p)
iterator	uStack.h	/^    struct iterator$/;"	s	class:Stack	access:public
itr	uCursor.h	/^                Iter itr;$/;"	m	class:SHEdit::CIter	access:private
itrCursor	cSHEdit.h	/^      Iter itrCursor;                                                                                \/*!< Points to actually edited position. If there is mouse drag occuring, then itrCursor is always position where drag started, To get begenning of selected area, use GetCursor() function*\/$/;"	m	class:SHEdit::TSHEdit	access:private
itrCursorSecond	cSHEdit.h	/^      Iter itrCursorSecond;                                                                          \/*!< Serves for mouse dragging - always is the iterator that is dragged along*\/$/;"	m	class:SHEdit::TSHEdit	access:private
itrLine	cSHEdit.h	/^      Iter itrLine;                                                                                  \/*!< Iterator that points to the first line of window*\/$/;"	m	class:SHEdit::TSHEdit	access:private
jumpcount	uLanguageDefinition.h	/^        short jumpcount;$/;"	m	struct:SHEdit::LanguageDefinition::TreeNode	access:public
jumps	uLanguageDefinition.h	/^        Jump * jumps; \/\/an array$/;"	m	struct:SHEdit::LanguageDefinition::TreeNode	access:public
jvBG	uLanguageDefinitionWebLangs.h	/^      TColor jvBG;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
jvCommentTree	uLanguageDefinitionWebLangs.h	/^      TreeNode * jvCommentTree;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
jvComments	uLanguageDefinitionWebLangs.h	/^      TColor jvComments;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
jvEnterTree	uLanguageDefinitionWebLangs.h	/^      TreeNode * jvEnterTree;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
jvFG	uLanguageDefinitionWebLangs.h	/^      TColor jvFG;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
jvKeywords	uLanguageDefinitionWebLangs.h	/^      TColor jvKeywords;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
jvLineCommentTree	uLanguageDefinitionWebLangs.h	/^      TreeNode * jvLineCommentTree;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
jvQuoteTree	uLanguageDefinitionWebLangs.h	/^      TreeNode * jvQuoteTree;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
jvQuotes	uLanguageDefinitionWebLangs.h	/^      TColor jvQuotes;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
jvTree	uLanguageDefinitionWebLangs.h	/^      TreeNode * jvTree;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
keepHistory	uBuffer.h	/^      bool keepHistory;$/;"	m	class:SHEdit::Buffer	access:public
langdef	uParser.h	/^      LanguageDefinition * langdef;$/;"	m	class:SHEdit::Parser	access:private
last	uSpan.h	/^    Span* last;$/;"	m	struct:SHEdit::Range	access:public
lastLine	uSpan.h	/^    NSpan* lastLine;$/;"	m	struct:SHEdit::Range	access:public
lastlinenumcount	uDrawer.h	/^      int lastlinenumcount; \/\/to be able to update lw automatically$/;"	m	class:SHEdit::Drawer	access:private
length	uSpan.h	/^    short length;$/;"	m	struct:SHEdit::Span	access:public
level	DOCUMENTATION	/^The data are stored in the buffer in a two-level linked list, which maintains a continuous text stream on one level, and a newline list on the other one. Almost entire data structure is designed "lineary" - without binary tree indexes, mainly because of relatively high time complexity of keeping the binary tree up-to-date (at least that was the original idea) - that means, main approach, that amortizes time complexity to be constant (considering the size of buffer) (except for line movements) is to have an iterator that points to the current position of application's view, without having access to information about the rest of the data (there is implemented just a linear positioning system, which keeps a track of the current line number and offset, and which keeps all the iterators valid and having the correct positioning info). Above the buffer is the component (the actual TSHEdit class), whose job is to process all user input, to let the buffer insert and remove text, to handle undo and redo funcionality, and to manage the painting of the screen. When updating the screen, the component repaints just those parts of the screen that are no longer valid (by lines - always an entire line is reparsed\/repainted). Lines which need to be repainted or reparsed are handed over to the Parser whose job is to parse the lines and to send those that are in visible part of the screen further to drawer which draws them. The Parser works "asynchronously" - can reparse every time just what it needs to reparse while maintaining the context through an entire buffer.$/;"	v
lftidx	uLanguageDefinition2.h	/^        std::map<int, Node*> lftidx; \/\/leave index$/;"	m	struct:SHEdit::LanguageDefinition::Node	access:public
line	uIPos.h	/^      NSpan * line;                                                                                  \/*!< Pointer to the befinning of current line. Positioning relies on correct line and linenum initialization. Other members can be recalculated *\/$/;"	m	class:SHEdit::IPos	access:public
line	uParser.h	/^        NSpan * line;$/;"	m	struct:SHEdit::Parser::ParseTask	access:public
linecount	uSpan.h	/^    int linecount;$/;"	m	struct:SHEdit::Range	access:public
lineempty	uSpan.h	/^    bool lineempty;$/;"	m	struct:SHEdit::Range	access:public
linenum	uIPos.h	/^      int linenum;                                                                                   \/*!< Line number of relative line. Is correct as long as it was correctly initialized and the buffer pointer is valid *\/$/;"	m	class:SHEdit::IPos	access:public
linenum	uParser.h	/^        int linenum;$/;"	m	struct:SHEdit::Parser::ParseTask	access:public
linenum	uParser.h	/^      short linenum;$/;"	m	class:SHEdit::Parser	access:private
linenumsenabled	uDrawer.h	/^      bool linenumsenabled;$/;"	m	class:SHEdit::Drawer	access:private
linenumwidth	uDrawer.h	/^      int linenumwidth;$/;"	m	class:SHEdit::Drawer	access:private
linesize	uDrawer.h	/^      int linesize;$/;"	m	class:SHEdit::Drawer	access:private
loc	uLanguageDefinition2.h	/^      std::locale loc;$/;"	m	class:SHEdit::LanguageDefinition	access:private
main	uLangDef2Test.cpp	/^int main()$/;"	f	signature:()
map	uLanguageDefinition.h	/^        TreeNode * map[128];$/;"	m	struct:SHEdit::LanguageDefinition::TreeNode	access:public
marks	uFormat.h	/^      std::list< Stack<Mark >::Node* > marks;$/;"	m	class:SHEdit::Format	access:private
marks	uSpan.h	/^    Stack<Mark> marks;$/;"	m	struct:SHEdit::Span	access:public
markupMask	uBuffer.h	/^      short markupMask;$/;"	m	class:SHEdit::Buffer	access:private
markupStack	uParser.h	/^        Stack<Format*> markupStack;$/;"	m	struct:SHEdit::Parser::ParserState	access:public
mask	uLanguageDefinition.h	/^        short mask;$/;"	m	struct:SHEdit::LanguageDefinition::SearchIter	access:public
maxScrollStep	cSHEdit.h	/^      int maxScrollStep;$/;"	m	class:SHEdit::TSHEdit	access:private
means	DOCUMENTATION	/^The data are stored in the buffer in a two-level linked list, which maintains a continuous text stream on one level, and a newline list on the other one. Almost entire data structure is designed "lineary" - without binary tree indexes, mainly because of relatively high time complexity of keeping the binary tree up-to-date (at least that was the original idea) - that means, main approach, that amortizes time complexity to be constant (considering the size of buffer) (except for line movements) is to have an iterator that points to the current position of application's view, without having access to information about the rest of the data (there is implemented just a linear positioning system, which keeps a track of the current line number and offset, and which keeps all the iterators valid and having the correct positioning info). Above the buffer is the component (the actual TSHEdit class), whose job is to process all user input, to let the buffer insert and remove text, to handle undo and redo funcionality, and to manage the painting of the screen. When updating the screen, the component repaints just those parts of the screen that are no longer valid (by lines - always an entire line is reparsed\/repainted). Lines which need to be repainted or reparsed are handed over to the Parser whose job is to parse the lines and to send those that are in visible part of the screen further to drawer which draws them. The Parser works "asynchronously" - can reparse every time just what it needs to reparse while maintaining the context through an entire buffer.$/;"	v
merge	LICENSE	/^the rights to use, copy, modify, merge, publish, distribute, sublicense,$/;"	v
modify	LICENSE	/^the rights to use, copy, modify, merge, publish, distribute, sublicense,$/;"	v
mouseDoubleClickFlag	cSHEdit.h	/^      bool mouseDoubleClickFlag;$/;"	m	class:SHEdit::TSHEdit	access:private
mouseDown	cSHEdit.h	/^      bool mouseDown;$/;"	m	class:SHEdit::TSHEdit	access:private
mouseSelect	cSHEdit.h	/^      bool mouseSelect;                                                                              \/*!< Whether component is in text-selection (=mouse drag) mode.*\/$/;"	m	class:SHEdit::TSHEdit	access:private
msgLock	cSHEdit.h	/^      bool msgLock;$/;"	m	class:SHEdit::TSHEdit	access:private
mx	cSHEdit.h	/^      int mx, my;                                                                                    \/*!< Position of itrCursorSecond*\/$/;"	m	class:SHEdit::TSHEdit	access:private
my	cSHEdit.h	/^      int mx, my;                                                                                    \/*!< Position of itrCursorSecond*\/$/;"	m	class:SHEdit::TSHEdit	access:private
myown	uCursor.h	/^                bool myown;$/;"	m	class:SHEdit::CIter	access:private
name	uLanguageDefinition2.h	/^        std::wstring name;$/;"	m	struct:SHEdit::LanguageDefinition::NTerm	access:public
name	uLanguageDefinition2.h	/^        std::wstring name;$/;"	m	struct:SHEdit::LanguageDefinition::Term	access:public
newgmask	uLanguageDefinition.h	/^        short newgmask;$/;"	m	struct:SHEdit::LanguageDefinition::Jump	access:public
newgmask	uLanguageDefinition.h	/^        short newgmask;$/;"	m	struct:SHEdit::LanguageDefinition::Pop	access:public
newline	uParser.h	/^      bool newline;$/;"	m	class:SHEdit::Parser	access:private
newmask	uLanguageDefinition.h	/^        short newmask;$/;"	m	struct:SHEdit::LanguageDefinition::Jump	access:public
next	uSpan.h	/^    Span* next;$/;"	m	struct:SHEdit::Span	access:public
next	uStack.h	/^      Node * next;$/;"	m	struct:Stack::Node	access:public
nextTree	uLanguageDefinition.h	/^        TreeNode * nextTree;$/;"	m	struct:SHEdit::LanguageDefinition::Jump	access:public
nextimark	uIter.h	/^      int nextimark;                                                                                 \/*!< See the Iter class info for explanation *\/$/;"	m	class:SHEdit::Iter	access:protected
nextimarkln	uIter.h	/^      int nextimarkln;                                                                               \/*!< See the Iter class info for explanation *\/$/;"	m	class:SHEdit::Iter	access:protected
nextline	uSpan.h	/^    NSpan * nextline;$/;"	m	struct:SHEdit::NSpan	access:public
nextnodes	uLanguageDefinition2.h	/^        std::vector<Node*> nextnodes;$/;"	m	struct:SHEdit::LanguageDefinition::Node	access:public
node	uLanguageDefinition2.h	/^        Node* node;$/;"	m	struct:SHEdit::LanguageDefinition::NTerm	access:public
nodes	uLanguageDefinition2.h	/^      std::set<Node*> nodes; \/\/temporary - for construction (and maybe for destruction?)$/;"	m	class:SHEdit::LanguageDefinition	access:private
nonterms	uLanguageDefinition2.h	/^      std::vector<NTerm*> nonterms;$/;"	m	class:SHEdit::LanguageDefinition	access:private
nt	uLanguageDefinition2.h	/^        NTerm* nt;$/;"	m	struct:SHEdit::LanguageDefinition::Rec	access:public
ntEnd	uLanguageDefinition2.h	/^      enum NType {ntTerm, ntNTerm, ntLambda, ntEnd, ntTailrec};$/;"	e	enum:SHEdit::LanguageDefinition::NType
ntLambda	uLanguageDefinition2.h	/^      enum NType {ntTerm, ntNTerm, ntLambda, ntEnd, ntTailrec};$/;"	e	enum:SHEdit::LanguageDefinition::NType
ntNTerm	uLanguageDefinition2.h	/^      enum NType {ntTerm, ntNTerm, ntLambda, ntEnd, ntTailrec};$/;"	e	enum:SHEdit::LanguageDefinition::NType
ntTailrec	uLanguageDefinition2.h	/^      enum NType {ntTerm, ntNTerm, ntLambda, ntEnd, ntTailrec};$/;"	e	enum:SHEdit::LanguageDefinition::NType
ntTerm	uLanguageDefinition2.h	/^      enum NType {ntTerm, ntNTerm, ntLambda, ntEnd, ntTailrec};$/;"	e	enum:SHEdit::LanguageDefinition::NType
number	uLanguageDefinitionSQL.h	/^    TColor number ;$/;"	m	class:SHEdit::LanguageDefinitionSQL	access:private
offset	uIter.h	/^      int offset;                                                                                    \/*!< Offset from beginning of current Span *\/$/;"	m	class:SHEdit::Iter	access:protected
oldidle	uParser.h	/^      TIdleEvent oldidle;$/;"	m	class:SHEdit::Parser	access:private
onidleset	uParser.h	/^      bool onidleset;$/;"	m	class:SHEdit::Parser	access:private
operator !=	uFormat.cpp	/^bool FontStyle::operator!=(const SHEdit::FontStyle& f)$/;"	f	class:FontStyle	signature:(const SHEdit::FontStyle& f)
operator !=	uFormat.cpp	/^bool Format::operator!=(const SHEdit::Format& f)$/;"	f	class:Format	signature:(const SHEdit::Format& f)
operator !=	uFormat.h	/^      bool operator!=(const FontStyle& f);$/;"	p	class:SHEdit::FontStyle	access:public	signature:(const FontStyle& f)
operator !=	uFormat.h	/^      bool operator!=(const Format& f);$/;"	p	class:SHEdit::Format	access:public	signature:(const Format& f)
operator !=	uIter.cpp	/^bool Iter::operator!=(const Iter& itr)$/;"	f	class:Iter	signature:(const Iter& itr)
operator !=	uIter.h	/^      bool operator!=(const Iter& itr);$/;"	p	class:SHEdit::Iter	access:public	signature:(const Iter& itr)
operator !=	uLanguageDefinition.cpp	/^bool LanguageDefinition::SearchIter::operator!=(const SearchIter& sit)$/;"	f	class:LanguageDefinition::SearchIter	signature:(const SearchIter& sit)
operator !=	uLanguageDefinition.h	/^        bool operator!=(const SearchIter& sit);$/;"	p	struct:SHEdit::LanguageDefinition::SearchIter	access:public	signature:(const SearchIter& sit)
operator !=	uParser.cpp	/^bool Parser::ParserState::operator!=(const ParserState& state)$/;"	f	class:Parser::ParserState	signature:(const ParserState& state)
operator !=	uParser.h	/^        bool operator!=(const ParserState& state);$/;"	p	struct:SHEdit::Parser::ParserState	access:public	signature:(const ParserState& state)
operator !=	uStack.h	/^      bool& operator!=(const iterator& i){return !(*this == i);}$/;"	f	struct:Stack::iterator	access:public	signature:(const iterator& i)
operator ()	uIPos.cpp	/^bool IPos::compare::operator()(const IPos* a, const IPos* b) const$/;"	f	class:IPos::compare	signature:(const IPos* a, const IPos* b) const
operator ()	uIPos.h	/^        bool operator()(const IPos* a, const IPos* b) const;$/;"	p	struct:SHEdit::IPos::compare	access:public	signature:(const IPos* a, const IPos* b) const
operator *	uIter.cpp	/^wchar_t& Iter::operator*()$/;"	f	class:Iter	signature:()
operator *	uIter.h	/^      wchar_t& operator*();$/;"	p	class:SHEdit::Iter	access:public	signature:()
operator *	uStack.h	/^      T_data& operator*() {return ptr->data};$/;"	f	struct:Stack::iterator	access:public	signature:()
operator ++	uIter.cpp	/^Iter& Iter::operator++()$/;"	f	class:Iter	signature:()
operator ++	uIter.h	/^      Iter& operator++();$/;"	p	class:SHEdit::Iter	access:public	signature:()
operator ++	uStack.h	/^      iterator& operator++(){if(ptr != NULL) ptr = ptr->next; return *this}$/;"	f	struct:Stack::iterator	access:public	signature:()
operator +=	uFormat.cpp	/^SHEdit::FontStyle& FontStyle::operator+=(const SHEdit::FontStyle& f)$/;"	f	class:FontStyle	signature:(const SHEdit::FontStyle& f)
operator +=	uFormat.cpp	/^SHEdit::FontStyle& FontStyle::operator+=(const SHEdit::Format& f)$/;"	f	class:FontStyle	signature:(const SHEdit::Format& f)
operator +=	uFormat.cpp	/^SHEdit::Format& Format::operator+=(const SHEdit::Format& f)$/;"	f	class:Format	signature:(const SHEdit::Format& f)
operator +=	uFormat.h	/^      FontStyle& operator+=(const FontStyle& f);$/;"	p	class:SHEdit::FontStyle	access:public	signature:(const FontStyle& f)
operator +=	uFormat.h	/^      FontStyle& operator+=(const Format& f);$/;"	p	class:SHEdit::FontStyle	access:public	signature:(const Format& f)
operator +=	uFormat.h	/^      Format& operator+=(const Format& f);$/;"	p	class:SHEdit::Format	access:public	signature:(const Format& f)
operator --	uIter.cpp	/^Iter& Iter::operator--()$/;"	f	class:Iter	signature:()
operator --	uIter.h	/^      Iter& operator--();$/;"	p	class:SHEdit::Iter	access:public	signature:()
operator ->	uStack.h	/^      T_data* operator->() {return &ptr->data};$/;"	f	struct:Stack::iterator	access:public	signature:()
operator <	uIter.cpp	/^bool Iter::operator<(const Iter& itr)$/;"	f	class:Iter	signature:(const Iter& itr)
operator <	uIter.h	/^      bool operator<(const Iter& itr);$/;"	p	class:SHEdit::Iter	access:public	signature:(const Iter& itr)
operator <	uLanguageDefinition2.h	/^        bool operator<(const Rec& r)const{return GetName() < r.GetName();};$/;"	f	struct:SHEdit::LanguageDefinition::Rec	access:public	signature:(const Rec& r) const
operator <	uParser.cpp	/^bool Parser::ParseTask::operator<(const Parser::ParseTask & pt)  const$/;"	f	class:Parser::ParseTask	signature:(const Parser::ParseTask & pt) const
operator <	uParser.h	/^        bool operator<(const ParseTask & pt)const;$/;"	p	struct:SHEdit::Parser::ParseTask	access:public	signature:(const ParseTask & pt) const
operator =	uFormat.cpp	/^SHEdit::FontStyle& FontStyle::operator=(const SHEdit::FontStyle& f)$/;"	f	class:FontStyle	signature:(const SHEdit::FontStyle& f)
operator =	uFormat.cpp	/^SHEdit::FontStyle& FontStyle::operator=(const SHEdit::Format& f)$/;"	f	class:FontStyle	signature:(const SHEdit::Format& f)
operator =	uFormat.cpp	/^SHEdit::Format& Format::operator=(const SHEdit::Format& f)$/;"	f	class:Format	signature:(const SHEdit::Format& f)
operator =	uFormat.h	/^      FontStyle& operator=(const FontStyle& f);$/;"	p	class:SHEdit::FontStyle	access:public	signature:(const FontStyle& f)
operator =	uFormat.h	/^      FontStyle& operator=(const Format& f);$/;"	p	class:SHEdit::FontStyle	access:public	signature:(const Format& f)
operator =	uFormat.h	/^      Format& operator=(const Format& f);$/;"	p	class:SHEdit::Format	access:public	signature:(const Format& f)
operator =	uIPos.cpp	/^IPos& IPos::operator=(const IPos& p)$/;"	f	class:IPos	signature:(const IPos& p)
operator =	uIPos.h	/^      IPos& operator=(const IPos& p);$/;"	p	class:SHEdit::IPos	access:public	signature:(const IPos& p)
operator =	uIter.cpp	/^Iter& Iter::operator=(const Iter& itr)$/;"	f	class:Iter	signature:(const Iter& itr)
operator =	uIter.h	/^      Iter& operator=(const Iter& itr);$/;"	p	class:SHEdit::Iter	access:public	signature:(const Iter& itr)
operator =	uParser.cpp	/^SHEdit::Parser::ParserState& Parser::ParserState::operator=(const SHEdit::Parser::ParserState& p)$/;"	f	class:Parser::ParserState	signature:(const SHEdit::Parser::ParserState& p)
operator =	uParser.h	/^        ParserState& operator=(const ParserState& p);$/;"	p	struct:SHEdit::Parser::ParserState	access:public	signature:(const ParserState& p)
operator =	uStack.h	/^    Stack<T_data>& operator=(const Stack<T_data>& stack);$/;"	p	class:Stack	access:public	signature:(const Stack<T_data>& stack)
operator =	uStack.h	/^Stack<T_data>& Stack<T_data>::operator=(const Stack<T_data>& stack)$/;"	f	class:Stack	signature:(const Stack<T_data>& stack)
operator ==	uFormat.cpp	/^bool FontStyle::operator==(const SHEdit::FontStyle& f)$/;"	f	class:FontStyle	signature:(const SHEdit::FontStyle& f)
operator ==	uFormat.cpp	/^bool Format::operator==(const SHEdit::Format& f)$/;"	f	class:Format	signature:(const SHEdit::Format& f)
operator ==	uFormat.h	/^      bool operator==(const FontStyle& f);$/;"	p	class:SHEdit::FontStyle	access:public	signature:(const FontStyle& f)
operator ==	uFormat.h	/^      bool operator==(const Format& f);$/;"	p	class:SHEdit::Format	access:public	signature:(const Format& f)
operator ==	uIPos.cpp	/^bool IPos::operator==(const IPos& p)$/;"	f	class:IPos	signature:(const IPos& p)
operator ==	uIPos.h	/^      bool operator==(const IPos& p);$/;"	p	class:SHEdit::IPos	access:public	signature:(const IPos& p)
operator ==	uIter.cpp	/^bool Iter::operator==(const Iter& itr)$/;"	f	class:Iter	signature:(const Iter& itr)
operator ==	uIter.h	/^      bool operator==(const Iter& itr);$/;"	p	class:SHEdit::Iter	access:public	signature:(const Iter& itr)
operator ==	uLanguageDefinition.cpp	/^bool LanguageDefinition::SearchIter::operator==(const SearchIter& sit)$/;"	f	class:LanguageDefinition::SearchIter	signature:(const SearchIter& sit)
operator ==	uLanguageDefinition.h	/^        bool operator==(const SearchIter& sit);$/;"	p	struct:SHEdit::LanguageDefinition::SearchIter	access:public	signature:(const SearchIter& sit)
operator ==	uLanguageDefinition2.cpp	/^bool LanguageDefinition::Node::operator==(const Node& n)$/;"	f	class:LanguageDefinition::Node	signature:(const Node& n)
operator ==	uLanguageDefinition2.h	/^        bool operator==(const Node& n);$/;"	p	struct:SHEdit::LanguageDefinition::Node	access:public	signature:(const Node& n)
operator ==	uParser.cpp	/^bool Parser::ParseTask::operator==(const Parser::ParseTask & pt) const$/;"	f	class:Parser::ParseTask	signature:(const Parser::ParseTask & pt) const
operator ==	uParser.cpp	/^bool Parser::ParserState::operator==(const ParserState& state)$/;"	f	class:Parser::ParserState	signature:(const ParserState& state)
operator ==	uParser.h	/^        bool operator==(const ParseTask & pt)const;$/;"	p	struct:SHEdit::Parser::ParseTask	access:public	signature:(const ParseTask & pt) const
operator ==	uParser.h	/^        bool operator==(const ParserState& state);$/;"	p	struct:SHEdit::Parser::ParserState	access:public	signature:(const ParserState& state)
operator ==	uStack.h	/^      bool& operator==(const iterator& i){return i.ptr == ptr;}$/;"	f	struct:Stack::iterator	access:public	signature:(const iterator& i)
operator ==	uStack.h	/^    bool operator==(const Stack<T_data>& stack);$/;"	p	class:Stack	access:public	signature:(const Stack<T_data>& stack)
operator ==	uStack.h	/^bool Stack<T_data>::operator==(const Stack<T_data>& stack)$/;"	f	class:Stack	signature:(const Stack<T_data>& stack)
operator >	uIter.cpp	/^bool Iter::operator>(const Iter& itr)$/;"	f	class:Iter	signature:(const Iter& itr)
operator >	uIter.h	/^      bool operator>(const Iter& itr);$/;"	p	class:SHEdit::Iter	access:public	signature:(const Iter& itr)
out	DOCUMENTATION	/^The TSHEdit consists of 4 main parts. The component class TSHEdit, the Buffer, the Parser and the Drawer. Originally the parser and the drawer were designed to work in their own threads, but as it turned out, it was not possible since the vcl is not thread safe (and it actually causes problems even when everything is synced properly from the side of the project).$/;"	v	typeref:class:turned
parent	uDrawer.h	/^      TSHEdit * parent;$/;"	m	class:SHEdit::Drawer	access:private
parent	uParser.h	/^      TSHEdit * parent;$/;"	m	class:SHEdit::Parser	access:private
parseid	uParser.h	/^        short parseid;$/;"	m	struct:SHEdit::Parser::ParserState	access:public
parser	cSHEdit.h	/^      Parser * parser;$/;"	m	class:SHEdit::TSHEdit	access:private
parserState	uSpan.h	/^    Parser::ParserState parserState;$/;"	m	struct:SHEdit::NSpan	access:public
phpBG	uLanguageDefinitionWebLangs.h	/^      TColor phpBG;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
phpCommentTree	uLanguageDefinitionWebLangs.h	/^      TreeNode * phpCommentTree;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
phpComments	uLanguageDefinitionWebLangs.h	/^      TColor phpComments;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
phpFG	uLanguageDefinitionWebLangs.h	/^      TColor phpFG;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
phpHtmlEnterTree	uLanguageDefinitionWebLangs.h	/^      TreeNode * phpHtmlEnterTree;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
phpKeywords	uLanguageDefinitionWebLangs.h	/^      TColor phpKeywords;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
phpLineCommentTree	uLanguageDefinitionWebLangs.h	/^      TreeNode * phpLineCommentTree;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
phpQuoteTree	uLanguageDefinitionWebLangs.h	/^      TreeNode * phpQuoteTree;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
phpQuotes	uLanguageDefinitionWebLangs.h	/^      TColor phpQuotes;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
phpQuotesBack	uLanguageDefinitionWebLangs.h	/^      TColor phpQuotesBack;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
phpReserved	uLanguageDefinitionWebLangs.h	/^      TColor phpReserved;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
phpTree	uLanguageDefinitionWebLangs.h	/^      TreeNode * phpTree;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
phpVariable	uLanguageDefinitionWebLangs.h	/^      TColor phpVariable;$/;"	m	class:SHEdit::LanguageDefinitionWebLangs	access:private
places	DOCUMENTATION	/^!!!THIS FILE IS NOT UP TO DATE!! It turned out to be impossible to maintain documentation on 2 different places; $/;"	v
popcount	uLanguageDefinition.h	/^        short popcount;$/;"	m	struct:SHEdit::LanguageDefinition::Pop	access:public
popmask	uLanguageDefinition.h	/^        short popmask;$/;"	m	struct:SHEdit::LanguageDefinition::Pop	access:public
pops	uLanguageDefinition.h	/^        Pop * pops;$/;"	m	struct:SHEdit::LanguageDefinition::TreeNode	access:public
pos	uIPos.h	/^      int pos;                                                                                       \/*!< Left offset. Does treat tabs as characters. *\/$/;"	m	class:SHEdit::IPos	access:public
pos	uMark.h	/^      short pos;$/;"	m	class:SHEdit::Mark	access:public
preload	uBuffer.h	/^      Range* preload;$/;"	m	class:SHEdit::Buffer	access:private
preloadFile	uBuffer.h	/^      std::ifstream * preloadFile;$/;"	m	class:SHEdit::Buffer	access:private
prev	uSpan.h	/^    Span* prev;$/;"	m	struct:SHEdit::Span	access:public
prev	uStack.h	/^      Node ** prev;$/;"	m	struct:Stack::Node	access:public
prevline	uSpan.h	/^    NSpan * prevline;$/;"	m	struct:SHEdit::NSpan	access:public
ptr	uIter.h	/^      wchar_t * ptr;                                                                                 \/*!< Direct pointer to current character *\/$/;"	m	class:SHEdit::Iter	access:protected
ptr	uLanguageDefinition2.h	/^        Node* ptr;$/;"	m	struct:SHEdit::LanguageDefinition::StackItem	access:public
ptr	uStack.h	/^      Node * ptr;$/;"	m	struct:Stack::iterator	access:public
publish	LICENSE	/^the rights to use, copy, modify, merge, publish, distribute, sublicense,$/;"	v
pushmask	uLanguageDefinition.h	/^        short pushmask;$/;"	m	struct:SHEdit::LanguageDefinition::Jump	access:public
r	uLanguageDefinition2.h	/^        Rec r;$/;"	m	struct:SHEdit::LanguageDefinition::Node	access:public
range	uSpan.h	/^    Range * range;$/;"	m	struct:SHEdit::UndoTask	access:public
readonly	cSHEdit.h	/^      bool readonly;$/;"	m	class:SHEdit::TSHEdit	access:private
recidx	uLanguageDefinition2.h	/^        std::map<int, Node*> recidx; \/\/recursive index (for nonterminals)$/;"	m	struct:SHEdit::LanguageDefinition::Node	access:public
recmsg	cSHEdit.h	/^      bool recmsg;                                                                                   \/*!< Originally to handle re-entrancy of processmessages, but quite obsolete by now.*\/$/;"	m	class:SHEdit::TSHEdit	access:private
recpopcount	uLanguageDefinition.h	/^        short recpopcount;$/;"	m	struct:SHEdit::LanguageDefinition::TreeNode	access:public
recurse	uParser.h	/^      int recurse;$/;"	m	class:SHEdit::Parser	access:private
remember	uLanguageDefinition2.h	/^        bool remember;$/;"	m	struct:SHEdit::LanguageDefinition::Term	access:public
reserved	uLanguageDefinitionSQL.h	/^    TColor reserved;$/;"	m	class:SHEdit::LanguageDefinitionSQL	access:private
restriction	LICENSE	/^to deal in the Software without restriction, including without limitation$/;"	v
returned	.uLanguageDefinition2.h.swp	/^/;"	v
ruleid	uLanguageDefinition2.h	/^        int ruleid;$/;"	m	struct:SHEdit::LanguageDefinition::NTerm	access:public
scrolldelta	cSHEdit.h	/^      int scrolldelta;                                                                               \/*!< used by ms to treat smooth-scroll wheels...*\/$/;"	m	class:SHEdit::TSHEdit	access:private
scrolldeltafontsize	cSHEdit.h	/^      int scrolldeltafontsize;                                                                       \/*!< used by ms to treat smooth-scroll wheels...*\/$/;"	m	class:SHEdit::TSHEdit	access:private
searchColor	cSHEdit.h	/^      TColor searchColor;$/;"	m	class:SHEdit::TSHEdit	access:private
searchFormat	cSHEdit.h	/^      Format * searchFormat;$/;"	m	class:SHEdit::TSHEdit	access:private
searchStateStack	uParser.cpp	30;"	d	file:
searchStateStack	uParser.h	/^        Stack<LanguageDefinition::SearchIter> searchStateStack;$/;"	m	struct:SHEdit::Parser::ParserState	access:public
selColor	cSHEdit.h	/^      TColor selColor;$/;"	m	class:SHEdit::TSHEdit	access:private
selFColor	cSHEdit.h	/^      TColor selFColor;$/;"	m	class:SHEdit::TSHEdit	access:private
selectionFormat	cSHEdit.h	/^      Format * selectionFormat;$/;"	m	class:SHEdit::TSHEdit	access:private
so	LICENSE	/^Software is furnished to do so, subject to the following conditions:$/;"	v
st	uLanguageDefinition2.h	/^        std::stack<StackItem> st;$/;"	m	struct:SHEdit::LanguageDefinition::PState	access:public
stackRedo	uBuffer.h	/^      std::stack<UndoTask*> stackRedo;$/;"	m	class:SHEdit::Buffer	access:private
stackUndo	uBuffer.h	/^      std::stack<UndoTask*> stackUndo;$/;"	m	class:SHEdit::Buffer	access:private
state	uParser.h	/^      ParserState state;$/;"	m	class:SHEdit::Parser	access:private
string	uLanguageDefinitionSQL.h	/^    TColor string ;$/;"	m	class:SHEdit::LanguageDefinitionSQL	access:private
string	uSpan.h	/^    wchar_t* string;$/;"	m	struct:SHEdit::Span	access:public
style	uFormat.h	/^      TFontStyles style;$/;"	m	class:SHEdit::FontStyle	access:public
sublicense	LICENSE	/^the rights to use, copy, modify, merge, publish, distribute, sublicense,$/;"	v
success	fSearchBar.h	/^  bool success;$/;"	m	class:TSearchBar	access:public
t	uLanguageDefinition2.h	/^        Term* t;$/;"	m	struct:SHEdit::LanguageDefinition::Rec	access:public
tC	uLanguageDefinition2.h	/^      enum TokType {tS, tC, tE};$/;"	e	enum:SHEdit::LanguageDefinition::TokType
tE	uLanguageDefinition2.h	/^      enum TokType {tS, tC, tE};$/;"	e	enum:SHEdit::LanguageDefinition::TokType
tJump	uLanguageDefinition.h	/^  enum LangDefJumpType{tJump, tPush, tMask};$/;"	e	enum:SHEdit::LangDefJumpType
tMask	uLanguageDefinition.h	/^  enum LangDefJumpType{tJump, tPush, tMask};$/;"	e	enum:SHEdit::LangDefJumpType
tPush	uLanguageDefinition.h	/^  enum LangDefJumpType{tJump, tPush, tMask};$/;"	e	enum:SHEdit::LangDefJumpType
tS	uLanguageDefinition2.h	/^      enum TokType {tS, tC, tE};$/;"	e	enum:SHEdit::LanguageDefinition::TokType
tasklist	uParser.h	/^      std::list<ParseTask> tasklist;$/;"	m	class:SHEdit::Parser	access:private
tasklistprior	uParser.h	/^      std::list<ParseTask> tasklistprior;$/;"	m	class:SHEdit::Parser	access:private
term	uLanguageDefinition2.h	/^        bool term;$/;"	m	struct:SHEdit::LanguageDefinition::Rec	access:public
terms	uLanguageDefinition2.h	/^      std::vector<Term*> terms;$/;"	m	class:SHEdit::LanguageDefinition	access:private
text	fSearchBar.h	/^  String text;$/;"	m	class:TSearchBar	access:public
tfCall	uLanguageDefinition2.h	/^      enum flags {tfCall = 1, tfGetStyle = 2, tfGather = 4, tfGlobal = 8, tfCaseSens = 16, tfEntering = 32};$/;"	e	enum:SHEdit::LanguageDefinition::flags
tfCaseSens	uLanguageDefinition2.h	/^      enum flags {tfCall = 1, tfGetStyle = 2, tfGather = 4, tfGlobal = 8, tfCaseSens = 16, tfEntering = 32};$/;"	e	enum:SHEdit::LanguageDefinition::flags
tfEntering	uLanguageDefinition2.h	/^      enum flags {tfCall = 1, tfGetStyle = 2, tfGather = 4, tfGlobal = 8, tfCaseSens = 16, tfEntering = 32};$/;"	e	enum:SHEdit::LanguageDefinition::flags
tfGather	uLanguageDefinition2.h	/^      enum flags {tfCall = 1, tfGetStyle = 2, tfGather = 4, tfGlobal = 8, tfCaseSens = 16, tfEntering = 32};$/;"	e	enum:SHEdit::LanguageDefinition::flags
tfGetStyle	uLanguageDefinition2.h	/^      enum flags {tfCall = 1, tfGetStyle = 2, tfGather = 4, tfGlobal = 8, tfCaseSens = 16, tfEntering = 32};$/;"	e	enum:SHEdit::LanguageDefinition::flags
tfGlobal	uLanguageDefinition2.h	/^      enum flags {tfCall = 1, tfGetStyle = 2, tfGather = 4, tfGlobal = 8, tfCaseSens = 16, tfEntering = 32};$/;"	e	enum:SHEdit::LanguageDefinition::flags
thisItem	uLanguageDefinition.h	/^        wchar_t thisItem;$/;"	m	struct:SHEdit::LanguageDefinition::TreeNode	access:public
timer	cSHEdit.h	/^      TTimer * timer;$/;"	m	class:SHEdit::TSHEdit	access:private
tokenizer	uLanguageDefinition2.h	/^      WTokenizer tokenizer;$/;"	m	class:SHEdit::LanguageDefinition	access:private
tokid	uLanguageDefinition2.h	/^        int tokid;$/;"	m	struct:SHEdit::LanguageDefinition::Term	access:public
tolinenum	uSpan.h	/^    int tolinenum;$/;"	m	struct:SHEdit::Action	access:public
top	uStack.h	/^    Node * top;$/;"	m	class:Stack	typeref:struct:Stack::iterator	access:public
topos	uSpan.h	/^    int topos;$/;"	m	struct:SHEdit::Action	access:public
tree	uLanguageDefinition.h	/^      TreeNode * tree;$/;"	m	class:SHEdit::LanguageDefinition	access:private
type	uCursor.h	/^                short type;$/;"	m	class:SHEdit::CIter	access:private
type	uIPos.h	/^      IPType type;                                                                                   \/*!< Determines type of object - allows IPos casted IMark\/Iter comparisons without requiring dynamic casting. *\/$/;"	m	class:SHEdit::IPos	access:public
type	uLanguageDefinition.h	/^        LangDefSpecType type;$/;"	m	struct:SHEdit::LanguageDefinition::TreeNode	access:public
type	uLanguageDefinition.h	/^        short type;$/;"	m	struct:SHEdit::LanguageDefinition::Jump	access:public
type	uLanguageDefinition2.h	/^        NType type;$/;"	m	struct:SHEdit::LanguageDefinition::Node	access:public
type	uSpan.h	/^    ActionType type;$/;"	m	struct:SHEdit::Action	access:public
uBufferH	uBuffer.h	4;"	d
uCursorH	uCursor.h	4;"	d
uDrawerH	uDrawer.h	5;"	d
uFormatH	uFormat.h	2;"	d
uIPosH	uIPos.h	4;"	d
uIterH	uIter.h	4;"	d
uLanguageDefinition2H	uLanguageDefinition2.h	6;"	d
uLanguageDefinitionH	uLanguageDefinition.h	6;"	d
uLanguageDefinitionSQLH	uLanguageDefinitionSQL.h	4;"	d
uLanguageDefinitionWebLangsH	uLanguageDefinitionWebLangs.h	4;"	d
uMarkH	uMark.h	3;"	d
uParserH	uParser.h	5;"	d
uSpanH	uSpan.h	4;"	d
uStackH	uStack.h	4;"	d
upperbound	uParser.h	/^      int upperbound;$/;"	m	class:SHEdit::Parser	access:private
use	LICENSE	/^the rights to use, copy, modify, merge, publish, distribute, sublicense,$/;"	v
variable	uLanguageDefinitionSQL.h	/^    TColor variable;$/;"	m	class:SHEdit::LanguageDefinitionSQL	access:private
word	uIter.h	/^      Span * word;                                                                                   \/*!< Pointer to current Span in buffer's structure *\/$/;"	m	class:SHEdit::Iter	access:protected
wordBeingEdited	uBuffer.h	/^      Span * wordBeingEdited;$/;"	m	class:SHEdit::Buffer	access:private
x	uDrawer.h	/^      int x, y;$/;"	m	class:SHEdit::Drawer	access:private
y	uDrawer.h	/^      int x, y;$/;"	m	class:SHEdit::Drawer	access:private
~Action	uSpan.cpp	/^Action::~Action()$/;"	f	class:Action	signature:()
~Action	uSpan.h	/^    ~Action();$/;"	p	struct:SHEdit::Action	access:public	signature:()
~Buffer	uBuffer.cpp	/^Buffer::~Buffer()$/;"	f	class:Buffer	signature:()
~Buffer	uBuffer.h	/^      ~Buffer();$/;"	p	class:SHEdit::Buffer	access:public	signature:()
~CIter	uCursor.cpp	/^CIter::~CIter()$/;"	f	class:CIter	signature:()
~CIter	uCursor.h	/^               ~CIter();$/;"	p	class:SHEdit::CIter	access:public	signature:()
~Drawer	uDrawer.cpp	/^__fastcall Drawer::~Drawer()$/;"	f	class:Drawer	signature:()
~Drawer	uDrawer.h	/^      virtual __fastcall ~Drawer();$/;"	p	class:SHEdit::Drawer	access:public	signature:()
~Format	uFormat.cpp	/^Format::~Format()$/;"	f	class:Format	signature:()
~Format	uFormat.h	/^      ~Format();$/;"	p	class:SHEdit::Format	access:public	signature:()
~IMark	uMark.cpp	/^IMark::~IMark()$/;"	f	class:IMark	signature:()
~IMark	uMark.h	/^      ~IMark();$/;"	p	class:SHEdit::IMark	access:public	signature:()
~IPos	uIPos.cpp	/^IPos::~IPos()$/;"	f	class:IPos	signature:()
~IPos	uIPos.h	/^      ~IPos();$/;"	p	class:SHEdit::IPos	access:public	signature:()
~Iter	uIter.cpp	/^Iter::~Iter()$/;"	f	class:Iter	signature:()
~Iter	uIter.h	/^      ~Iter();$/;"	p	class:SHEdit::Iter	access:public	signature:()
~LanguageDefinition	uLanguageDefinition.cpp	/^LanguageDefinition::~LanguageDefinition()$/;"	f	class:LanguageDefinition	signature:()
~LanguageDefinition	uLanguageDefinition.h	/^      ~LanguageDefinition();$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:()
~LanguageDefinition	uLanguageDefinition2.cpp	/^LanguageDefinition::~LanguageDefinition()$/;"	f	class:LanguageDefinition	signature:()
~LanguageDefinition	uLanguageDefinition2.h	/^      ~LanguageDefinition();$/;"	p	class:SHEdit::LanguageDefinition	access:public	signature:()
~NSpan	uSpan.cpp	/^NSpan::~NSpan()$/;"	f	class:NSpan	signature:()
~NSpan	uSpan.h	/^    ~NSpan();$/;"	p	struct:SHEdit::NSpan	access:public	signature:()
~Parser	uParser.cpp	/^__fastcall Parser::~Parser()$/;"	f	class:Parser	signature:()
~Parser	uParser.h	/^      virtual __fastcall ~Parser();$/;"	p	class:SHEdit::Parser	access:public	signature:()
~ParserState	uParser.cpp	/^Parser::ParserState::~ParserState()$/;"	f	class:Parser::ParserState	signature:()
~ParserState	uParser.h	/^        ~ParserState();$/;"	p	struct:SHEdit::Parser::ParserState	access:public	signature:()
~Range	uSpan.cpp	/^Range::~Range()$/;"	f	class:Range	signature:()
~Range	uSpan.h	/^    ~Range();$/;"	p	struct:SHEdit::Range	access:public	signature:()
~Span	uSpan.cpp	/^Span::~Span()$/;"	f	class:Span	signature:()
~Span	uSpan.h	/^    ~Span();$/;"	p	struct:SHEdit::Span	access:public	signature:()
~Stack	uStack.h	/^    ~Stack();$/;"	p	class:Stack	access:public	signature:()
~Stack	uStack.h	/^Stack<T_data>::~Stack()$/;"	f	class:Stack	signature:()
~TSHEdit	cSHEdit.cpp	/^__fastcall TSHEdit::~TSHEdit()$/;"	f	class:TSHEdit	signature:()
~TSHEdit	cSHEdit.h	/^      __fastcall ~TSHEdit();$/;"	p	class:SHEdit::TSHEdit	access:public	signature:()
~UndoTask	uSpan.cpp	/^UndoTask::~UndoTask()$/;"	f	class:UndoTask	signature:()
~UndoTask	uSpan.h	/^    ~UndoTask();$/;"	p	struct:SHEdit::UndoTask	access:public	signature:()
